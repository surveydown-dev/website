[
  {
    "objectID": "question-types.html",
    "href": "question-types.html",
    "title": "Question Types",
    "section": "",
    "text": "All questions in a surveydown survey are created using the sd_question() function. Calls to sd_question() should be put inside code chunks in the survey.qmd file to define the survey questions.\nThe function requires the following three arguments:\nMany question types also require an option argument, which is a named vector of options for the question (e.g. for multiple choice questions). The function also includes many other optional arguments that can be used to customize the question appearance and behavior. See the package documentation for more details.\nBelow are examples of each question type.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Question Types"
    ]
  },
  {
    "objectID": "question-types.html#text",
    "href": "question-types.html#text",
    "title": "Question Types",
    "section": "text",
    "text": "text\nUse type = 'text' to specify a text input type question.\n\nOutputCode\n\n\n\n\n\n\nWrite a word:\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type  = \"text\",\n  id    = \"word\",\n  label = \"Write a word:\"\n)\n```",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Question Types"
    ]
  },
  {
    "objectID": "question-types.html#textarea",
    "href": "question-types.html#textarea",
    "title": "Question Types",
    "section": "textarea",
    "text": "textarea\nUse type = 'textarea' to specify a text area input type question.\n\nOutputCode\n\n\n\n\n\n\nWrite a paragraph:\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type  = \"textarea\",\n  id    = \"paragraph\",\n  label = \"Write a paragraph:\"\n)\n```",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Question Types"
    ]
  },
  {
    "objectID": "question-types.html#numeric",
    "href": "question-types.html#numeric",
    "title": "Question Types",
    "section": "numeric",
    "text": "numeric\nUse type = 'numeric' to specify a numeric input type.\n\nOutputCode\n\n\n\n\n\n\nWhat’s your age?\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type  = 'numeric',\n  id    = 'age',\n  label = \"What's your age?\"\n)\n```",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Question Types"
    ]
  },
  {
    "objectID": "question-types.html#mc",
    "href": "question-types.html#mc",
    "title": "Question Types",
    "section": "mc",
    "text": "mc\nUse type = 'mc' to specify a multiple choice type question with a single choice option.\n\nOutputCode\n\n\n\n\n\n\nWhich artist do you prefer most from this list?\n\n\n\n\n\nTaylor Swift\n\n\n\n\n\nBeyoncé\n\n\n\n\n\nAdele\n\n\n\n\n\nRihanna\n\n\n\n\n\nLady Gaga\n\n\n\n\n\nEd Sheeran\n\n\n\n\n\nDrake\n\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type   = 'mc',\n  id     = 'artist',\n  label  = \"Which artist do you prefer most from this list?\",\n  option = c(\n    \"Taylor Swift\" = \"taylor_swift\",\n    \"Beyoncé\"      = \"beyonce\",\n    \"Adele\"        = \"adele\",\n    \"Rihanna\"      = \"rihanna\",\n    \"Lady Gaga\"    = \"ladygaga\",\n    \"Ed Sheeran\"   = \"ed_sheeran\",\n    \"Drake\"        = \"drake\"\n  )\n)\n```",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Question Types"
    ]
  },
  {
    "objectID": "question-types.html#mc_multiple",
    "href": "question-types.html#mc_multiple",
    "title": "Question Types",
    "section": "mc_multiple",
    "text": "mc_multiple\nUse type = 'mc_multiple' to specify a multiple choice type question with multiple selection enabled.\n\nOutputCode\n\n\n\n\n\n\nWhat are your favorite Taylor Swift albums (select all that apply)?\n\n\n\n\n\nTaylor Swift (2006)\n\n\n\n\n\nFearless (2008)\n\n\n\n\n\nSpeak Now (2010)\n\n\n\n\n\nRed (2012)\n\n\n\n\n\n1989 (2014)\n\n\n\n\n\nReputation (2017)\n\n\n\n\n\nLover (2019)\n\n\n\n\n\nFolklore (2020)\n\n\n\n\n\nEvermore (2020)\n\n\n\n\n\nMidnights (2022)\n\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type  = 'mc_multiple',\n  id    = 'swift',\n  label = \"What are your favorite Taylor Swift albums (select all that apply)?\",\n  option = c(\n    \"Taylor Swift (2006)\" = \"taylor_swift\",\n    \"Fearless (2008)\"     = \"fearless\",\n    \"Speak Now (2010)\"    = \"speak_now\",\n    \"Red (2012)\"          = \"red\",\n    \"1989 (2014)\"         = \"1989\",\n    \"Reputation (2017)\"   = \"reputation\",\n    \"Lover (2019)\"        = \"lover\",\n    \"Folklore (2020)\"     = \"folklore\",\n    \"Evermore (2020)\"     = \"evermore\",\n    \"Midnights (2022)\"    = \"midnights\"\n  )\n)\n```",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Question Types"
    ]
  },
  {
    "objectID": "question-types.html#mc_buttons",
    "href": "question-types.html#mc_buttons",
    "title": "Question Types",
    "section": "mc_buttons",
    "text": "mc_buttons\nUse type = 'mc_buttons' to generate the button version of mc.\n\nOutputCode\n\n\n\n\n\n\nWhich fruit do you prefer most from this list?\n\n\n\n\n\nApple\n\nBanana\n\nPear\n\nStrawberry\n\nGrape\n\nMango\n\nWatermelon\n\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type   = 'mc_buttons',\n  id     = 'fruit',\n  label  = \"Which fruit do you prefer most from this list?\",\n  option = c(\n    \"Apple\"      = \"apple\",\n    \"Banana\"     = \"banana\",\n    \"Pear\"       = \"pear\",\n    \"Strawberry\" = \"strawberry\",\n    \"Grape\"      = \"grape\",\n    \"Mango\"      = \"mango\",\n    \"Watermelon\" = \"watermelon\"\n  )\n)\n```\n\n\n\n\nUse direction = \"vertical\" to display the button options vertically.\n\nOutputCode\n\n\n\n\n\n\nWhich fruit do you prefer most from this list?\n\n\n\n\n\nApple\n\nBanana\n\nPear\n\nStrawberry\n\nGrape\n\nMango\n\nWatermelon\n\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type   = 'mc_buttons',\n  id     = 'fruit',\n  label  = \"Which fruit do you prefer most from this list?\",\n  option = c(\n    \"Apple\"      = \"apple\",\n    \"Banana\"     = \"banana\",\n    \"Pear\"       = \"pear\",\n    \"Strawberry\" = \"strawberry\",\n    \"Grape\"      = \"grape\",\n    \"Mango\"      = \"mango\",\n    \"Watermelon\" = \"watermelon\"\n  ), \n  direction = \"vertical\"\n)\n```",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Question Types"
    ]
  },
  {
    "objectID": "question-types.html#mc_multiple_buttons",
    "href": "question-types.html#mc_multiple_buttons",
    "title": "Question Types",
    "section": "mc_multiple_buttons",
    "text": "mc_multiple_buttons\nUse type = 'mc_multiple_buttons' to generate the button version of mc_multiple.\n\nOutputCode\n\n\n\n\n\n\nWhich are your favorite Michael Jackson songs (select all that apply)?\n\n\n\n\n\nThriller (1982)\n\nBillie Jean (1982)\n\nBeat It (1982)\n\nMan in the Mirror (1987)\n\nSmooth Criminal (1987)\n\nBlack or White (1991)\n\nBad (1987)\n\nHuman Nature (1982)\n\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type  = 'mc_multiple_buttons',\n  id    = 'michael_jackson',\n  label = \"Which are your favorite Michael Jackson songs (select all that apply)?\",\n  option = c(\n    \"Thriller (1982)\"          = \"thriller\",\n    \"Billie Jean (1982)\"       = \"billie_jean\",\n    \"Beat It (1982)\"           = \"beat_it\",\n    \"Man in the Mirror (1987)\" = \"man_in_the_mirror\",\n    \"Smooth Criminal (1987)\"   = \"smooth_criminal\",\n    \"Black or White (1991)\"    = \"black_or_white\",\n    \"Bad (1987)\"               = \"bad\",\n    \"Human Nature (1982)\"      = \"human_nature\"\n  )\n)\n```\n\n\n\n\nUse direction = \"vertical\" to display the button options vertically.\n\nOutputCode\n\n\n\n\n\n\nWhich are your favorite Michael Jackson songs (select all that apply)?\n\n\n\n\n\nThriller (1982)\n\nBillie Jean (1982)\n\nBeat It (1982)\n\nMan in the Mirror (1987)\n\nSmooth Criminal (1987)\n\nBlack or White (1991)\n\nBad (1987)\n\nHuman Nature (1982)\n\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type  = 'mc_multiple_buttons',\n  id    = 'michael_jackson',\n  label = \"Which are your favorite Michael Jackson songs (select all that apply)?\",\n  option = c(\n    \"Thriller (1982)\"          = \"thriller\",\n    \"Billie Jean (1982)\"       = \"billie_jean\",\n    \"Beat It (1982)\"           = \"beat_it\",\n    \"Man in the Mirror (1987)\" = \"man_in_the_mirror\",\n    \"Smooth Criminal (1987)\"   = \"smooth_criminal\",\n    \"Black or White (1991)\"    = \"black_or_white\",\n    \"Bad (1987)\"               = \"bad\",\n    \"Human Nature (1982)\"      = \"human_nature\"\n  ), \n  direction = \"vertical\"\n)\n```",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Question Types"
    ]
  },
  {
    "objectID": "question-types.html#select",
    "href": "question-types.html#select",
    "title": "Question Types",
    "section": "select",
    "text": "select\nUse type = 'select' to specify a drop down select type question.\n\nOutputCode\n\n\n\n\n\n\nWhat is the highest level of education you have attained?\n\n\nChoose an option...\nDid not attend high school\nSome high school\nHigh school graduate\nSome college\nCollege\nGraduate Work\nPrefer not to say\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type  = 'select',\n  id    = 'education',\n  label = \"What is the highest level of education you have attained?\",\n  option = c(\n    \"Did not attend high school\" = \"hs_no\",\n    \"Some high school\"           = \"hs_some\",\n    \"High school graduate\"       = \"hs_grad\",\n    \"Some college\"               = \"college_some\",\n    \"College\"                    = \"college_grad\",\n    \"Graduate Work\"              = \"grad\",\n    \"Prefer not to say\"          = \"no_response\"\n  )\n)\n```",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Question Types"
    ]
  },
  {
    "objectID": "question-types.html#slider",
    "href": "question-types.html#slider",
    "title": "Question Types",
    "section": "slider",
    "text": "slider\n\n\n\n\n\n\nNote\n\n\n\nThis widget only renders well in a Shiny environment, so we just show a screenshot here.\n\n\n\nOutputCode chunk\n\n\n\n\n\n\n\n\n```{r}\nsd_question(\n  type  = 'slider',\n  id    = 'climate_care',\n  label = \"To what extent do you believe human-caused climate change is real?\",\n  option = c(\n    \"Don't Believe\"    = \"dont_believe\",\n    \"Somewhat Believe\" = \"somewhat\",\n    \"Neutral\"          = \"neutral\",\n    \"Believe\"          = \"believe\",\n    \"Strongly Believe\" = \"strongly_believe\"\n  )\n)\n```",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Question Types"
    ]
  },
  {
    "objectID": "question-types.html#date",
    "href": "question-types.html#date",
    "title": "Question Types",
    "section": "date",
    "text": "date\nUse type = 'date' to specify a date input type. The date value will be today’s date by default. Upon clicking on the text box, you are provided with a date dialog box to choose date from.\n\n\n\n\n\n\nNote\n\n\n\nThis widget only renders well in a Shiny environment, so we just show a screenshot here.\n\n\n\nOutputCode\n\n\n\n\n\n\n\n\n```{r}\nsd_question(\n  type  = 'date',\n  id    = 'dob',\n  label = \"What is your date of birth?\"\n)\n```",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Question Types"
    ]
  },
  {
    "objectID": "question-types.html#daterange",
    "href": "question-types.html#daterange",
    "title": "Question Types",
    "section": "daterange",
    "text": "daterange\nUse type = 'daterange' to specify a date range input type.\n\n\n\n\n\n\nNote\n\n\n\nThis widget only renders well in a Shiny environment, so we just show a screenshot here.\n\n\n\nOutputCode\n\n\n\n\n\n\n\n\n```{r}\nsd_question(\n  type  = 'daterange',\n  id    = 'hs_date',\n  label = \"When did you start and finish high school?\"\n)\n```",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Question Types"
    ]
  },
  {
    "objectID": "question-types.html#matrix",
    "href": "question-types.html#matrix",
    "title": "Question Types",
    "section": "matrix",
    "text": "matrix\nUse type = 'matrix' to specify a matrix input type.\n\nOutputCode\n\n\n\n\n\n\nPlease indicate your agreement with the following statements.\n\n\n\n\n\n\n\n\n\n\n\n\nDisagree\nNeutral\nAgree\n\n\n\n\nbuy_gasoline\n\n\n\n\n\n  Disagree \n\n\n  Neutral \n\n\n  Agree \n\n\n\n*\n\n\n\nbuy_ev\n\n\n\n\n\n  Disagree \n\n\n  Neutral \n\n\n  Agree \n\n\n\n*\n\n\n\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type   = \"matrix\",\n  id     = \"car_preference\",\n  label  = \"Please indicate your agreement with the following statements.\",\n  row    = c(\n    \"buy_gasoline\" = \"I'd like to buy a gasoline car.\",\n    \"buy_ev\"       = \"I'd like to buy an EV.\"\n  ),\n  option = c(\n    \"Disagree\" = \"disagree\",\n    \"Neutral\"  = \"neutral\",\n    \"Agree\"    = \"agree\"\n  )\n)\n```",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Question Types"
    ]
  },
  {
    "objectID": "survey-components.html",
    "href": "survey-components.html",
    "title": "Survey Components",
    "section": "",
    "text": "Every surveydown survey is composed of a survey and an app, defined in two separate files:\n\nsurvey.qmd: A Quarto document that contains the survey content (pages, questions, etc), which renders to an HTML file.\napp.R: An R script defining a Shiny app that contains the global settings (libraries, database configuration, etc.) and server configuration options (e.g., conditional skipping / display, etc.).\n\nThese files must be named survey.qmd and app.R.\nThey typically look something like this:\n\nsurvey.qmd fileapp.R file\n\n\n\n---\nformat: html\necho: false\nwarning: false\n---\n\n```{r}\nlibrary(surveydown)\n```\n\n::: {#welcome .sd-page}\n\n# Welcome to our survey!\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'penguins',\n  label = \"Which type of penguin do you like the best?\",\n  option = c(\n    'Adélie'    = 'adelie',\n    'Chinstrap' = 'chinstrap',\n    'Gentoo'    = 'gentoo'\n  )\n)\n\nsd_next(next_page = 'end')\n```\n\n:::\n\n::: {#end .sd-page}\n\nThis it the last page in the survey\n\n:::\n\n\n\n\nlibrary(surveydown)\n\ndb &lt;- sd_database(\n  host   = \"\",\n  dbname = \"\",\n  port   = \"\",\n  user   = \"\",\n  table  = \"\",\n  ignore = TRUE\n)\n\nserver &lt;- function(input, output, session) {\n\n  # Define conditional skip logic here (skip to page if a condition is true)\n  sd_skip_if()\n\n  # Define  conditional display logic here (show a question if a condition is true)\n  sd_show_if()\n\n  # Main server to control the app\n  sd_server()\n}\n\nshiny::shinyApp(ui = sd_ui(), server = server)",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Survey Components"
    ]
  },
  {
    "objectID": "survey-components.html#overview",
    "href": "survey-components.html#overview",
    "title": "Survey Components",
    "section": "",
    "text": "Every surveydown survey is composed of a survey and an app, defined in two separate files:\n\nsurvey.qmd: A Quarto document that contains the survey content (pages, questions, etc), which renders to an HTML file.\napp.R: An R script defining a Shiny app that contains the global settings (libraries, database configuration, etc.) and server configuration options (e.g., conditional skipping / display, etc.).\n\nThese files must be named survey.qmd and app.R.\nThey typically look something like this:\n\nsurvey.qmd fileapp.R file\n\n\n\n---\nformat: html\necho: false\nwarning: false\n---\n\n```{r}\nlibrary(surveydown)\n```\n\n::: {#welcome .sd-page}\n\n# Welcome to our survey!\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'penguins',\n  label = \"Which type of penguin do you like the best?\",\n  option = c(\n    'Adélie'    = 'adelie',\n    'Chinstrap' = 'chinstrap',\n    'Gentoo'    = 'gentoo'\n  )\n)\n\nsd_next(next_page = 'end')\n```\n\n:::\n\n::: {#end .sd-page}\n\nThis it the last page in the survey\n\n:::\n\n\n\n\nlibrary(surveydown)\n\ndb &lt;- sd_database(\n  host   = \"\",\n  dbname = \"\",\n  port   = \"\",\n  user   = \"\",\n  table  = \"\",\n  ignore = TRUE\n)\n\nserver &lt;- function(input, output, session) {\n\n  # Define conditional skip logic here (skip to page if a condition is true)\n  sd_skip_if()\n\n  # Define  conditional display logic here (show a question if a condition is true)\n  sd_show_if()\n\n  # Main server to control the app\n  sd_server()\n}\n\nshiny::shinyApp(ui = sd_ui(), server = server)",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Survey Components"
    ]
  },
  {
    "objectID": "survey-components.html#the-survey.qmd-file",
    "href": "survey-components.html#the-survey.qmd-file",
    "title": "Survey Components",
    "section": "The survey.qmd file",
    "text": "The survey.qmd file\nThe survey.qmd file is where you define the main survey content of your survey, such as pages, questions, and navigation buttons. It is a standard Quarto document, so you can use markdown (or the RStudio visual editor) to insert text, images, etc. just like you would in any Quarto document.\n\n\n\n\n\n\nNote\n\n\n\nYou do NOT need to render the survey.qmd file, and in fact we do not recommend doing so as the rendered output will not necessarily look like your final survey. Instead, to preview your survey you should locally run your app.\n\n\n\nYAML header\nThe YAML header is at the top of the survey.qmd file. It contains some basic settings, like this:\n---\nformat: html\necho: false\nwarning: false\n---\nThe only required setting is format: html, as the document should render as an HTML document. The other settings are optional, though we recommend you keep them to ensure a good experience for your respondents. Typically you wouldn’t want warnings or the code defining the survey questions to be displayed in your survey - that’s what the echo: false and warning: false settings are for.\n\n\nChanging the look and feel\nBecause the survey.qmd is a Quarto document, you can use any of the Quarto formatting options to change the look and feel of your survey.\nFor example, you can change the overall survey theme using the theme key:\n---\ntheme: united # Any bootswatch theme \n---\nThere are 25 bootswatch themes to choose from. You can also provide a custom.scss file to further modify the theme, or even combine the two, e.g.:\n---\ntheme: [united, custom.scss]\n---\n\n\nProgress bar\nYou can modify the survey progress bar with the barcolor and barposition keys, e.g.:\n---\nbarcolor: \"#768692\"\nbarposition: top \n---\nThe barcolor key defines the color of the progress bar. It defaults to the primary theme color, but you can change it to any hex code you wish here to overwrite the theme color.\nThe barposition key defines the position of the progress bar. It defaults to top, but can also be changed to bottom or none (to remove the bar). The progress bar updates on every question the user clicks on, not pages.\nThe rest of the content in the survey.qmd file is the content you want in your survey, including pages, navigation buttons, and questions.\n\n\nAdding pages\nIn surveydown, pages are defined using fences (:::), like this:\n\n::: {#welcome .sd-page}\n\nPage 1 content here\n\n:::\n\n::: {#page2 .sd-page}\n\nPage 2 content here\n\n:::\n\nAs you can see, we use three colon symbols :::, called a “fence”, to mark the start and end of pages. This notation is commonly used in Quarto for a variety of use cases, like defining subfigures in images.\nIn the starting fence, you need to define a page name (e.g. welcome and page2 in the example above) and you need to define the class as .sd-page. Then anything you put between the page fences will appear on that page.\n\n\nAdding navigation buttons\nTo navigate to the next page, you need to insert a sd_next() function call inside a code chunk, like this:\n\n```{r}\nsd_next()\n```\n\nThe above code chunk will create a “Next” button that goes on to the immediate next page. The button will look like this:\n\n\n\nNext\n\n\n\nYou can also send the user to other pages by just changing the value assigned to the next_page argument. For example, to send the user to a page with the id page3, you can use:\n\n```{r}\nsd_next(next_page = 'page3')\n```\n\nFinally, you can also change the label of the button by changing the label argument, like this:\n\n```{r}\nsd_next(label = 'Next page')\n```\n\n\n\n\nNext page\n\n\n\n\n\nAdding questions\nEvery survey question is created using the sd_question() function inside a code chunk. The question type is defined by the type argument. For example, to add a multiple choice question, you could insert the following code chunk:\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'penguins',\n  label = \"Which is your favorite type of penguin?\",\n  option = c(\n    'Adélie'    = 'adelie',\n    'Chinstrap' = 'chinstrap',\n    'Gentoo'    = 'gentoo'\n  )\n)\n```\n\nThe above code chunk will create a multiple choice question that looks like this:\n\n\n\n\nWhich is your favorite type of penguin?\n\n\n\n\n\nAdélie\n\n\n\n\n\nChinstrap\n\n\n\n\n\nGentoo\n\n\n\n\n*\n\n\n\nThe sd_question() function can be used to create a variety of question types, like text input, select drop down choices, and more by changing the type argument (see the Questions Types page).\nThe function has many other arguments for customizing the look and feel of the question, such as the height and width (see the Formatting Questions page).\nBy default all questions are optional, but you can make questions required in the server options (see the Server Options page for details).\n\n\nEnding the survey\nThe simplest way to end a survey is to create a page with no sd_next() button on it. This will effectively serve as a ending page, because the respondent will not be able to navigate anywhere else once reaching a page with no next button.\nFor example, you may want to have a screen-out page that respondents are sent to if they answer a certain way on a question (e.g., see conditional skipping. You can do this by creating a page with no sd_next() button on it, like this:\n\n::: {#screenout .sd-page}\n\nSorry, you are not eligible for this survey.\n\nYou can close this window now.\n\n:::\n\nWhen a respondent reaches this page, they will not be able to navigate anywhere else, so the survey is over.\nYou can also add a button to end the survey programmatically using the sd_close() function inside a code chunk, like this:\n\n```{r}\nsd_close(label = 'Close window')\n```\n\nThis will create a button with the label “Close window” that the respondent can click on to close the survey window. This button can be added anywhere in the survey, not necessarily on the last page - all it does is close the browser window.\nFinally, you can also add a button to end the survey and redirect the respondent to another page. You can do this using the sd_redirect() function, like this:\n\nCode chunkOutput\n\n\n\nsd_redirect(\n  id     = \"redirect\",\n  url    = \"https://www.google.com\",\n  label  = \"Redirect to Google\",\n  button = TRUE,\n  newtab = TRUE\n)\n\n\n\n\n\n\n\nRedirect to Google\n\n\n\n\n\n\n\nThis will create a button with the label “Redirect to Google” that the respondent can click on to be redirected to Google. You can also customize the url to include url parameters. See the External Redirects page for more details.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Survey Components"
    ]
  },
  {
    "objectID": "survey-components.html#the-app.r-file",
    "href": "survey-components.html#the-app.r-file",
    "title": "Survey Components",
    "section": "The app.R file",
    "text": "The app.R file\nThe app.R file is where you define the global settings and server logic for your survey. It defines a Shiny app, so if you are familiar with Shiny you should feel right at home. The main components of the app.R file are:\n\nGlobal settings: where you load the surveydown package and define the database connection.\nServer: where you define the logic of the survey (conditional skipping / display, etc.)\n\n\nGlobal settings\nThe global settings are at the top of the app.R file. At a minimum, you need to load the surveydown package and define the database connection. You can also load other packages / global objects here if you need to. It typically looks like this:\n\nlibrary(surveydown)\n\ndb &lt;- sd_database(\n  host   = \"\",\n  dbname = \"\",\n  port   = \"\",\n  user   = \"\",\n  table  = \"\"\n)\n\nThe db object is used to store survey data - see the Store Data page for details on how to set up the database connection.\n\n\nServer\nThe server() function is a standard Shiny server function that takes input, output, and session as arguments. It is where you can set custom control logic and other configuration options, such as conditional display logic with the sd_show_if() function, or conditional skip logic with the sd_skip_if() function.\nIf you create a new survey using a template, the server() function looks like this:\n\nserver &lt;- function(input, output, session) {\n\n  # Define conditional skip logic (skip to page if a condition is true)\n  sd_skip_if()\n\n  # Define conditional display logic (show a question if a condition is true)\n  sd_show_if()\n\n  # Main server to control the app\n  sd_server(db = db)\n\n}\n\nThe sd_server() function at the bottom makes everything run. It also includes some optional arguments that you can use to customize the survey.\nSee the Server Options page for details on the different options you can use to customize the server.\n\n\n\n\n\n\nNote\n\n\n\nThe db = db argument in sd_server() is required if you are using a database connection, which should be defined using the sd_database() function as mentioned above in the Global Settings section. See the Store Data page for more details.\n\n\n\n\nRun code\nAt the very bottom of the app.R file, you will see the following code:\n\nshiny::shinyApp(ui = sd_ui(), server = server)\n\nThis code defines the Shiny app and should always be at the bottom of the app.R file.\n\n\n\n\n\n\nNote\n\n\n\nWhat’s with the sd_ui() thing?\nIn a typical Shiny app, you have to define the UI and server functions separately. In a surveydown survey, the UI is a fixed structure that is defined by the sd_ui() function, so simply provide it to the ui argument in shiny::shinyApp() to run the survey.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Survey Components"
    ]
  },
  {
    "objectID": "survey-components.html#locally-running-the-survey",
    "href": "survey-components.html#locally-running-the-survey",
    "title": "Survey Components",
    "section": "Locally running the survey",
    "text": "Locally running the survey\nTo preview your survey, you can run the Shiny app locally by clicking the “Run App” button in RStudio or in your R console run the code shiny::runApp('app.R'). Typically, RStudio will launch the app in a new window, but you can also choose to have the app launch in a dedicated viewer pane, or in your external web browser. Make your selection by clicking the icon next to Run App:",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Survey Components"
    ]
  },
  {
    "objectID": "question-formatting.html",
    "href": "question-formatting.html",
    "title": "Question Formatting",
    "section": "",
    "text": "The sd_question() function has many optional arguments for modifying the appearance and behavior of questions. This page demonstrates some of the formatting options.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Question Formatting"
    ]
  },
  {
    "objectID": "question-formatting.html#markdown-formatting",
    "href": "question-formatting.html#markdown-formatting",
    "title": "Question Formatting",
    "section": "Markdown formatting",
    "text": "Markdown formatting\nMarkdown is supported for question labels and option labels.\n\nQuestion labels\nThe label argument for any question type can accept markdown formatting. For example, the question below uses the * symbol to make some words bold, italic, and bold italic.\n\nCode chunkOutput\n\n\n\n```{r}\nsd_question(\n  type   = 'mc',\n  id     = 'markdown_label',\n  label  = \"**This** is a question *label* supporting ***markdown***:\",\n  option = c(\n    \"Option A\" = \"option_a\",\n    \"Option B\" = \"option_b\",\n    \"Option C\" = \"option_c\"\n  )\n)\n```\n\n\n\n\n\n\n\nThis is a question label supporting markdown:\n\n\n\n\n\nOption A\n\n\n\n\n\nOption B\n\n\n\n\n\nOption C\n\n\n\n\n*\n\n\n\n\n\n\n\n\nOption labels\nMarkdown formatting is also supported for the option labels in question types that have options, such as mc, mc_multiple, mc_buttons, and mc_multiple_buttons. For example:\n\nCode chunkOutput\n\n\n\n```{r}\nsd_question(\n  type   = 'mc_buttons',\n  id     = 'markdown_buttons',\n  label  = \"The 3 options below support markdown:\",\n  option = c(\n    \"*Option A*\"     = \"option_a\",\n    \"**Option B**\"   = \"option_b\",\n    \"***Option C***\" = \"option_c\"\n  )\n)\n```\n\n\n\n\n\n\n\nThe 3 options below support markdown:\n\n\n\n\n\n\n\nOption A\n\n\n\n\n\nOption B\n\n\n\n\n\nOption C\n\n\n\n\n\n\n*",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Question Formatting"
    ]
  },
  {
    "objectID": "question-formatting.html#html-formatting",
    "href": "question-formatting.html#html-formatting",
    "title": "Question Formatting",
    "section": "HTML formatting",
    "text": "HTML formatting\nHTML formatting is supported for the option labels in question types that have options, such as mc_buttons and mc_multiple_buttons. This allows you to insert mixed content to achieve more complex labels, including plain text, markdown, and HTML code.\nFor example, here is a question with some complex labels for a choice question that include markdown and HTML code to embed images.\n\nCode chunkOutput\n\n\n\n```{r}\n# Define the option vector\nhtml_button_options &lt;- c(\"option_1\", \"option_2\", \"option_3\")\n\n# Define option labels that include markdown and HTML code to embed images\nnames(html_button_options) &lt;- c(\n\n  \"**Option 1**&lt;br&gt;\n   &lt;img src='https://raw.githubusercontent.com/surveydown-dev/demo-conjoint-survey/main/images/fuji.jpg' width=100&gt;&lt;br&gt;\n   **Type**: Fuji&lt;br&gt;\n   **Price**: $ 2 / lb&lt;br&gt;\n   **Freshness**: Average\",\n\n  \"**Option 2**&lt;br&gt;\n   &lt;img src='https://raw.githubusercontent.com/surveydown-dev/demo-conjoint-survey/main/images/pinkLady.jpg' width=100&gt;&lt;br&gt;\n    **Type**: Pink Lady&lt;br&gt;\n    **Price**: $ 1.5 / lb&lt;br&gt;\n    **Freshness**: Excellent\",\n\n  \"**Option 3**&lt;br&gt;\n    &lt;img src='https://raw.githubusercontent.com/surveydown-dev/demo-conjoint-survey/main/images/honeycrisp.jpg' width=100&gt;&lt;br&gt;\n    **Type**: Honeycrisp&lt;br&gt;\n    **Price**: $ 2 / lb&lt;br&gt;\n    **Freshness**: Poor\"\n)\n\nsd_question(\n  type   = 'mc_buttons',\n  id     = 'html_buttons',\n  label  = \"A sample survey question using `mc_buttons`\",\n  option = html_button_options\n)\n```\n\n\n\n\n\n\n\nA sample survey question using mc_buttons\n\n\n\n\n\n\n\nOption 1Type: FujiPrice: $ 2 / lbFreshness: Average\n\n\n\n\n\nOption 2Type: Pink LadyPrice: $ 1.5 / lbFreshness: Excellent\n\n\n\n\n\nOption 3Type: HoneycrispPrice: $ 2 / lbFreshness: Poor\n\n\n\n\n\n\n*",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Question Formatting"
    ]
  },
  {
    "objectID": "question-formatting.html#size-formatting",
    "href": "question-formatting.html#size-formatting",
    "title": "Question Formatting",
    "section": "Size formatting",
    "text": "Size formatting\nUse the width, height arguments to change the size of the question.\nFor example, the question below uses the width and height arguments to change the size of a text area question.\n\nCode chunkOutput\n\n\n\n```{r}\nsd_question(\n  type  = \"textarea\",\n  id    = \"change_width\",\n  label = \"This text area has width set as 40% and height set as 100px:\",\n  width = \"40%\", \n  height = \"100px\"\n)\n```\n\n\n\n\n\n\n\nThis text area has width set as 40% and height set as 100px:\n\n\n\n*",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Question Formatting"
    ]
  },
  {
    "objectID": "conditional-control.html",
    "href": "conditional-control.html",
    "title": "Conditional Control",
    "section": "",
    "text": "All survey configuration settings are defined within the server function in the app.R file. The server() function is a standard Shiny server function that takes input, output, and session as arguments.\nIf you create a new survey using a template, the server() function looks like this:\nserver &lt;- function(input, output, session) {\n\n  # Define conditional skip logic (skip to page if a condition is true)\n  sd_skip_if()\n\n  # Define conditional display logic (show a question if a condition is true)\n  sd_show_if()\n\n  # Main server to control the app\n  sd_server(db = db)\n\n}\nThe sd_skip_if() and sd_show_if() functions are used to define conditional skip and show logic for the survey. This page details how to use each of these functions to control many aspects of the survey flow logic.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Conditional Control"
    ]
  },
  {
    "objectID": "conditional-control.html#conditional-display",
    "href": "conditional-control.html#conditional-display",
    "title": "Conditional Control",
    "section": "Conditional display",
    "text": "Conditional display\nIt is often useful to have a question display based on some condition, such as the respondent choosing a particular value in a multiple choice question.\nFor example, let’s say we have a choice question about people’s favorite penguin type, and the last option is “other”. If the respondent chose it, you may want a second question to display that allows them to specify the “other” penguin type, like this:\n\n\n\n\nTo implement this, you first need to define both the conditional question and the target question in the survey.qmd file, like this:\n\n```{r}\n# Conditional question\nsd_question(\n  type  = \"mc\",\n  id    = \"penguins\",\n  label = \"Which is your favorite type of penguin?\",\n  option = c(\n    \"Adélie\"    = \"adelie\",\n    \"Chinstrap\" = \"chinstrap\",\n    \"Gentoo\"    = \"gentoo\",\n    \"Other\"     = \"other\"\n  )\n)\n\n# Target question\nsd_question(\n  type  = \"text\",\n  id    = \"penguins_other\", \n  label = \"Please specify the other penguin type:\"\n)\n```\n\nThen in the server function in the app.R file, you can use the sd_show_if() function to define that the \"penguins_other\" question would only be shown if the respondent chose the \"other\" option in the \"penguins\" question, like this:\n\nserver &lt;- function(input, output, session) {\n\n  sd_show_if(\n    input$penguins == \"other\" ~ \"penguins_other\" \n  )\n\n  sd_server(db = db)\n\n}\n\nYou can provide multiple conditions to the sd_show_if() function, each separated by a comma. The structure for each condition in the sd_show_if() function is always:\n\n&lt;condition&gt; ~ \"target_question_id\"\n\nIn the example above, input$penguins == \"other\" is the condition, and \"penguins_other\" is the target question that will be shown if the condition is met. The ~ symbol is used to separate the condition from the target question.\n\n\n\n\n\n\nNote\n\n\n\nThe input object is a Shiny object that stores each question id defined by sd_question() in your survey.qmd file, so whenever referring to a question in a condition, you must use the format input$question_id.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Conditional Control"
    ]
  },
  {
    "objectID": "conditional-control.html#conditional-skipping",
    "href": "conditional-control.html#conditional-skipping",
    "title": "Conditional Control",
    "section": "Conditional skipping",
    "text": "Conditional skipping\nOften times you’ll want to send respondents to different parts of the survey based on some condition, such as the respondent choosing a particular value in a multiple choice question.\nFor example, let’s say you want to screen out people who do not own a vehicle. To do this, you would first define a question in your survey.qmd file about their vehicle ownership, e.g.:\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'vehicle_ownership',\n  label = \"Do you own your vehicle?\",\n  option = c(\n    'Yes' = 'yes',\n    'No'  = 'no'\n  )\n)\n```\n\nYou would also need to define a screenout page to send respondents to, like this:\n\n::: {#screenout .sd-page}\n\nSorry, but you are not qualified to take our survey.\n\n:::\n\nThen in the server function in the app.R file, you can use the sd_skip_if() function to define the condition under which the respondent will be sent to the target screenout page, like this:\n\nserver &lt;- function(input, output, session) {\n\n  sd_skip_if(\n    input$vehicle_ownership == \"no\" ~ \"screenout\"\n  )\n\n  sd_server(db = db)\n\n}\n\nJust like the sd_show_if() function, you can provide multiple conditions to the sd_skip_if() function, each separated by a comma. The structure for each condition in the sd_skip_if() function is always:\n\n&lt;condition&gt; ~ \"target_page_id\"\n\nIn the example above, input$vehicle_ownership == \"no\" is the condition, and \"screenout\" is the target page that the respondent will be sent to if the condition is met.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Conditional Control"
    ]
  },
  {
    "objectID": "conditional-control.html#common-conditions",
    "href": "conditional-control.html#common-conditions",
    "title": "Conditional Control",
    "section": "Common conditions",
    "text": "Common conditions\nBoth the sd_show_if() and sd_skip_if() functions require a condition that returns a logical value (TRUE or FALSE). The condition can be defined in a number of ways. In this section, we’ll highlight some of the most common types of conditions you might need.\n\n\n\n\n\n\nNote\n\n\n\nThe show_if demo showcases how to use the sd_show_if() function with a variety of different conditions, but the same principles apply to conditions used in the sd_skip_if() function.\n\n\n\nConditioning on question answers\nOne of the most common situations is conditioning on the value of a single question or multiple questions, like this:\n\nsd_show_if(\n\n # Simple condition based on single question choice\n input$penguins1 == \"other\" ~ \"penguins1_other\",\n\n # Multiple condition based on multiple question choices\n input$penguins2 == \"other\" & input$show_other == \"show\" ~ \"penguins2_other\"\n\n)\n\nIn the first condition, the penguins1 question is checked to see if the respondent chose the \"other\" option. If they did, the penguins1_other question will be shown.\nIn the second condition, the penguins2 question is checked to see if the respondent chose the \"other\" option, and the show_other question is checked to see if the respondent chose the \"show\" option. With this condition, the penguins2_other question will only be shown if both conditions are TRUE.\n\n\nNumeric values\nAnother common condition is checking the value of a numeric question. To do so, you need to wrap the input$question_id in the as.numeric() function because all question values are stored as strings, like this:\n\nsd_show_if(\n as.numeric(input$car_number) &gt; 1 ~ \"car_ownership\"\n)\n\nIn the condition above, the car_number question is checked to see if the respondent chose a number greater than 1. If they did, the car_ownership question will be shown.\n\n\nMultiple response questions\nFor multiple response question types (e.g. mc_multiple), the question returns a vector storing all the chosen values. You can use this vector to check for different conditions, such as whether the chosen values are in some set of values using the %in% operator, or whether the respondent chose a number of options using the length() function, like this:\n\nsd_show_if(\n\n # Check if the respondent chose \"apple\", \"banana\", or both\n all(input$fav_fruits %in% c(\"apple\", \"banana\")) ~ \"apple_or_banana\",\n\n # Check if the respondent chose more than 3 fruits\n length(input$fav_fruits) &gt; 3 ~ \"fruit_number\"\n\n)\n\nIn the first example, the fav_fruits question is checked to see if the respondent chose \"apple\", \"banana\", or both; if so, the apple_or_banana question will be shown.\nIn the second example, the fav_fruits question is checked to see if the respondent chose more than 3 fruits; if so, the fruit_number question will be shown.\n\n\nConditioning on answered status\nYou may want to show a target question if a question is answered at all or not. To do this, we created the sd_is_answered() function that returns TRUE if a question is answered and FALSE otherwise.\nFor example, let’s say you had a multiple choice question fav_fruit that asked you to choose your favorite fruit from a list of options, and a target question num_fruit that asked how many fruit you eat per day. If we wanted to show the num_fruit question so long as the fav_fruit question is answered, we can use sd_is_answered(\"fav_fruit\") in the sd_show_if() function, like this:\n\nsd_show_if(\n  sd_is_answered(\"fav_fruit\") ~ \"num_fruit\" \n)\n\nThis way, as long as the fav_fruit question is answered, no matter which option the user picks the num_fruit question will appear.\nFor \"matrix\" type questions, sd_is_answered() will only be TRUE if all sub-questions (matrix rows)in it are answered.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Conditional Control"
    ]
  },
  {
    "objectID": "conditional-control.html#conditions-with-custom-functions",
    "href": "conditional-control.html#conditions-with-custom-functions",
    "title": "Conditional Control",
    "section": "Conditions with custom functions",
    "text": "Conditions with custom functions\nFor situations where the conditional logic is more complex, we recommend defining a custom function that will return a logical value (TRUE or FALSE). You can then pass this function to the sd_show_if() or sd_skip_if() functions as a condition.\nFor example, let’s say we had a mc type question where we asked how many cars the respondent owned, and we included numeric options 1 through 5 as well as a final option \"6 or more\". If we wanted to set a condition that would return TRUE if the user had more than one car, we could not use as.numeric(input$question_id) &gt; 1 because this would return NA if the respondent chose the \"6 or more\" option.\nTo address this, we could create a custom function to handle this special condition:\n\nserver &lt;- function(input, output, session) {\n\n  more_than_one_car &lt;- function(input) {\n    num_cars &lt;- as.numeric(input$car_number)\n    if (is.na(num_cars)) { return(TRUE) }\n    return(num_cars &gt; 1)\n  }\n\n  sd_show_if(\n    more_than_one_car(input) ~ \"car_ownership\"\n  )\n\n  sd_server(db = db)\n\n}\n\nIn the more_than_one_car() function, we first obtain the numeric value of the car_number question using as.numeric(input$car_number). If this value is NA it indicates that the respondent chose the \"6 or more\" option, in which case we return TRUE. If not, then we can be sure that num_cars is a number, and we can return the simple condition num_cars &gt; 1.\nNote that here the more_than_one_car function is defined in the condition without () after it. This is because we are passing the function itself, not the result of the function.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Conditional Control"
    ]
  },
  {
    "objectID": "faq.html",
    "href": "faq.html",
    "title": "Frequently Asked Questions",
    "section": "",
    "text": "Note\n\n\n\nHave a question but don’t see an answer here? Feel free to make a post on GitHub:\n\nPost a bug report or documentation issue on the GitHub repo issues page.\nAsk a question, make a feature request, start a discussion, or show off your project on the discussion board."
  },
  {
    "objectID": "faq.html#how-do-i-make-a-question-required",
    "href": "faq.html#how-do-i-make-a-question-required",
    "title": "Frequently Asked Questions",
    "section": "How do I make a question required?",
    "text": "How do I make a question required?\nUse the required_questions argument in sd_server() to control required responses (see the required questions page for more details)."
  },
  {
    "objectID": "faq.html#why-is-my-shinyapps-deployment-failing",
    "href": "faq.html#why-is-my-shinyapps-deployment-failing",
    "title": "Frequently Asked Questions",
    "section": "Why is my shinyapps deployment failing?",
    "text": "Why is my shinyapps deployment failing?\nFirst, make sure everything is correctly defined, including your Supabase project settings and password settings. The password in your project folder should be the same as your Supabase project password (see here for how to set the password). Then, make sure your survey runs on your local machine and can successfully link with your Supabase project table. With these confirmed, your shinyapps deployment should work without problem.\nIf you still encounter an error (e.g., the page shows the app failed to start, or you see the page but it doesn’t run properly), try clearing your cache. The simplest way to do so is to reboot your computer. It may also help if you delete previously generated files, such as the survey.html file if you rendered it and the rsconnect folder. After re-rendering, you should be able to deploy the app without error."
  },
  {
    "objectID": "faq.html#why-cant-i-install-the-package",
    "href": "faq.html#why-cant-i-install-the-package",
    "title": "Frequently Asked Questions",
    "section": "Why can’t I install the package?",
    "text": "Why can’t I install the package?\n1. Install from the repo (recommended)\nUsually, we install a package by the install.packages() function. For example:\n\ninstall.packages(\"tidyverse\")\n\nHowever, this function is only effective for packages on CRAN, a database that stores the R packages. Since surveydown is still under construction, it’s not available on CRAN yet (but it will be).\nNow the recommended way of installing surveydown is to install it directly from its GitHub repo:\n\nremotes::install_github(\"surveydown-dev/surveydown\", force = TRUE)\n\n2. Download the source code and install locally (alternative)\nIf you still cannot have your package installed, it could be because that your path was managed by some package managing system like Anaconda. An alternative is to download the zip file of surveydown and install it locally.\nTo download the zip file, go the the surveydown repo, click on the green “Code” button and click on “Download Zip”, or simplify click on this link.\nUnzip this repo, and open the surveydown.Rproj file. In your R Console panel, run this code to install:\n\ndevtools::install(force = TRUE)"
  },
  {
    "objectID": "faq.html#how-to-set-a-password-for-my-surveydown-project-and-why-do-i-need-a-password",
    "href": "faq.html#how-to-set-a-password-for-my-surveydown-project-and-why-do-i-need-a-password",
    "title": "Frequently Asked Questions",
    "section": "How to set a password for my surveydown project, and why do I need a password?",
    "text": "How to set a password for my surveydown project, and why do I need a password?\nIn Supabase (the database we use for surveydown), we need a password to access the database and establish connection. In surveydown, we’ve prepared a function for you: sd_set_password(). This function helps you set up your password that can be used to connect to Supabase. It is also the password for your admin page.\nBelow is what sd_set_password() exactly does:\nFor example, say your password is MyPassword. Then you define your password by:\n\nsd_set_password(\"MyPassword\")\n\nAfter you defined your password, restart your R session by clicking on “Session” on your menu and choose “Restart R”.\nThis will save your password into a newly created .Renviron file. The statement looks like this:\n\nSURVEYDOWN_PASSWORD=MyPassword\n\nThen, this function also adds the .Renviron file into your .gitignore file (if you want to store your project on GitHub), so that it won’t be pushed to your GitHub repo. Your password is always stored locally on your machine.\nYou need to make sure that this password you defined matches with your Supabase project (in this case, it should be MyPassword).\nThere is no defined sequence in these 2 above moves. You can define your Supabase project password first, and then define your local password using sd_set_password(), or you can do it inversely. The only thing that matters is when you attempt to connect to Supabase using your survey, these 2 passwords should match.\nFor more information about setting password, proceed to the password page."
  },
  {
    "objectID": "installation.html",
    "href": "installation.html",
    "title": "Installation",
    "section": "",
    "text": "You need both:\n\nInstall \nInstall Quarto\n\nWe also recommend working with an IDE that has good support for R, Quarto, and Shiny.\nRStudio is great, and we also like VSCode and Positron.",
    "crumbs": [
      "Documentation",
      "Installation"
    ]
  },
  {
    "objectID": "installation.html#install-r-quarto",
    "href": "installation.html#install-r-quarto",
    "title": "Installation",
    "section": "",
    "text": "You need both:\n\nInstall \nInstall Quarto\n\nWe also recommend working with an IDE that has good support for R, Quarto, and Shiny.\nRStudio is great, and we also like VSCode and Positron.",
    "crumbs": [
      "Documentation",
      "Installation"
    ]
  },
  {
    "objectID": "installation.html#install-the-surveydown-r-package",
    "href": "installation.html#install-the-surveydown-r-package",
    "title": "Installation",
    "section": "Install the {surveydown} R package",
    "text": "Install the {surveydown} R package\nYou can install {surveydown} from CRAN in your R console:\n\ninstall.packages(\"surveydown\")\n\nor you can install the development version from GitHub:\n\n# install.packages(\"pak\")\npak::pak('surveydown-dev/surveydown')\n\nLoad the package with:\n\nlibrary(surveydown)\n\nYou can also check which version you have installed:\n\nsurveydown::sd_version()",
    "crumbs": [
      "Documentation",
      "Installation"
    ]
  },
  {
    "objectID": "tips.html",
    "href": "tips.html",
    "title": "Tips",
    "section": "",
    "text": "This page has some helpful suggestions for working with surveydown surveys.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Tips"
    ]
  },
  {
    "objectID": "tips.html#programmatically-generate-survey-questions",
    "href": "tips.html#programmatically-generate-survey-questions",
    "title": "Tips",
    "section": "Programmatically generate survey questions",
    "text": "Programmatically generate survey questions\nYou can use  code to programmatically generate survey questions in your survey.qmd file, which can be useful if you have a large number of questions that are similar to each other. One way to do this is to first create a data frame with the question parameters, and then use the sd_question() function to create the questions.\nHere’s an example using map() over the items data frame to generate a list of questions. Note that the list of questions is wrapped in shiny::tagList(), which is necessary for the survey to render properly since the map() function returns a list.\n\n\n\n\n\n\nNote\n\n\n\nThis approach inserts all the questions on the same page. We haven’t found a way to insert these questions on different pages, which would require more sophistication in the map() function.\n\n\n\nCode chunkOutput\n\n\n\n```{r}\n# Generate data frame of question parameters\nitems &lt;- tibble::tibble(\n  type = \"mc\",\n  id = as.character(1:3),\n  label = LETTERS[1:3],\n  option = list(c(\n    \"None\" = \"0\", \n    \"A Little\" = \"1\",\n    \"A lot\" = \"2\"\n  ))\n)\n\n# Generate questions\nshiny::tagList(\n  purrr::map(1:nrow(items), function(i) {\n    args &lt;- items[i, ]\n    sd_question(\n      id     = as.character(args$id),\n      type   = args$type,\n      label  = args$label,\n      option = unlist(args$option)\n    )\n  })\n)\n```\n\n\n\n\n\n\n\nA\n\n\n\n\n\nNone\n\n\n\n\n\nA Little\n\n\n\n\n\nA lot\n\n\n\n\n*\n\n\n\nB\n\n\n\n\n\nNone\n\n\n\n\n\nA Little\n\n\n\n\n\nA lot\n\n\n\n\n*\n\n\n\nC\n\n\n\n\n\nNone\n\n\n\n\n\nA Little\n\n\n\n\n\nA lot\n\n\n\n\n*",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Tips"
    ]
  },
  {
    "objectID": "documentation.html",
    "href": "documentation.html",
    "title": "surveydown.org",
    "section": "",
    "text": "Welcome to your first surveydown survey!\nWe recommend reading the Getting Started page to get a sense of how to use surveydown. The rest of the documentation covers more details on how to use surveydown.\n\nClick here to get started!\n\n\n\nFeatures\n\n\n\n\n    \n\n    \n    \n      \n        \n        \n              \n                Progress\n                Feature\n              \n        \n        \n        \n                \n                                       \n                  Wide variety of question types                                                          \n                \n                \n                                       \n                  Ability to use latest survey results in the survey itself                 \n                \n                \n                                       \n                  Pause database connection                                          \n                \n                \n                                       \n                  Conditionally display questions                                     \n                \n                \n                                       \n                  Conditionally skip to pages                                        \n                \n                \n                                       \n                  Start survey from a specific page (helpful when editing)                  \n                \n                \n                                       \n                  Show all pages at once (helpful for editing or printing out whole survey)\n                \n                \n                                       \n                  Require specific questions be answered                               \n                \n                \n                                       \n                  Require all questions be answered                                    \n                \n                \n                                       \n                  Create a random numeric completion code                     \n                \n                \n                                       \n                  Time stamps recorded for each question and page interaction                                                               \n                \n                \n                                       \n                  Auto scroll according to the answering progress                             \n                \n                \n                                       \n                  Progress bar bar that updates on each question interaction              \n                \n                \n                                       \n                  Customizable progress bar color                                         \n                \n                \n                                       \n                  Customizable progress bar position                                      \n                \n                \n                                       \n                  Markdown formatting for options and buttons                             \n                \n                \n                                       \n                  Support for bootstrap themes                              \n                \n                \n                                       \n                  Customizable scss theme file                              \n                \n                \n                                       \n                  Pass parameters through the url, e.g. to track user IDs                     \n                \n                \n                                       \n                  Redirect users to an external url                                                          \n                \n                \n                  \n                  Admin page with password login to preview / download data, pause survey, etc.\n                \n                \n                  \n                  Form validation (limit input based on question type)                                                                      \n                \n                \n                  \n                  Cookies to store user progress                                                                                            \n                \n        \n      \n    \n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Documentation"
    ]
  },
  {
    "objectID": "demos.html",
    "href": "demos.html",
    "title": "Demos",
    "section": "",
    "text": "Question Types\nA demo of all the question types currently supported by surveydown.\n\n\n  GitHub Repo     Demo Survey \n\n\n\n\n\n\n\nConditional Display\nA demo of how to implement conditional display (showing a question based on a previous response).\n\n\n  GitHub Repo     Demo Survey \n\n\n\n\n\n\n\nConditional Skipping\nA demo of how to implement conditional skipping (skipping to a page based on a previous response).\n\n\n  GitHub Repo     Demo Survey \n\n\n\n\n\n\n\nChoice-Based Conjoint\nA demo of how to implement a choice-based conjoint survey with surveydown.\n\n\n  GitHub Repo     Demo Survey \n\n\n\n\n\n\n\nRandomized Question Labels\nA demo of how to implement randomized question labels.\n\n\n  GitHub Repo     Demo Survey \n\n\n\n\n\n\n\nRandomized Question Labels (Predefined)\nA demo of how to implement randomized question labels using predefined random labels.\n\n\n  GitHub Repo     Demo Video \n\n\n\n\n\n\n\nReactive Plot\nA demo of how to implement a reactive plot (a summary plot of all prior response data updated in real time).\n\n\n  GitHub Repo     Demo Video \n\n\n\n\n\n\n\nExternal Redirect\nA demo of how to implement external redirection links in your survey.\n\n\n  GitHub Repo     Demo Video \n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "store-data.html",
    "href": "store-data.html",
    "title": "Storing Data",
    "section": "",
    "text": "The surveydown package is designed to work with any PostgreSQL database. Since many may not want to create such a database on their own, we recommend using Supabase, which is a free, open-source PostgreSQL database service.\nIn this guide, we’ll walk you through the steps to set up a Supabase project and connect your surveydown survey to it.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Store Data"
    ]
  },
  {
    "objectID": "store-data.html#create-a-supabase-account",
    "href": "store-data.html#create-a-supabase-account",
    "title": "Storing Data",
    "section": "Create a Supabase account",
    "text": "Create a Supabase account\nNavigate to the Supabase website and create an account. You may use your GitHub account or create a new account using your email.\nWhile creating your account, it’s by default that you will have an organization under your account name. Your projects will be designated to this organization. You can have other organizations based on your need, but let’s just use this default one for now.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Store Data"
    ]
  },
  {
    "objectID": "store-data.html#create-a-supabase-project",
    "href": "store-data.html#create-a-supabase-project",
    "title": "Storing Data",
    "section": "Create a Supabase project",
    "text": "Create a Supabase project\nOnce you are logged in, the page will prompt you to create a project. It’s an obvious green button. Click on it and select your organization. A dialog box will pop up like this:\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nOne Supabase project can support multiple surveydown surveys if you wish, but we recommend that you have only one survey per project to avoid potential mistakes.\n\n\nFill in the project name and give it a strong password. Choose a region that is close to you (or close to your audiences). All settings can be modified at any time.\n\n\n\n\n\n\nImportant\n\n\n\nOnce you set the password, don’t forget to also set the same password in surveydown with sd_set_password(). Go to the Password page for details.\nYou will need this both to communicate with your Supabase project and also to log in to your admin page, should you decide to enable it.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Store Data"
    ]
  },
  {
    "objectID": "store-data.html#copy-your-credentials",
    "href": "store-data.html#copy-your-credentials",
    "title": "Storing Data",
    "section": "Copy your credentials",
    "text": "Copy your credentials\nOnce your Supabase project is ready, go to “Project Settings” located at the bottom-left corner. Then, click on “Database” under “Configuration”.\nYou’ll see the “Connection parameters” section like this:\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nThis is also where you change the password of your Supabase project.\n\n\nNow, deliver these parameters to your app! In your app.R file, you define sd_database() at the top before defining the server() function. Anything loaded here is globally accessible, so this is where your database configuration should go. In the template it looks like this:\n\ndb &lt;- sd_database(\n  host   = \"\",\n  dbname = \"\",\n  port   = \"\",\n  user   = \"\",\n  table  = \"any_name\"\n)\n\nCopy and paste the first 4 parameters from your Supabase page to sd_database(), aka “Host”, “Database name”, “Port”, and “User”. Again, your password should be defined using sd_set_password() in your R console, NOT in the app.R file.\nThe last parameter, table, can be any string you want. After your survey gets running, a table with this name will appear in “Table Editor” of your Supabase project. It’s located at the top-left corner of the page.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Store Data"
    ]
  },
  {
    "objectID": "store-data.html#tips",
    "href": "store-data.html#tips",
    "title": "Storing Data",
    "section": "Tips",
    "text": "Tips\n\nIgnoring the Supabase connection\nWhile editing your survey, you may want to not connect to the database. This can be easily implemented by setting ignore = TRUE in sd_database():\n\ndb &lt;- sd_database(\n  # Previous parameters...\n  ignore = TRUE\n)\n\nWith this setting, your connection parameters can remain set, but the survey will not attempt to connect to your database. Instead, a local data.csv file will be created in your project folder so you can preview the survey data.\n\n\nDisabling gssencmode\nIf you’ve set everything correctly but still encounter connection error, try to disable gssencmode like this:\n\ndb &lt;- sd_database(\n  # Previous parameters...\n  gssencmode = \"disable\"\n)\n\nBy default, gssencmode is set as \"prefer\". It secures your connection with PostgreSQL, which is the SQL used by Supabase. We generally recommend that you DO NOT disable gssencmode, but sometimes this is necessary, especially when you are working on a protected network, e.g. on a VPN.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Store Data"
    ]
  },
  {
    "objectID": "password.html",
    "href": "password.html",
    "title": "Setting Your Password",
    "section": "",
    "text": "Every surveydown survey requires a password, which is used to communicate with the Supabase database and access the admin page (should you choose to enable it).",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Password"
    ]
  },
  {
    "objectID": "password.html#setting-your-project-password",
    "href": "password.html#setting-your-project-password",
    "title": "Setting Your Password",
    "section": "Setting your project password",
    "text": "Setting your project password\nTo set your surveydown password in a given project, run:\n\nsd_set_password(\"your_password\")\n\n\n\n\n\n\n\nImportant\n\n\n\nDo NOT put the sd_set_password() function in your app.R file!\n\n\nThis is designed to be run once in your R console and not again (unless you want to change the password).",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Password"
    ]
  },
  {
    "objectID": "password.html#what-does-this-do",
    "href": "password.html#what-does-this-do",
    "title": "Setting Your Password",
    "section": "What does this do?",
    "text": "What does this do?\nBy running sd_set_password(), the following happens:\n\nA .Renviron file is created in your project directory that contains your password stored as an environment variable, e.g., SUPABASE_PASSWORD=my_password.\nIf there is a previously defined SUPABASE_PASSWORD in .Renviron, it will be overwritten, so you are safe to run this function multiple times.\nA .gitignore file is created in your project directory with .Renviron in it so it won’t be accidentally pushed to GitHub. If a .gitignore file already exists, it will be updated to include .Renviron.\n\nThe .Renviron file must remain in the root project directory - do not manually modify it",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Password"
    ]
  },
  {
    "objectID": "password.html#what-is-the-password-used-for",
    "href": "password.html#what-is-the-password-used-for",
    "title": "Setting Your Password",
    "section": "What is the password used for?",
    "text": "What is the password used for?\nYour password is used for two purposes:\n\nObtaining access to the Supabase database storing your survey data (see Store Data).\nObtaining access to the admin page of your survey.\n\n\n\n\n\n\n\nImportant\n\n\n\nBe sure to use the same password when setting up your Supabase database.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Password"
    ]
  },
  {
    "objectID": "password.html#forgot-your-password",
    "href": "password.html#forgot-your-password",
    "title": "Setting Your Password",
    "section": "Forgot your password?",
    "text": "Forgot your password?\nTo reveal your password, run:\n\nsd_show_password()\n\n\n\n\n\n\n\nImportant\n\n\n\nThis is a one-time operation, so you can also run in your R console. You will be prompted to confirm you really want to reveal your password, since it is a sensitive operation.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Password"
    ]
  },
  {
    "objectID": "security.html",
    "href": "security.html",
    "title": "Security",
    "section": "",
    "text": "There are three main security considerations when working with a surveydown survey:\nWhile we have worked to make our application code secure, it is ultimately up to you to choose appropriate host and data storage environments that are also secure for your needs.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Security"
    ]
  },
  {
    "objectID": "security.html#the-surveydown-application-code",
    "href": "security.html#the-surveydown-application-code",
    "title": "Security",
    "section": "The surveydown application code",
    "text": "The surveydown application code\nThe application code refers to the resulting Shiny app generated from a surveydown survey. Since surveydown users will be collecting potentially sensitive data from survey respondents, we have tried to develop the platform with data security in mind. We have taken care to follow many best practices, such as using SQL injection prevention strategies in how we store the survey response data, and ensuring that users store their database passwords as environment variables that are also added to a .gitignore file. We also adopted an architecture where all content on any page in the survey is served entirely from the shiny server, meaning that respondents taking the survey cannot see the underlying html source code for any of the content being displayed in the survey. This is important so respondents cannot see content on other pages (e.g., completion codes) before getting there from the survey navigation buttons.\nDespite our efforts, however, we do not (yet) have any form of security compliance certificate that we can provide. This means we cannot guarantee the application code is compliant with common security protocols, such as SOC2 Type 2 or HIPPA. This is an eventual goal, but for now this is a limitation for using this package for some domains that require certain certifications.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Security"
    ]
  },
  {
    "objectID": "security.html#the-hosting-environment",
    "href": "security.html#the-hosting-environment",
    "title": "Security",
    "section": "The hosting environment",
    "text": "The hosting environment\n\nShinyapps.io\nThe free service we use for hosting a surveydown survey is shinyapps.io, which is not HIPPA compliant. According to the Posit Documentation on Security and Compliance for shinyapps.io:\n\nshinyapps.io is currently hosted on Amazon’s Web Services (AWS) infrastructure in the us-east-1 region. The infrastructure used is not the HIPAA-compliant stack, so if you need to be in a HIPAA-compliant environment, we recommend deploying and operating your own Posit Connect or Shiny Server Open Source instance.\n\nThis means that if you require a HIPPA compliant hosting service, we recommend that follow Posit’s guidelines and deploy your own instance of Posit Connect.\n\n\nOther Hosting Services\nYou can deploy shiny apps to other hosting services. Here are some guides for several other alternatives:\n\nPosit Connect Cloud\nHugging Face\nHeroku\n\nYou can also install Posit Connect on your own server, which is the recommended approach for remaining compliant with any security protocols your organization requires.\nWhatever hosting service you choose, please read carefully about the security implications of the environment you choose.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Security"
    ]
  },
  {
    "objectID": "security.html#the-data-storage-environment",
    "href": "security.html#the-data-storage-environment",
    "title": "Security",
    "section": "The data storage environment",
    "text": "The data storage environment\nWe designed surveydown to be able to store data on any PostgreSQL database. This gives you flexibility on where you choose to store your data, and it is up to you to find a suitable host.\nFortunately, the default service we recommend using (Supabase) is actually SOC2 Type 2 and HIPPA compliant 🎉\nAs with the hosting service, please choose a data storage environment carefully and read about the security implications of the environment you choose.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Security"
    ]
  },
  {
    "objectID": "external-resources.html",
    "href": "external-resources.html",
    "title": "External Resources",
    "section": "",
    "text": "Often times you will want to include external resources in your survey, things like images, videos, etc. While you can easily include these in your survey.qmd file by referencing their location in your survey project folder, these resources may not always be available in the shiny app defined in your app.R file.\nTo address this, you should always place external resources in a separate folder and then make sure that folder is added to Shiny’s resource path. You can do this in your app.R file by using the sd_include_folder() function at the beginning of the file after loading the surveydown package, like this:\nlibrary(surveydown)\n\nsd_include_folder(\"resources\")\nThis will make all files in a folder called resources available to Shiny.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "External Resources"
    ]
  },
  {
    "objectID": "external-resources.html#default-folders",
    "href": "external-resources.html#default-folders",
    "title": "External Resources",
    "section": "Default folders",
    "text": "Default folders\nThe surveydown package will automatically add the following folders to Shiny’s resource path:\n\nwww\nimages\ncss\njs\n\nIf any of these folders exist in your project, they will automatically be added to Shiny’s resource path. For this reason, we recommend that you always put images inside a images folder in your project directory, css files inside a css folder, and so on. This will make it easier to manage your resources and ensure that they are always available to Shiny.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "External Resources"
    ]
  },
  {
    "objectID": "performance.html",
    "href": "performance.html",
    "title": "Performance",
    "section": "",
    "text": "Our goal in designing surveydown was to create a package that was both performant and easy to use. While we’ve worked to ensure that the package is efficient, the ultimate performance of your survey in the field will depend on the services you use to host your app, store your data, and field your survey.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Performance"
    ]
  },
  {
    "objectID": "performance.html#hosting",
    "href": "performance.html#hosting",
    "title": "Performance",
    "section": "Hosting",
    "text": "Hosting\nWe recommend using shinyapps.io to host your survey as it is designed to work with Shiny Apps. The platform offers a free tier that should work well for most simple surveys. However, more complex surveys may require paid plans to achieve better performance.\nOne thing you can do to improve the performance is to max out the memory settings for your app in the “settings” tab in your app dashboard. It should look something like this:\n\n\n\n\nThe free tier allows for 1 GB of memory, and paid plans can go up much higher (this screenhot is from an earlier period when the free tier memory limits were larger).\nThe other thing to consider is the number of active hours (the free tier allows for 25 active hours per month).\nDepending on your needs, a paid plan may be worth the investment during your actual survey fielding to ensure a smooth user experience. And of course, you can consider other hosting services that might have better options.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Performance"
    ]
  },
  {
    "objectID": "performance.html#database",
    "href": "performance.html#database",
    "title": "Performance",
    "section": "Database",
    "text": "Database\nThe surveydown package is designed to work with any PostgreSQL database, but we recommend using Supabase to store your survey responses as it is a fast, reliable, and scalable PostgreSQL database. Like shinyapps.io, Supabase offers a free tier that should work well for most simple surveys, but a paid plan may be needed if you expect to have a large number of concurrent respondents.\nThe free tier allows for 20 concurrent database connections, but since surveydown uses a pooled connection to the database, this limit not directly translate to a hard limit of 20 concurrent respondents.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Performance"
    ]
  },
  {
    "objectID": "performance.html#fielding-options",
    "href": "performance.html#fielding-options",
    "title": "Performance",
    "section": "Fielding Options",
    "text": "Fielding Options\nMany researchers use panel providers like Prolific to recruit respondents for their surveys. Given the large number of potential concurrent respondents, you may want to place a limit on the number of people who can complete your survey at once to avoid overloading your app. On prolific, for example, you can set a quota in your study settings, which looks something like this:\n\n\n\n\nAnother option to consider is what types of devices your respondents will be completing your survey on. You may want to test how your survey renders on phones versus computers to see if there are siginificant differences. Some panel providers have options to limit which devices respondents can use to take the survey. On prolific this looks like this:\n\n\n\n\nMany panel providers offer these kinds of fielding options, and we recommend checking with your panel provider to help prevent overloading your app.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Performance"
    ]
  },
  {
    "objectID": "blog/index.html",
    "href": "blog/index.html",
    "title": "Blog",
    "section": "",
    "text": "New architecture in v0.3.0 (and loads of breaking changes)!\n\n\n\n\n\nWe’re releasing v0.3.0, and with it multiple breaking changes. \n\n\n\n\n\n2024-09-18\n\n\nJohn Paul Helveston\n\n\n\n\n\n\n\n\n\n\n\n\nChoice-based conjoint surveys in R with surveydown\n\n\n\n\n\nA how-to guide for using R to design and implement choice-based conjoint surveys using the surveydown R package \n\n\n\n\n\n2024-08-28\n\n\nJohn Paul Helveston\n\n\n\n\n\n\n\n\n\n\n\n\nIntroducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny\n\n\n\n\n\nA quick overview of the {surveydown} R package for making markdown-based surveys with open-source technologies: Quarto, shiny, and supabase. \n\n\n\n\n\n2024-08-21\n\n\nJohn Paul Helveston\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to surveydown.org!",
    "section": "",
    "text": "Welcome to surveydown.org!\nsurveydown is a flexible, open-source platform for making surveys with , Quarto, Shiny, and Supabase.\n\n\n\n\n\nAbout the package and the open-source technologies behind it.\n\n\nABOUT\n\n\n\n\n\n\n\n\nDemos showcasing surveydown features.\n\n\nDEMOS\n\n\n\n\n\n\n\n\nDocumentation for building surveys with surveydown.\n\n\nDOCUMENTATION\n\n\n\n\n\n\n\n\nFrequently asked questions.\n\n\nFAQ\n\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "template.html",
    "href": "template.html",
    "title": "Start with a Template",
    "section": "",
    "text": "We recommend starting with a template to build your surveydown survey.\nIn the R console, run the following to to setup a template survey:\nsurveydown::sd_create_survey(\"path/to/folder\")\nThis will create a folder located at \"path/to/folder\" with the following files:",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Start with a Template"
    ]
  },
  {
    "objectID": "template.html#single-vs-multiple-file-structure",
    "href": "template.html#single-vs-multiple-file-structure",
    "title": "Start with a Template",
    "section": "Single vs Multiple File Structure",
    "text": "Single vs Multiple File Structure\nThe app.R file defines the Shiny app, which by default is a single file. If you wish to define your app using separate files, you can do so by setting the structure argument to \"multi\" in the sd_create_survey() function. This will create a template with four files:\n\nsurveydown::sd_create_survey(\"path/to/folder\", structure = \"multi\")\n\n\nsurvey.qmd: a template survey where you define your survey content (text, questions, images, etc.).\nui.R: The main UI file for the Shiny app. It will only contain the sd_ui() function.\nserver.R: a template server file where you define the server logic of the app.\nglobal.R: a template global file where you define any global variables, libraries, or functions.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Start with a Template"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Overview",
    "section": "",
    "text": "Overview\nsurveydown is a flexible, open-source platform for making surveys with , Quarto, Shiny, and Supabase.\n\n\n\n\n\nThe basic concept is:\n\nDesign your survey as a Quarto document using markdown and R code.\nConvert your survey into a Shiny app that can be hosted online and sent to respondents.\nStore your survey responses in a Supabase database (or any PostgreSQL database).\n\nThe {surveydown} R package provides functions to bring this all together.\nWe recommend reading the Getting Started page to get a sense of how to use surveydown. The rest of the documentation covers more details on how to use surveydown.\n\nClick here to get started!\n\n\n\nBackground & Motivation\nMost survey platforms (e.g., Google forms, Qualtrics, etc.) use drag-and-drop interfaces to design surveys, making version control and collaboration with others difficult. They’re also not reproducible (others cannot easily reproduce a survey made on these platforms), and many require a paid subscription or license to use.\nThe surveydown package was designed to address these problems. As an open-source, markdown-based platform, all survey content is defined with plain text (markdown and R code) in a survey.qmd file and an app.R file that renders your survey into a Shiny app that can be hosted online. This makes your survey easy to reproduce, share, and version control with common tools like Git. The survey data collected is also owned by the survey designer in a separate PostgreSQL database (we recommend Supabase as a free and open-source database provider).\nIf you’re curious where this whole idea came from, check out this blog post, which outlines more on the general idea and the motivation for it. The post is now outdated in terms of the overall package design, but it provides something of an origin story and some of the motivation for developing this project.\n\n\nAuthors\nThe surveydown project is led by professor John Paul Helveston at George Washington University. The development team consists of the following members:\n\n\n\n\n\nJohn Paul Helveston, Ph.D.\nJohn Paul Helveston is an Assistant Professor in the Department of Engineering Management and Systems Engineering at George Washington University. Professor Helveston is the core designer and developer, and maintainer of both the surveydown project and this documentation website.\n\n\n\n\n\n\n\nPingfan Hu\nPingfan Hu is a Ph.D. student in Systems Engineering at George Washington University, supervised by professor Helveston. Pingfan is mainly responsible for UI design, user interactions, and website maintenance.\n\n\n\n\n\n\n\nBogdan Bunea\nBogdan Bunea is an undergraduate student majoring in Systems Engineering and minoring in Computer Science at George Washington University. Bogdan is mainly responsible for database connection and data management.\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "deployment.html",
    "href": "deployment.html",
    "title": "Deploying Your Survey",
    "section": "",
    "text": "Before deploying your survey, make sure everything is working locally. You should have done the following:\n\nYou have locally previewed your app.R file by clicking the “Run App” button in RStudio or in your R console running the code shiny::runApp('app.R').\nYou have set up a database connection to store survey responses (e.g. using Supabase) and have already added the database parameters in the sd_database() function in your app.R file (see the Store Data page).\nYou have set the password for your survey using surveydown::sd_set_password(\"my_password\") using the password you set in the Supabase project (see the Password page).\n\nWith these steps completed, you are ready to deploy your survey online.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Deployment"
    ]
  },
  {
    "objectID": "deployment.html#preparing-to-deploy",
    "href": "deployment.html#preparing-to-deploy",
    "title": "Deploying Your Survey",
    "section": "",
    "text": "Before deploying your survey, make sure everything is working locally. You should have done the following:\n\nYou have locally previewed your app.R file by clicking the “Run App” button in RStudio or in your R console running the code shiny::runApp('app.R').\nYou have set up a database connection to store survey responses (e.g. using Supabase) and have already added the database parameters in the sd_database() function in your app.R file (see the Store Data page).\nYou have set the password for your survey using surveydown::sd_set_password(\"my_password\") using the password you set in the Supabase project (see the Password page).\n\nWith these steps completed, you are ready to deploy your survey online.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Deployment"
    ]
  },
  {
    "objectID": "deployment.html#deploying-to-shinyapps.io",
    "href": "deployment.html#deploying-to-shinyapps.io",
    "title": "Deploying Your Survey",
    "section": "Deploying to shinyapps.io",
    "text": "Deploying to shinyapps.io\nDeploying your survey is pretty much the same as deploying any other Shiny app. We recommend using shinyapps.io to host your survey as it is designed to work with Shiny Apps, but you can also use other hosting services.\n\n\n\n\n\n\nNote\n\n\n\nYou may have deployed other Quarto documents on Quarto Pub before, but this site is only for static websites, so you SHOULD NOT use Quarto Pub for your survey deployment.\n\n\nTo start using shinyapps.io, you’ll need to create an account and follow the basic instructions to set up your sub-domain and authorize your IDE. See more information here.\nOnce you have your account and sub-domain ready, make sure you have the rsconnect package installed. You should have done this while authorizing your IDE, but in case you didn’t, you can install it with:\n\ninstall.packages('rsconnect')\n\nThen to deploy your survey, run:\n\n# Define your app name with the appName parameter\nrsconnect::deployApp(appName = \"My Survey\")\n\nThat’s it! Now you should have your survey site deployed on shinyapps.io. Congratulations! 🎉",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Deployment"
    ]
  },
  {
    "objectID": "deployment.html#deploying-to-other-hosting-services",
    "href": "deployment.html#deploying-to-other-hosting-services",
    "title": "Deploying Your Survey",
    "section": "Deploying to Other Hosting Services",
    "text": "Deploying to Other Hosting Services\nYou can deploy shiny apps to other hosting services. Here are some guides for several other alternatives:\n\nPosit Connect Cloud\nHugging Face\nHeroku\n\nYou can also install Posit Connect on your own server, which is the recommended approach for remaining compliant with any security protocols your organization requires.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Deployment"
    ]
  },
  {
    "objectID": "fetch-data.html",
    "href": "fetch-data.html",
    "title": "Fetching Data",
    "section": "",
    "text": "Once you have your database properly set up and your survey is live, you can fetch the data using the sd_get_data() function. All you have to do is pass in the db object you created with sd_database() to the sd_get_data() function.\nFor example, if you have a table called my_table in your Supabase database:\n\ndb &lt;- sd_database(\n  host   = \"my_host\",\n  dbname = \"my_dbname\",\n  port   = \"my_port\",\n  user   = \"my_user\",\n  table  = \"my_table\"\n)\n\nYou can fetch the data like this:\n\ndata &lt;- sd_get_data(db)\n\nHere the data object will be a data.frame with the data from your database.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Fetch Data"
    ]
  },
  {
    "objectID": "fetch-data.html#static-fetching",
    "href": "fetch-data.html#static-fetching",
    "title": "Fetching Data",
    "section": "",
    "text": "Once you have your database properly set up and your survey is live, you can fetch the data using the sd_get_data() function. All you have to do is pass in the db object you created with sd_database() to the sd_get_data() function.\nFor example, if you have a table called my_table in your Supabase database:\n\ndb &lt;- sd_database(\n  host   = \"my_host\",\n  dbname = \"my_dbname\",\n  port   = \"my_port\",\n  user   = \"my_user\",\n  table  = \"my_table\"\n)\n\nYou can fetch the data like this:\n\ndata &lt;- sd_get_data(db)\n\nHere the data object will be a data.frame with the data from your database.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Fetch Data"
    ]
  },
  {
    "objectID": "fetch-data.html#reactive-fetching",
    "href": "fetch-data.html#reactive-fetching",
    "title": "Fetching Data",
    "section": "Reactive Fetching",
    "text": "Reactive Fetching\n\n\n\n\n\n\nTip\n\n\n\nRun the Demo survey of a reactive plot for an example of reactively fetching data.\n\n\nThe above example is intended for an analysis context, where all you want to do is fetch the latest data from your database. However, you may also want to fetch the data in a reactive context (i.e. in your survey). For example, perhaps you want to show respondents a bar chart of the most common responses to a question. The sd_get_data() function is compatible with reactive fetching as well - just call it inside the server() function in your app.R file:\n\nserver &lt;- function(input, output, session) {\n\n  data &lt;- sd_get_data(db)\n\n  sd_server()\n\n}\n\nNow the data object will be a reactive expression, not a data.frame. To use it, you have to call it with () to get the latest data as a data.frame. For example:\n\nserver &lt;- function(input, output, session) {\n\n  data &lt;- sd_get_data(db, refresh_interval = 5)\n\n  output$my_plot &lt;- renderPlot({  \n    my_data &lt;- data()\n    # insert code here to make a plot with my_data\n  })\n\n  sd_server()\n\n}\n\nHere the my_data object will be a data.frame with the latest data from your database, refreshed every 5 sections according to the refresh_interval parameter (5 seconds is the default value), which you could then use to make a plot.\nIn this example, the output$my_plot object will be a plot, which you can then display in your survey by placing plotOutput(\"my_plot\") in a code chunk somewhere in your survey.qmd file.\nSee the Reactivity page for more information on how to use reactivity in your survey.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Fetch Data"
    ]
  },
  {
    "objectID": "blog/2024-09-18-new-app-design/index.html",
    "href": "blog/2024-09-18-new-app-design/index.html",
    "title": "New architecture in v0.3.0 (and loads of breaking changes)!",
    "section": "",
    "text": "The surveydown package is only a couple months old, and thanks to many early users we learned about some design flaws that needed to be fixed. As a result, with the release of {surveydown} 0.3.0, the package has undergone a major overhaul to improve security, modularity, and extensibility.\nWe introduced several major breaking changes in this release, so we felt we should make a blog post to both explain why we felt these changes were needed as well as introduce the new architecture we have adopted."
  },
  {
    "objectID": "blog/2024-09-18-new-app-design/index.html#motivation",
    "href": "blog/2024-09-18-new-app-design/index.html#motivation",
    "title": "New architecture in v0.3.0 (and loads of breaking changes)!",
    "section": "Motivation",
    "text": "Motivation\nIn the original conception of surveydown, the entire survey was defined in a single Quarto shiny document that would render into a shiny app. While this was a rather parsimonious design, it also had some flaws that weren’t immediately apparent.\nPerhaps the largest issue was page security (see this issue). With Quarto shiny documents, the qmd file is first rendered into a static html page that is then used to define the elements of the user interface in the resulting shiny app. This meant that for us to introduce pages, we relied on a combination of JS and CSS to hide and show the page divs based on users clicking on next buttons. While this resulted in a nice user experience, under the hood the entire app was still just one big html page with all of the content available.\nThis design meant that anyone could still see the source code to any component of the survey they wanted. A user could simply right-click and open “Inspect” then manually change the CSS of a page div from style=\"display: none;\" to style=\"display: show;\" and boom - the “page” would appear!\nThis was obviously a major security issue as pages with things like completion codes or redirect buttons at the end could be easily shown without going through the whole survey. The only solution was an architectural overhaul that would only show the content on one page at a time."
  },
  {
    "objectID": "blog/2024-09-18-new-app-design/index.html#new-architecture",
    "href": "blog/2024-09-18-new-app-design/index.html#new-architecture",
    "title": "New architecture in v0.3.0 (and loads of breaking changes)!",
    "section": "New architecture",
    "text": "New architecture\nThe new architecture employs a two-file design composed of a survey and an app that renders to a traditional Shiny app:\n\nsurvey.qmd: A Quarto document that contains the survey content (pages, questions, etc), which renders to an HTML file.\napp.R: An R script defining a Shiny app that contains the global settings (libraries, database configuration, etc.) and server configuration options (e.g., conditional skipping / display, etc.).\n\nThese files must be named survey.qmd and app.R.\nThey typically look something like this:\n\nsurvey.qmd fileapp.R file\n\n\n\n---\nformat: html\necho: false\nwarning: false\n---\n\n```{r}\nlibrary(surveydown)\n```\n\n::: {#welcome .sd-page}\n\n# Welcome to our survey!\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'penguins',\n  label = \"Which type of penguin do you like the best?\",\n  option = c(\n    'Adélie'    = 'adelie',\n    'Chinstrap' = 'chinstrap',\n    'Gentoo'    = 'gentoo'\n  )\n)\n\nsd_next(next_page = 'end')\n```\n\n:::\n\n::: {#end .sd-page}\n\nThis it the last page in the survey\n\n:::\n\n\n\n\n\nlibrary(surveydown)\n\ndb &lt;- sd_database(\n  host   = \"\",\n  dbname = \"\",\n  port   = \"\",\n  user   = \"\",\n  table  = \"\",\n  ignore = TRUE\n)\n\nserver &lt;- function(input, output, session) {\n\n  # Define conditional skip logic here (skip to page if a condition is true)\n  sd_skip_if()\n\n  # Define  conditional display logic here (show a question if a condition is true)\n  sd_show_if()\n\n  # Main server to control the app\n  sd_server()\n}\n\nshiny::shinyApp(ui = sd_ui(), server = server)\n\n\n\n\nThis approach allows us to separate the survey content (in the survey.qmd file) from the survey logic (in the app.R file), which comes with a few benefits:\n\nSecurity: Since the rendered survey content is no longer directly embedded in the app as a single html page, it makes it much harder for users to tamper with the content. Only the content on one page at a time will be rendered by the server.\nClarity: With two files, it is now clearer where the survey content versus control logic should be defined. Before, all of the server logic was in a single server code chunk at the end of the survey.qmd file, which required the user to scroll up and down to edit the server logic versus the survey content. Now a user can have both files open in two tabs in an IDE and more easily edit the survey content and server content.\nSimplicity: The new design eliminates the need for a Quarto extension to render the survey. This allows us to ship all of the core functionality of surveydown as a single R package, which is installed globally on your system.\n\nThe updated documentation of the Survey Components page reflects this new design."
  },
  {
    "objectID": "blog/2024-09-18-new-app-design/index.html#new-page-architecture",
    "href": "blog/2024-09-18-new-app-design/index.html#new-page-architecture",
    "title": "New architecture in v0.3.0 (and loads of breaking changes)!",
    "section": "New page architecture",
    "text": "New page architecture\nThe motivation to secure the page content led to a totally new approach to designing the survey pages. Our new approach actually renders the survey.qmd into a static html page and then parses it into a list of page objects. Each page object is itself a list of elements, including the page ID, question IDs, etc., as well as the rendered html content for that page.\nThe sd_server() function then uses this list of page objects to display one page at a time via a shiny::renderUI() function into a single “main” output. This approach allowed us to control what content is being served, eliminating the ability of survey respondents to see anything other than the content on the current page.\nThis approach also gave us the opportunity to overhaul how pagination works in general. Previously, users had to add a sd_next(next_page = \"page_id\") button at the end of each page, making sure to specify the next page to go to. This was a bit annoying as most of the time you just want to go to the next page, so specifying it felt redundant. Now users can simply add sd_next() at the bottom of each page and the server will go to the next page by default. If you want to direct the respondent to a different page, then you specify the target page using sd_next(next_page = \"page_id\")."
  },
  {
    "objectID": "blog/2024-09-18-new-app-design/index.html#improved-conditional-show-and-skip-logic",
    "href": "blog/2024-09-18-new-app-design/index.html#improved-conditional-show-and-skip-logic",
    "title": "New architecture in v0.3.0 (and loads of breaking changes)!",
    "section": "Improved conditional show and skip logic",
    "text": "Improved conditional show and skip logic\nConditionally displaying questions or skipping to pages is a core logic that many surveys need. Our original approach was relatively clunky, so since we were already introducing many breaking designs, we figured we should overhaul the logic for conditional skipping and displaying.\nThe new approach uses just two functions: sd_skip_if() and sd_show_if(). These functions can be provided in the main server() function in the app.R file to define the conditions and targets for either conditional displaying a question or conditionally skipping to a page. The structure for each condition in these new functions is always as follows:\n\n&lt;condition&gt; ~ \"target_question_id\"\n\nAs an example, let’s say we want to show a question called \"penguins_other\" if the respondent chose the \"other\" option in a question called \"penguins\". We could do this with the following code in the app.R file:\n\nserver &lt;- function(input, output, session) {\n\n  sd_show_if(\n    input$penguins == \"other\" ~ \"penguins_other\"\n  )\n\n  sd_server(db = db)\n\n}\n\nYou can provide multiple conditions to the sd_show_if() function, each separated by a comma. The sd_skip_if() function works the same way, but it will skip to a target page instead of showing a target question. See the revised Configuration Options page for more details on the new changes."
  },
  {
    "objectID": "blog/2024-09-18-new-app-design/index.html#no-more-sd_config-function",
    "href": "blog/2024-09-18-new-app-design/index.html#no-more-sd_config-function",
    "title": "New architecture in v0.3.0 (and loads of breaking changes)!",
    "section": "No more sd_config() function",
    "text": "No more sd_config() function\nOne more small change we made is that the sd_config() function is no longer needed. Since we moved the conditional skip and show logic into their own functions, we took the remaining arguments that used to be provided to sd_config() and added them to the sd_server() function as options. You can now simply pass these arguments to the sd_server() function in the app.R file."
  },
  {
    "objectID": "blog/2024-09-18-new-app-design/index.html#our-apologies",
    "href": "blog/2024-09-18-new-app-design/index.html#our-apologies",
    "title": "New architecture in v0.3.0 (and loads of breaking changes)!",
    "section": "Our apologies",
    "text": "Our apologies\nThat’s about it for the changes with v0.3.0. We want to send our deepest apologies for anyone who has already begun a study using the orginal design. The most recent version prior to v0.3.0 was v0.2.4, so this is the version you should install if you want to stick with the old design.\nThat said, all development will now continue on this new design, so we strongly recommend updating to the new version and converting any existing surveys to the new design. The biggest change you’ll need to make is to move your server logic out of the survey.qmd file and into the app.R file. We’ve also updated all our demos to the new design, so you can refer to these for examples on how to convert your existing surveys."
  },
  {
    "objectID": "server-options.html",
    "href": "server-options.html",
    "title": "Server Options",
    "section": "",
    "text": "All survey configuration settings are defined within the server function in the app.R file. The server() function is a standard Shiny server function that takes input, output, and session as arguments.\nIf you create a new survey using a template, the server() function looks like this:\nserver &lt;- function(input, output, session) {\n\n  # Define conditional skip logic (skip to page if a condition is true)\n  sd_skip_if()\n\n  # Define conditional display logic (show a question if a condition is true)\n  sd_show_if()\n\n  # Main server to control the app\n  sd_server(db = db)\n\n}\nThe sd_skip_if() and sd_show_if() functions are used to define conditional skip and show logic for the survey (see the Conditional Control page for more details).\nThe sd_server() function is used to run the survey. It handles the main logic, such as page navigation and managing the survey data. The db = db argument is required if you are using a database connection, which should be defined using the sd_database() function (see the Store Data page for more details).\nThe sd_server() function also has many other optional arguments that can be used to customize the survey behavior. This page details these options.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Server Options"
    ]
  },
  {
    "objectID": "server-options.html#required-questions",
    "href": "server-options.html#required-questions",
    "title": "Server Options",
    "section": "Required questions",
    "text": "Required questions\nBy default, no questions are required. However, you can make questions required by providing a vector containing the id of the questions to be required to the required_questions argument in sd_server(), like\n\nsd_server(\n1  required_questions = c(\"vehicle_ownership\", \"penguins_other\")\n)\n\n\n1\n\nThe required_questions argument takes a vector of question ids that you want to make required.\n\n\n\n\nThis will make the respondent unable to proceed until they have answered the required questions. It will also place a red asterisk (*) next to the question label to indicate that the question is required.\nYou can also make all questions required by setting all_questions_required = TRUE like this:\n\nsd_server(\n  all_questions_required = TRUE\n)",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Server Options"
    ]
  },
  {
    "objectID": "server-options.html#starting-page",
    "href": "server-options.html#starting-page",
    "title": "Server Options",
    "section": "Starting page",
    "text": "Starting page\nWhen editing your survey, it can be helpful to start the survey at a specific page. You can define the starting page with the start_page argument in the sd_server() function, like this:\n\nsd_server(\n  start_page = \"page_id\"\n)",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Server Options"
    ]
  },
  {
    "objectID": "server-options.html#auto-scroll",
    "href": "server-options.html#auto-scroll",
    "title": "Server Options",
    "section": "Auto scroll",
    "text": "Auto scroll\nThe auto scroll feature allows the page to automatically scroll according to the user’s working progress and is enabled by default.\n\nsd_server(\n  auto_scroll = TRUE # Change to FALSE to switch it off.\n)",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Server Options"
    ]
  },
  {
    "objectID": "server-options.html#admin-page",
    "href": "server-options.html#admin-page",
    "title": "Server Options",
    "section": "Admin page",
    "text": "Admin page\n\n\n\n\n\n\nImportant\n\n\n\nThe admin page is currently under development and has limited functionality.\n\n\nBy default, the admin page is not created. But if you want one, set admin_page to TRUE inside the sd_server() function, like this:\n\nsd_server(\n  admin_page = TRUE\n)\n\nWhen the admin page is enabled, you will be able to access the page by adding ?admin to the end of the survey URL, e.g. https://myname.shinyapps.io/?admin. This will display a login page with a single “Password” parameter, which is the password set using sd_set_password(). See the Password page for details.\nThe admin page has the following features:\n\nPause Survey: Once clicked, the Shiny app pauses all instances replacing questions with a placeholder page.\nPause DB: Once clicked, the all database uploads will be paused. You can still take the survey, but the data will not be updated in the database.\nDownload Data: Download the most recent table instance from the database as a .csv file.\nAdmin Logout and Return to Survey: Once clicked, the admin page will be logged out and the survey will be returned to the start page.\nSurvey Data Preview: View the latest instance of the database table.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Server Options"
    ]
  },
  {
    "objectID": "server-options.html#rating-question",
    "href": "server-options.html#rating-question",
    "title": "Server Options",
    "section": "Rating question",
    "text": "Rating question\nYou may want to add a rating question by the end of the survey to collect user reflections. Simply set rate_survey to TRUE (Default to FALSE):\n\nsd_server(\n  rate_survey = TRUE\n)\n\nSurvey rating is triggered by the “Exit Survey” button by the end of the survey. If you want to implement the survey rating, make sure you define the Exit Button by the end of the survey using the sd_close() function, and then define rate_survey = TRUE in sd_server().\nBelow are the TRUE and FALSE cases for rate_survey:\n\nTRUEFALSE\n\n\nIf rate_survey is TRUE, a survey rating question will pop up:\n\n\n\n\n\nIf rate_survey is FALSE, a confirm exit dialog box will pop up:",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Server Options"
    ]
  },
  {
    "objectID": "getting-started.html",
    "href": "getting-started.html",
    "title": "Getting Started",
    "section": "",
    "text": "Every surveydown survey is composed of a survey and an app, defined in two separate files:\n\nsurvey.qmd: A Quarto document that contains the survey content (pages, questions, etc), which renders to an HTML file.\napp.R: An R script defining a Shiny app that contains the global settings (libraries, database configuration, etc.) and server configuration options (e.g., conditional skipping / display, etc.).\n\nThese files must be named survey.qmd and app.R.\nThe {surveydown} R package provides a set of functions for defining the survey content and configuration options. Each function starts with sd_ to make them easy to identify.\nThe platform is based on some basic principles:\n\nAdd content to your survey.qmd file using markdown text (or in RStudio use the visual editor).\nDefine survey questions in R code chunks with the sd_question() function.\nDefine pages using fences (:::), with navigation buttons handled using the sd_next() function.\nAdd rich functionality to your survey using a variety of server options and conditional control logic in the server() function in the app.R file.\nStore your respondent data in a database (see Store Data).\n\nThis approach ensures a flexible survey platform that is fully reproducible and easy to customize.\nThe remaining steps on this page will guide you through the process of creating a surveydown survey.",
    "crumbs": [
      "Documentation",
      "Getting Started"
    ]
  },
  {
    "objectID": "getting-started.html#overview",
    "href": "getting-started.html#overview",
    "title": "Getting Started",
    "section": "",
    "text": "Every surveydown survey is composed of a survey and an app, defined in two separate files:\n\nsurvey.qmd: A Quarto document that contains the survey content (pages, questions, etc), which renders to an HTML file.\napp.R: An R script defining a Shiny app that contains the global settings (libraries, database configuration, etc.) and server configuration options (e.g., conditional skipping / display, etc.).\n\nThese files must be named survey.qmd and app.R.\nThe {surveydown} R package provides a set of functions for defining the survey content and configuration options. Each function starts with sd_ to make them easy to identify.\nThe platform is based on some basic principles:\n\nAdd content to your survey.qmd file using markdown text (or in RStudio use the visual editor).\nDefine survey questions in R code chunks with the sd_question() function.\nDefine pages using fences (:::), with navigation buttons handled using the sd_next() function.\nAdd rich functionality to your survey using a variety of server options and conditional control logic in the server() function in the app.R file.\nStore your respondent data in a database (see Store Data).\n\nThis approach ensures a flexible survey platform that is fully reproducible and easy to customize.\nThe remaining steps on this page will guide you through the process of creating a surveydown survey.",
    "crumbs": [
      "Documentation",
      "Getting Started"
    ]
  },
  {
    "objectID": "getting-started.html#install",
    "href": "getting-started.html#install",
    "title": "Getting Started",
    "section": "1. Install",
    "text": "1. Install\nSee the Installation page.",
    "crumbs": [
      "Documentation",
      "Getting Started"
    ]
  },
  {
    "objectID": "getting-started.html#start-with-a-template",
    "href": "getting-started.html#start-with-a-template",
    "title": "Getting Started",
    "section": "2. Start with a template",
    "text": "2. Start with a template\nSee the Template page.",
    "crumbs": [
      "Documentation",
      "Getting Started"
    ]
  },
  {
    "objectID": "getting-started.html#add-survey-content-in-your-survey.qmd-file",
    "href": "getting-started.html#add-survey-content-in-your-survey.qmd-file",
    "title": "Getting Started",
    "section": "3. Add survey content in your survey.qmd file",
    "text": "3. Add survey content in your survey.qmd file\nSee the Survey Components page for details on the main components in a surveydown survey. For a quick overview, here’s how you add pages and questions:\n\nAdd pages with fences, like this:\n\n\n::: {#page1 .sd-page}\n\nPage 1 content here\n\n:::\n\n\nAdd questions with the sd_question() function in code chunks (see the Question Types page for more on the types of questions supported). For example, here’s a multiple choice question:\n\n\nCode chunkOutput\n\n\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'penguins',\n  label = \"Which is your favorite type of penguin?\",\n  option = c(\n    'Adélie'    = 'adelie',\n    'Chinstrap' = 'chinstrap',\n    'Gentoo'    = 'gentoo'\n  )\n)\n```\n\n\n\n\n\n\n\nWhich is your favorite type of penguin?\n\n\n\n\n\nAdélie\n\n\n\n\n\nChinstrap\n\n\n\n\n\nGentoo\n\n\n\n\n*",
    "crumbs": [
      "Documentation",
      "Getting Started"
    ]
  },
  {
    "objectID": "getting-started.html#add-control-options",
    "href": "getting-started.html#add-control-options",
    "title": "Getting Started",
    "section": "4. Add control options",
    "text": "4. Add control options\nIn the server() function in the app.R file, add rich functionality to your survey using a variety of server options and conditional control logic.",
    "crumbs": [
      "Documentation",
      "Getting Started"
    ]
  },
  {
    "objectID": "getting-started.html#setup-your-database",
    "href": "getting-started.html#setup-your-database",
    "title": "Getting Started",
    "section": "5. Setup your database",
    "text": "5. Setup your database\nIn the global settings at the top of the app.R file, setup your database with the sd_database() function. You can also leave it blank to preview / edit your survey without database connected, or set ignore = TRUE to run the survey without storing data. See the Store Data page for more details.",
    "crumbs": [
      "Documentation",
      "Getting Started"
    ]
  },
  {
    "objectID": "getting-started.html#locally-preview",
    "href": "getting-started.html#locally-preview",
    "title": "Getting Started",
    "section": "6. Locally preview",
    "text": "6. Locally preview\nPreview your survey by clicking the “Run App” button in RStudio or in your R console running the runApp() command.",
    "crumbs": [
      "Documentation",
      "Getting Started"
    ]
  },
  {
    "objectID": "getting-started.html#deploy",
    "href": "getting-started.html#deploy",
    "title": "Getting Started",
    "section": "7. Deploy",
    "text": "7. Deploy\nDeploy your survey by hosting it on your favorite server, like shinyapps.io, HuggingFace, Posit Connect Cloud, Heroku, etc. See the Deployment page for more details.",
    "crumbs": [
      "Documentation",
      "Getting Started"
    ]
  },
  {
    "objectID": "redirect.html",
    "href": "redirect.html",
    "title": "External Redirect",
    "section": "",
    "text": "Like other operations, there are also two types of redirection: static and reactive. A static redirect provides a hard-coded URL, like google.com, apple.com, etc. A reactive redirect grabs parameters from your survey URL and allows you to use them to construct a new redirect URL.\nWe highly recommend you to watch the video showcase and play with our demo survey, so that you can have a full understanding of how this works:",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Redirect"
    ]
  },
  {
    "objectID": "redirect.html#static-redirect",
    "href": "redirect.html#static-redirect",
    "title": "External Redirect",
    "section": "Static Redirect",
    "text": "Static Redirect\nIn your survey body, use the sd_redirect() function and define your parameters. Below is an example of a redirect button that goes to google.com.\n\nCode chunkOutput\n\n\n\n# Static redirect\nsd_redirect(\n  id     = \"redirect\",\n  url    = \"https://www.google.com\",\n  label  = \"Redirect to Google\",\n  button = TRUE,\n  newtab = TRUE\n)\n\n\n\n\n\n\n\nRedirect to Google",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Redirect"
    ]
  },
  {
    "objectID": "redirect.html#reactive-redirect",
    "href": "redirect.html#reactive-redirect",
    "title": "External Redirect",
    "section": "Reactive Redirect",
    "text": "Reactive Redirect\nReactive redirect is essentially useful if you deploy your survey on survey panels like Prolific or Dynata. These survey panels usually use different IDs to identify survey respondents.\nTo make reactive redirect work, you need to edit both in your server chunk, and your survey body. We’ll use an example to explain the process. This is the same example in our demo survey.\nFirstly, in your server chunk, define url_normal. It is an reactive expression in Shiny apps. You’ll use the sd_get_url_pars() function to retrieve all the parameters in your survey URL, and concatenate with customized texts including id names, status values, etc. In this example, we defined 3 IDs: id_a, id_b, and id_c, which should be grabbed from your survey link.\n\n# Reactive expression that generates a url for a normal ending\nurl_normal &lt;- reactive({\n  params &lt;- sd_get_url_pars()\n  id_a &lt;- params[\"id_a\"]\n  id_b &lt;- params[\"id_b\"]\n  id_c &lt;- params[\"id_c\"]\n  return(paste0(\"https://www.google.com?id_a=\", id_a,\n                \"id_b=\", id_b,\n                \"id_c=\", id_c,\n                \"&status=0\")) # status of 0 indicates normal ending\n})\n\nSecondly, also in your server chunk, create the redirect button using sd_redirect(). Note that we passed url_normal() value, with a pair of parentheses, to the url parameter.\n\n# Create the redirect button for normal ending\nsd_redirect(\n  id = \"redirect_normal\",\n  url = url_normal(),\n  button = TRUE,\n  label = \"Redirect with Normal Status\"\n)\n\n\n\n\n\n\n\nTip\n\n\n\nYou may have noticed that we created url_normal, and then passed url_normal() to sd_redirect(). This is how Shiny app deals with reactivity. Here url_normal is created by reactive() and is called “reactive expression”. url_normal() is a string value containing the concatenated URL. In other words, the url_normal() value is the result of the url_normal expression.\n\n\nFinally, in your survey body, output this redirect_normal URL using the sd_output() function:\n\n# Put this in the desired place of your survey body\nsd_output(\"redirect_normal\")\n\nAfter all these are done, your sd_output() function will generate a button that redirects you to this link:\n\nhttps://www.google.com/?id_a=a123id_b=b234id_c=c345&status=0\n\n\n\n\n\n\n\nTip\n\n\n\nCount-down delay (only applies for static redirect):\n\n# count-down of 10 seconds\nsd_redirect(\n  # previous parameters...\n  delay  = 10\n)\n\nOpen at a new tab (applies for both static and reactive):\n\nsd_redirect(\n  # previous parameters...\n  newtab  = TRUE\n)\n\nIf newtab is used together with delay, the new tab opened after count-down might be blocked by the browser. We’ve tested it with Safari and Edge. It worked fine on Safari, but Edge blocks it with a pop-up notice.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Redirect"
    ]
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "",
    "text": "Important\n\n\n\nThis post was updated on 2024-09-23 to match the new architecture introduced in v0.3.0. See the blog post on the v0.3.0 release for more details.\nBecause surveydown surveys run as a shiny app, you can include custom logic in the background by writing some  code in your server. In this post, I’m going to show you one approach for using surveydown to create a particular type of complex survey: a choice-based conjoint survey.\nThe key component of a choice-based conjoint survey is asking repsondents to make choices from randomized sets of choice questions. So the hard part is figuring out a way to show each respondent a different set of randomized questions. This post shows how you can achieve this in surveydown.\nThroughout this post, I will use a demo survey about people’s preferences for apples with three attributes: type, price, and freshness.1\nYou can view the live demo survey here, and all files used to create the survey are on this GitHub repo."
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#introduction",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#introduction",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Introduction",
    "text": "Introduction\nIf you’ve never used surveydown before, take a look at the Getting Started page to get a quick introduction to the package and how to use it to make a survey.\nThe basic concept is this:\n\nDesign your survey as a Quarto document using markdown and R code.\nConvert your survey into a Shiny app that can be hosted online and sent to respondents.\nStore your survey responses in a Supabase database."
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#getting-started",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#getting-started",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Getting started",
    "text": "Getting started\nIf you want to start from a blank slate, take a look at the Getting Started documentation page.\nFor this post, we recommend starting from the demo survey available at this GitHub repo. It provides an already working survey that you can modify to the needs of your conjoint survey.\nThe demo repo has a lot of files in it, but the main files defining the survey itself are:\n\nsurvey.qmd: The main body of the survey.\napp.R: The app file containing the server logic implemented in the survey, including randomizing questions, connecting to a database, etc.\n\n\n\n\n\n\n\nNote\n\n\n\nWe recommend opening the survey.Rproj if you’re working in RStudio to make sure RStudio opens to the correct project folder."
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#content-in-the-survey-body",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#content-in-the-survey-body",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Content in the survey body",
    "text": "Content in the survey body\nAfter the setup code chunk where we load the surveydown package, we have a series of pages (defined with ::: fences) that include markdown-formatted text and survey questions (defined with sd_question()). You can modify any of this content as you wish to suit the needs of your survey.\nIn this demo, we have a few other examples included, like a conditionally displayed question (the fav_fruit question will not display if you choose “No” on the first question about liking fruit) as well as a question that skips people to the end (if you choose “blue” and not “red” on the screening page). The logic controlling the conditional display and skipping is defined with the sd_skip_if() function in the app.R file.\nNone of this is necessary for a conjoint survey, but often times these are features that you may want to include, such as screening people out of the survey if they don’t qualify to take it, so we include it for demonstration purposes."
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#defining-the-choice-questions",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#defining-the-choice-questions",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Defining the choice questions",
    "text": "Defining the choice questions\nThe central component of every conjoint survey is the set of randomized choice questions. To implement these in surveydown, we pre-define our choice questions in a design file that we later use in the survey to select randomized sets of choice questions to display each respondent.\nWe use the cbcTools package to create the pre-defined design file. The code to create the choice questions for this demo survey is in the make_choice_questions.R file in the demo repo. This code generates a data frame of randomized choice questions that we then save in the project directory as choice_questions.csv."
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#implementing-the-choice-questions",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#implementing-the-choice-questions",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Implementing the choice questions",
    "text": "Implementing the choice questions\nThe choice questions are implemented at the top of the server() function in the app.R file in the demo repo. This code does the following steps:\n\n1. Read in the design file\nPretty straightforward - this is one line to read in the choice_questions.csv design file that we saved in the project folder.\n\ndesign &lt;- readr::read_csv(\"choice_questions.csv\")\n\n\n\n2. Sample and store a random respondent ID\nSince we want each respondent to see a different set of choice questions, we randomly sample a respondent ID from the set of all respondent IDs in the design file. We also need to keep track of this and store it in our response data so that later we can know what each respondent was actually shown.\nSince this is a value that we generated in the server (and not a value from a survey question to a respondent), we have to manually add it to the survey response data using sd_store_value(). Here we modified the name so that in the resulting survey data the column name will be \"respID\".\n\n# Sample a random respondentID\nrespondentID &lt;- sample(design$respID, 1)\n\n# Store the respondentID\nsd_store_value(respondentID, \"respID\")\n\n\n\n3. Filter the design for the respondentID\nWe create a subset dataframe called df that stores only the rows for the randomly chosen respondent ID. We also append the \"images/\" string onto the values in the image column as this will create the relative path to the images in our survey, e.g. \"images/fuji.jpg\" (all the images we show are in the \"images\" folder in the repo).\n\n# Filter for the rows for the chosen respondentID\ndf &lt;- design %&gt;%\n  filter(respID == respondentID) %&gt;%\n  mutate(image = paste0(\"images/\", image))\n\n\n\n4. Define a function to create question options\nThis is the most complex component in the server logic. Here we created a function that takes a dataframe and returns a named vector defining the options to show in each choice question. In this case, we only have 3 options per choice question, so each time we call this function we will use a small dataframe that has just 3 rows defining the 3 choice alternatives in a single choice question.\nThe function does several things. First, it extracts three single-row data frames that store the values of each of the 3 alternatives (alt1, alt2, and alt3). It then creates an options vector that has just 3 values: \"option_1\", \"option_2\", and \"option_3\". Then we have to define the names of each of those options. Remember that the values in the options vector are what gets stored in our resulting survey data based on what the respondent chooses, but the names are what respondents see. So in the context of a choice survey like this, we need to embed all of the attributes and their levels in the names of the options vector.\nWe use the glue() function to easily inject the values stored in alt1, alt2, and alt3 into our labels. The glue() function is similar to paste() in that is just concatenates object values into a string, but it has an easier syntax to work with. Anything inside {} brackets is evaluated, and the resulting value is inserted into the string. So for example, the line glue(\"1 plus 1 equals {1+1}\") would produce the string \"1 plus 1 equals 2\".\nIn our case, we’re including some html code to insert an image of the apple type (&lt;img src='{alt1$image}' width=100&gt;), the apply type itself (**Type**: {alt1$type}), and the apple price (**Price**: $ {alt1$price} / lb).\nNotice also that we’re mixing markdown (e.g. **Option 1**) and html (e.g. &lt;br&gt;), which will all get rendered into proper html in the resulting shiny app. The full function looks like this:\n\n# Function to create the labels for a choice question\n# based on the values in df\n\nmake_cbc_options &lt;- function(df) {\n  alt1 &lt;- df |&gt; filter(altID == 1)\n  alt2 &lt;- df |&gt; filter(altID == 2)\n  alt3 &lt;- df |&gt; filter(altID == 3)\n\n  options &lt;- c(\"option_1\", \"option_2\", \"option_3\")\n\n  names(options) &lt;- c(\n    glue(\"\n      **Option 1**&lt;br&gt;\n      &lt;img src='{alt1$image}' width=100&gt;&lt;br&gt;\n      **Type**: {alt1$type}&lt;br&gt;\n      **Price**: $ {alt1$price} / lb\n    \"),\n    glue(\"\n      **Option 2**&lt;br&gt;\n      &lt;img src='{alt2$image}' width=100&gt;&lt;br&gt;\n      **Type**: {alt2$type}&lt;br&gt;\n      **Price**: $ {alt2$price} / lb\n    \"),\n    glue(\"\n      **Option 3**&lt;br&gt;\n      &lt;img src='{alt3$image}' width=100&gt;&lt;br&gt;\n      **Type**: {alt3$type}&lt;br&gt;\n      **Price**: $ {alt3$price} / lb\n    \")\n  )\n  return(options)\n}\n\n\n\n5. Create the options for each choice question\nOne of the benefits of making the function the way we did in the previous step is that we can now easily call it to generate the option vector for each of the 6 choice questions in df:\n\n# Create the options for each choice question\n\ncbc1_options &lt;- make_cbc_options(df |&gt; filter(qID == 1))\ncbc2_options &lt;- make_cbc_options(df |&gt; filter(qID == 2))\ncbc3_options &lt;- make_cbc_options(df |&gt; filter(qID == 3))\ncbc4_options &lt;- make_cbc_options(df |&gt; filter(qID == 4))\ncbc5_options &lt;- make_cbc_options(df |&gt; filter(qID == 5))\ncbc6_options &lt;- make_cbc_options(df |&gt; filter(qID == 6))\n\n\n\n6. Create each choice question (6 in total)\nFinally, we now have everything we need to generate each choice question. Here we’re using the mc_buttons question type so that the labels we generated will be displayed on a large button, which looks good both on a computer and phone. We give the question a unique id (e.g. cbc_q1), and a label, and then set the option to the corresponding option vector we defined above.\n\nsd_question(\n  type   = 'mc_buttons',\n  id     = 'cbc_q1',\n  label  = \"(1 of 6) If these were your only options, which would you choose?\",\n  option = cbc1_options\n)\n\n# ...and 5 more questions like this\n\nRemember that since the labels in the options are being dynamically generated on each new session (each respondent), they have to be created in the server, not in the main survey body. As a result, the sd_question() function must also be created in the server code (if you put this code in the main body, only one random set of choice options will be generated, and they’ll be the same for everyone).\nTo display each question in the survey body, we use sd_output(\"id\", type = \"question\"), changing id to each corresponding choice question we created. In the demo survey.qmd file, you’ll see that there are 6 choice questions displayed in the main survey body (each on their own page), and each of those 6 questions are defined in the server() function in the app.R file.\nWhen rendered, a choice question will look like this, with the values matching whatever alternative was chosen in the design file:\n\n\n\n\n(1 of 6) If these were your only options, which would you choose? *\n\n\n\n\n\n\n\nOption 1Type: HoneycrispPrice: $ 1 / lb\n\n\n\n\n\nOption 2Type: FujiPrice: $ 3 / lb\n\n\n\n\n\nOption 3Type: Red DeliciousPrice: $ 2.5 / lb\n\n\n\n\n\n\n\n\n\n\nAnd that’s it! You now have 6 randomized choice questions!"
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#preview-and-check",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#preview-and-check",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Preview and check",
    "text": "Preview and check\nThe rest of the server() function in the app.R file has the remaining components we need, like any conditional display or skip logic. This is all standard features of any surveydown survey, so we won’t cover them in detail here and instead direct you to the documentation for details.\nBut before you go live, it’s a good idea to do some quick testing. You can test your survey even without having it connected to a database by setting ignore = TRUE in the sd_database() function. Of course, you probably should also test it after connecting it to a database to ensure that responses are being properly stored.\nWhen testing, you might get an error - don’t panic! Read the terminal output carefully and debug. There’s a good chance you may have missed a bug somewhere in your server code. Look in your app.R file to see if you can spot the error."
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#getting-the-data",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#getting-the-data",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Getting the data",
    "text": "Getting the data\nOnce your survey is live and you start collecting responses, you can easily access your data with the sd_get_data() function. This is typically done in a separate R file, which might look something like this:\n\nlibrary(surveydown)\n\ndb &lt;- sd_database(\n  user   = 'postgres.axzkymswaxcasjdflkurrj',\n  host   = 'aws-0-us-east-1.pooler.supabase.com',\n  port   = 5678,\n  db_name = 'postgres',\n  table_name = 'my_table'\n)\n\ndata &lt;- sd_get_data(db)\n\nObviously your settings in sd_database() would need to match those of your Supabase database that you created for your survey.\nAnd that’s it! We hope this post was helpful, and do go check out the this GitHub repo to try out the demo yourself."
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#footnotes",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#footnotes",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nYes, people have actually done conjoint surveys on fruit before.↩︎"
  },
  {
    "objectID": "reactivity.html",
    "href": "reactivity.html",
    "title": "Reactivity",
    "section": "",
    "text": "Because surveydown renders to a Shiny app, it can take advantage of Shiny’s reactivity features. This means you can create reactive expressions and reactive values that update the survey in response to user input or other events.\nThis page demonstrates some common use cases for reactive programming in surveydown.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Reactivity"
    ]
  },
  {
    "objectID": "reactivity.html#displaying-question-values-in-the-survey",
    "href": "reactivity.html#displaying-question-values-in-the-survey",
    "title": "Reactivity",
    "section": "Displaying question values in the survey",
    "text": "Displaying question values in the survey\nA simple example of using a reactive value is displaying a question value somewhere else in the survey.\nFor example, you might ask the respondent’s name in a question and then display their name somewhere else in the survey, like in a greeting message. First, you would ask the respondent’s name in a question in your survey.qmd file:\n\nsd_question(\n  type  = \"text\",\n  id    = \"name\",\n  label = \"What is your name?\"\n)\n\nThen you can use the sd_output() function to display the value of the \"name\" question elsewhere in the survey. For example, you could display the name in a greeting message:\n\nWelcome, `r sd_output(\"name\", type = \"value\")`!\n\nIf the respondent entered “Dave” in the name question, this would render as:\n\nWelcome, Dave!\n\nThe type = \"value\" argument tells sd_output() to display the value of the question rather than the question itself.\n\n\n\n\n\n\nHow this works under the hood\n\n\n\nEvery question has it’s own id. To access the value that a respondent chose, we can’t use the same id. To address this, whenever you create a question we automatically create an object stored as id_value to store the value chosen by the respondent.\nFor example, if the question id was \"name\", then the value would be stored as \"name_value\". In the sd_output() function, when you use type = \"value\", the function automatically appends this _value to the id to get the question value we want to display, then uses an appropriate shiny output function to display it, e.g. shiny::textOutput().\nYou can also use type = \"question\" to display questions that are defined in the server() function in your app.R file (for example, see the randomizing question labels section below).",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Reactivity"
    ]
  },
  {
    "objectID": "reactivity.html#displaying-stored-values-e.g.-a-completion-code",
    "href": "reactivity.html#displaying-stored-values-e.g.-a-completion-code",
    "title": "Reactivity",
    "section": "Displaying stored values (e.g. a completion code)",
    "text": "Displaying stored values (e.g. a completion code)\nYou can use sd_output() with type = \"value\" to display values that you stored in the server() function.\nFor example, you might want to display a completion code at the end of the survey. You can do this by defining a completion code in the server() function and then storing it in the survey data using the sd_store_value() function.\nSince completion codes are often needed, we made a simple sd_completion_code() function that returns a random numeric completion code as a string. Here’s an example of how to use it:\n\n# Make a 10-digit random number completion code\ncompletion_code &lt;- sd_completion_code(10)\n\n# Store the completion code in the survey data\nsd_store_value(completion_code)\n\nThis will store the completion code in the survey data under the completion_code column.\nYou can then display the completion code at the end of the survey using the sd_output() function in your survey.qmd file, like this:\n\n```{r}\nYour code is: `r sd_output(\"completion_code\", type = 'value')`\n```\n\nThis should render as something like this:\n\nYour code is: 7408931907",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Reactivity"
    ]
  },
  {
    "objectID": "reactivity.html#displaying-the-same-value-in-multiple-places",
    "href": "reactivity.html#displaying-the-same-value-in-multiple-places",
    "title": "Reactivity",
    "section": "Displaying the same value in multiple places",
    "text": "Displaying the same value in multiple places\nThe sd_output() function can only be used once per each unique question id because the id gets used in the rendered HTML divs, and HTML with more than one element with the same id is invalid HTML. This is a general issue for Shiny - outputs can only be used once per each unique id (see this GitHub issue on the topic).\nThe solution that we use is to simply make a copy of the value and then display the copy (this is also the solution on the GitHub issue linked above).\nTo do so, in the server function in the app.R file use the sd_copy_value() function to create a copy of the value, like this:\n\nsd_copy_value(id = \"name\", id_copy = \"name_copy\")\n\nYou can then use the sd_output() function in your survey.qmd file to display both the original and copied values. For example:\n\nWelcome, `r sd_output(\"name\", type = \"value\")`!\n\nIs it alright if we call you `r sd_output(\"name_copy\", type = \"value\")`?\n\nIf the respondent entered “Dave” in the name question, this would render as:\n\nWelcome, Dave!\nIs it alright if we call you Dave?\n\n\n\n\n\n\n\nNote\n\n\n\nIf you find this annoying, we agree! This is a bit of a hack and we are working on a better solution, but it is a limitation of Shiny that we have to live with, at least for now.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Reactivity"
    ]
  },
  {
    "objectID": "reactivity.html#defining-questions-in-the-server-function",
    "href": "reactivity.html#defining-questions-in-the-server-function",
    "title": "Reactivity",
    "section": "Defining questions in the server function",
    "text": "Defining questions in the server function\nOften you will want to define questions where the label or options change based on the respondent’s answers to other questions. You can do this by defining the question in the server function and then displaying it in the survey.qmd file using the sd_output() function.\nFor example, let’s say you want to ask a follow-up question based on the respondent’s answer to a previous question. To do this, you would define the first question in the survey.qmd file as usual, e.g.:\n\nsd_question(\n  id     = \"pet_type\",\n  type   = \"mc\",\n  label  = \"Which do you like more, dogs or cats?\",\n  option = c(\"Dogs\" = \"dog\", \"Cats\" = \"cat\")\n)\n\nMy follow-up question is whether or not the respondent has a pet of the type they chose above. To do this, you would define the follow-up question in the app.R file’s server() function like this:\n\nserver &lt;- function(input, output, session) {\n\n  observe({\n    pet_type &lt;- input$pet_type\n\n    # Make the question label and options\n    label &lt;-glue::glue(\"Are you a {pet_type} owner?\")\n    options &lt;- c('yes', 'no')\n    names(options)[1] &lt;- glue::glue(\"Yes, am a {pet_type} owner\")\n    names(options)[2] &lt;- glue::glue(\"No, I am not a {pet_type} owner\")\n\n    # Make the question\n    sd_question(\n      type   = \"mc\",\n      id     = \"pet_owner\",\n      label  = label,\n      option = options\n    )\n  })\n\n  sd_server()\n}\n\nThe pet_owner question is a reactive question where the label and options will change based on the respondent’s answer to the pet_type question.\n\n\n\n\n\n\nNote\n\n\n\nThe observe() function is used to create the reactive question. This is a core concept in Shiny reactivity that allows you to create reactive expressions that can change based on the values of other reactive expressions.\nAlso, in this example we use the glue package to create the question label and options. This is a powerful package for creating strings that contain variable values.\n\n\nFinally, you can display the pet_owner question in the survey.qmd file using the sd_output() function, like this:\n\n```{r}\nsd_output(id = \"pet_owner\", type = \"question\")\n```",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Reactivity"
    ]
  },
  {
    "objectID": "reactivity.html#randomizing-question-labels",
    "href": "reactivity.html#randomizing-question-labels",
    "title": "Reactivity",
    "section": "Randomizing question labels",
    "text": "Randomizing question labels\nShowing a question with randomized labels is a common use case for reactive programming. There are at least two ways to achieve this.\n\nLive randomization\nOne approach is to generate the random labels in the server function “live”, meaning that the labels will be generated when the survey is first loaded. For example, let’s say in my server function I generate three random numbers between 1 and 100 and use them to create the option labels for a multiple choice question:\n\n# Create a vector of options\nq1_options &lt;- c('option 1', 'option 2', 'option 3')\n\n# Randomly sample 3 labels from 1 to 100\nq1_labels &lt;- sample(seq(100), 3) \n\n# Assign the labels to the options\nnames(q1_options) &lt;- q1_labels \n\nq1_options\n\n#&gt;        100         89         37 \n#&gt; \"option 1\" \"option 2\" \"option 3\"\n\n\nRemember that the names of the vector are the labels, so the respondents will see the numbers in the names of the above vector, and the values ('option1', etc.) will be stored in the resulting survey data.\nTo then use these options in a multiple choice question, you would use the sd_question() function also in the server function (not in the survey.qmd file) like this:\n\nsd_question(\n  id = \"q1\",\n  type = \"mc\",  \n  label = \"Which of these numbers is the largest?\",\n  option = q1_options\n)\n\nBy defining this question inside the server function, the question will be created as a reactive question that can then be displayed in the survey.qmd file using the sd_output() function, like this:\n\n```{r}\nsd_output(id = \"q1\", type = \"question\")\n```\n\nOne important caveat to this approach is that the random numbers that are generated are not automatically stored in the survey data (because they are generated live). If you needed to store the random numbers, you can use the sd_store_value() function, like this:\n\nsd_store_value(q1_labels, id = \"q1_labels\")\n\nThis would store the numbers in the q1_labels column of the survey data, which would be concatenated into the single string: 100, 89, 37.\nYou could alternatively use the sd_store_value() function to store each of the random numbers in separate columns, like this:\n\nsd_store_value(q1_labels[1], id = \"q1_label_1\")\nsd_store_value(q1_labels[2], id = \"q1_label_2\")\nsd_store_value(q1_labels[3], id = \"q1_label_3\")\n\n\n\nPre-defined randomization\nAn alternative approach is to pre-define the randomized labels and store them in a separate design file, and then randomly select a set of labels for each respondent from the design file.\nFor example, let’s generate 10 sets of 3 random numbers between 1 and 100 and store them in a data frame:\n\ndesign &lt;- data.frame(\n  id = rep(1:10, each = 3),\n  numbers = unlist(lapply(1:10, function(x) sample(seq(100), 3)))\n)\n\nhead(design)\n\n#&gt;   id numbers\n#&gt; 1  1      20\n#&gt; 2  1      26\n#&gt; 3  1       3\n#&gt; 4  2      41\n#&gt; 5  2      89\n#&gt; 6  2      27\n\n\nNow we can write this design to a csv file:\n\nreadr::write_csv(design, \"design.csv\")\n\nThen in your server function in the app.R file, you could read in the design file and use it to randomize the labels for each question. Here the only thing you would need to keep track of the randomly chosen row id:\n\n# Read in the design file\ndesign &lt;- readr::read_csv(\"design.csv\")\n\n# Randomly choose a row id\nq1_id &lt;- sample(design$id, 1)\n\n# Store the chosen row id in the survey data (here q1_id will be the column name)\nsd_store_value(q1_id) \n\n# Filter the design to get the chosen row\nnumbers &lt;- design |&gt; \n  filter(id == q1_id) |&gt; \n  pull(numbers)\n\n# Create the options\nq1_options &lt;- c('option 1', 'option 2', 'option 3')\nnames(q1_options) &lt;- numbers\n\n# Create the reactive question\nsd_question(\n  id = \"q1\",\n  type = \"mc\",  \n  label = \"Which of these numbers is the largest?\",\n  option = q1_options\n)\n\nOnce again, you would be able to then display this question in the survey.qmd file using the sd_output() function:\n\n```{r}\nsd_output(id = \"q1\", type = \"question\")\n```",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Reactivity"
    ]
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html",
    "href": "blog/2024-08-21-introducing-surveydown/index.html",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "",
    "text": "This post introduces the {surveydown} R package, a new way to design surveys using markdown, R, Quarto, and shiny. The idea for this platform has been brewing for a while (see this blog post for more on the motivation for this project), but now the package is finally here!\nIn this post, I’m going to show you a quick overview of the {surveydown} R package for making markdown-based surveys as well as a little about why we built surveydown."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#open-source",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#open-source",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Open source",
    "text": "Open source\nsurveydown is built entirely with open-source technologies, making it transparent and customizable. Best of all, no expensive licenses! Just install and use it!"
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#own-your-data",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#own-your-data",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Own your data",
    "text": "Own your data\nWith surveydown, you retain full ownership and control of your survey data. The responses are stored in your own Supabase database, ensuring that you have complete access to the data. This is particularly important for researchers dealing with sensitive information or those who need to comply with specific data protection regulations. We’re still working on enabling you to use your own hosted database, which will provide even more flexibility."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#ease-of-editing",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#ease-of-editing",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Ease of editing",
    "text": "Ease of editing\nDesigning a survey in surveydown is a pretty straightforward process. The markdown-based approach allows for quick modifications and easy navigation through your survey. And since it’s built on Quarto, you can use all of the features of Quarto to make your survey look great, like changing the theme, adding custom CSS, etc. You can also easily preview your survey as you edit it, and even run your survey locally to test it out before you deploy it, either with a button click in RStudio or with a quarto serve command in the terminal."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#did-i-mention-you-can-run-r-code-in-your-survey",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#did-i-mention-you-can-run-r-code-in-your-survey",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Did I mention you can run R code in your survey?",
    "text": "Did I mention you can run R code in your survey?\nEvery surveydown survey uses R code chunks for questions. But you can also insert R code for all sorts of other things. For example, if you wanted to randomize the values shown in a question, you could write some R code for that. Want to insert a plot of something? Write a little ggplot code. You can also add interactive components to your surveys, such as showing a respondent how their responses compare to others in real time."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#easy-version-control-and-collaboration",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#easy-version-control-and-collaboration",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Easy version control and collaboration",
    "text": "Easy version control and collaboration\nBecause the entire survey is defined in a single plain text file, surveydown naturally integrates with version control systems like Git. This allows you to track changes over time, collaborate with team members, and maintain a clear history of your survey’s development."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#reproducible",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#reproducible",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Reproducible",
    "text": "Reproducible\nSurveydown promotes reproducible research by allowing you to define your entire survey in a single, self-contained plain text document. This has a ton of benefits:\n\nWant someone else to be able to reproduce your experiment? Just give them the .qmd file and any other files they need (e.g., images, data, etc.), and they can reproduce your survey on their own computer.\nWant to print out your survey for an appendix? Render the survey with all pages visible then print it to pdf.\nWant others to see your survey live? Just set the database into pause mode and your survey will function without recording any responses.\n\nReproducibility is something we had in mind from the start with this project, and we’ve tried to make it as easy as possible for your surveydown surveys to be fully reproducible."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#getting-started",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#getting-started",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Getting started",
    "text": "Getting started\nAfter getting everything installed, we recommend starting with a template survey project. To do so, run the following in the R console:\n\nsurveydown::sd_create_survey(\"path/to/folder\")\n\nThis will create a folder with the following files:\n\nexample.qmd: a template survey you should edit.\nexample.Rproj: An RStudio project file (helpful if you’re working in RStudio)\n_extensions: A folder with the surveydown Quarto extension needed to make everything work (don’t modify this).\n\nIf you have the example open in RStudio, you can click the “Run document” button, or in your terminal run quarto serve example.qmd. Either approach should render the example survey into a shiny app that you can preview in a browser. Don’t worry just yet about setting up your database or making the survey live - for now, we’re going to focus on designing the survey and running it locally to preview it. The example survey should look like this:"
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#adding-pages",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#adding-pages",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Adding pages",
    "text": "Adding pages\nIn surveydown, pages are delineated using “fences”, like this:\n\n::: {#welcome .sd-page}\n\nPage 1 content here\n\n:::\n\n::: {#page2 .sd-page}\n\nPage 2 content here\n\n:::\n\nAs you can see, we use three colon symbols :::, called a “fence”, to mark the start and end of pages. This notation is commonly used in Quarto for a variety of use cases, like defining subfigures in images.\nIn the starting fence, you need to define a page name (e.g. welcome and page2 in the example above) and you need to define the class as .sd-page. Then anything you put between the page fences will appear on that page.\nTo navigate to the next page, you need to insert a sd_next() function call inside a code chunk, like this:\n\n```{r}\nsd_next(next_page = 'page2')\n```\n\nThe above code chunk will create a “Next” button that goes on to page 2 that looks like this:\n\n\n\nNext\n\n\n\n\nYou would need to place the code chunk in between the ::: fences of the welcome page in order to have a “Next” button that goes on to page 2. You can also send the user to other pages by just changing the next_page argument. Finally, you can also change the label of the button by changing the label argument, like this:\n\n```{r}\nsd_next(next_page = 'page2', label = 'Next page')\n```\n\n\n\n\nNext page"
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#adding-questions",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#adding-questions",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Adding questions",
    "text": "Adding questions\nEvery survey question is created using the sd_question() function inside a code chunk. The question type is defined by the type argument. For example, to add a multiple choice question, you could insert the following code chunk:\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'penguins',\n  label = \"Which is your favorite type of penguin?\",\n  option = c(\n    'Adélie'    = 'adelie',\n    'Chinstrap' = 'chinstrap',\n    'Gentoo'    = 'gentoo'\n  )\n)\n```\n\nThe above code chunk will create a multiple choice question that looks like this:\n\n\n\n\nWhich is your favorite type of penguin? *\n\n\n\n\n\nAdélie\n\n\n\n\n\nChinstrap\n\n\n\n\n\nGentoo\n\n\n\n\n\n\n\n\nThe sd_question() function can be used to create a variety of question types, like text input, select drop down choices, and more by changing the type argument.\nThe function has many other arguments for customizing the look and feel of the question (e.g., height and width, etc.)."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#the-server-chunk",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#the-server-chunk",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "The server chunk",
    "text": "The server chunk\nAt the very bottom of the .qmd file is a special “server” code chunk (that’s the #| context: server bit) that defines the app server. This is where you can customize and control the survey flow logic as well as where you define the database that will store the survey response data. It looks like this:\n\n```{r}\n#| context: server\n\n# Define the database settings\ndb &lt;- sd_database()\n\n# Define the configuration settings\nconfig &lt;- sd_config()\n\n# The sd_server() function initiates your survey - don't change this\nsd_server(\n  input   = input,\n  session = session,\n  config  = config,\n  db      = db\n)\n```\n\nThe sd_database() function is where you set up your database. The sd_server() function makes everything run, which you can safely ignore - just don’t change it and all will be good!\nThe middle part (the sd_config() function) is where you can define custom control logic for the survey, such as conditional display (conditionally displaying a question based on responses to questions), or conditional skip (conditionally sending the respondent to a page based on responses to questions)."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#going-live",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#going-live",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Going live!",
    "text": "Going live!\nOnce you are happy with your survey, you can deploy it live to any server of your choice. Since it’s a shiny app, you can deploy it to shinyapps.io for free!"
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#conditional-display",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#conditional-display",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Conditional display",
    "text": "Conditional display\nLet’s say we had a fourth option for “other” in our multiple choice question about penguins. If the respondent chose it, you may want a second question to popup that allows them to specify the other penguin type. To implement this, you would need to define both questions, e.g.:\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'penguins',\n  label = \"Which is your favorite type of penguin?\",\n  option = c(\n    'Adélie'    = 'adelie',\n    'Chinstrap' = 'chinstrap',\n    'Gentoo'    = 'gentoo',\n    'Other'     = 'other'\n  )\n)\n\nsd_question(\n  type  = \"text\",\n  id    = \"penguins_other\",\n  label = \"Please specify the other penguin type:\"\n)\n```\n\nThen in the server code chunk, you could use the show_if argument to define that the penguins_other question would only be shown if the respondent chose the other option in the penguins question, like this:\n\nconfig &lt;- sd_config(\n  show_if = tibble::tribble(\n    ~question_id,  ~question_value, ~target,\n    \"penguins\",    \"other\",         \"penguins_other\"\n  )\n)\n\nThis will make the penguins_other question only appear if the respondent chose the other option in the penguins question, like this:\n\n\n\n\nHere we’re using the tibble::tribble() function to define a data frame with three columns:\n\nquestion_id: The id of the triggering question.\nquestion_value: The triggering value.\ntarget: The id of the target question to display.\n\nYou don’t have to use tibble::tribble(), and in fact if you have a lot of show_if conditions, then you could create a csv file with all of your conditions in it and read it in to set the show_if conditions (just make sure the header has the same three column names), e.g.:\n\nconfig &lt;- sd_config(\n  show_if = readr::read_csv('path/to/show_if_conditions.csv')\n  )\n)"
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#conditional-skip",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#conditional-skip",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Conditional skip",
    "text": "Conditional skip\nOften times you’ll want to screen people out of a survey based on responses to questions. For example, let’s say you only wanted to only include people who own a vehicle. On your first page (e.g., with page name welcome), you could screen out people who do not own a vehicle.\nFirst, define a question about their vehicle ownership, e.g.:\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'vehicle_ownership',\n  label = \"Do you own your vehicle?\",\n  option = c(\n    'Yes' = 'yes',\n    'No'  = 'no'\n  )\n)\n```\n\nThen in the server code chunk, you could use the skip_if argument in sd_config() to define the behavior of the next button on the welcome page, like this:\n\nconfig &lt;- sd_config(\n  skip_if = tibble::tribble(\n    ~question_id,        ~question_value, ~target,\n    \"vehicle_ownership\", \"no\",            \"screenout\"\n  )\n)\n\nThis sets up a condition where if the respondent chooses no on the vehicle_ownership question, they will be sent to a page named screenout. You could put such a page at the end of the survey, something like this:\n\n::: {#screenout .sd-page}\n\nSorry, but you are not qualified to take our survey.\n\n:::\n\nNotice that I don’t have a sd_next() on this screenout page. That is how you define an end point for the survey taker. If there’s no “Next” button, then they cannot navigate anywhere else, so the survey is over."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#required-responses",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#required-responses",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Required responses",
    "text": "Required responses\nBy default, no questions are required. However, you can make questions required by adding the question id to the required argument in sd_config(), like this:\n\nconfig &lt;- sd_config(\n  required_questions = c(\"vehicle_ownership\", \"penguins_other\")\n)\n\nThis will make the respondent unable to proceed until they have answered the required questions. It will also place a red asterisk (*) next to the question label to indicate that the question is required.\nYou can also make all questions required by setting all_questions_required = TRUE like this:\n\nconfig &lt;- sd_config(\n  all_questions_required = TRUE\n)"
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#reactivity",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#reactivity",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Reactivity",
    "text": "Reactivity\nOne other feature that is particularly powerful is the ability to use R code in your survey via Shiny’s reactive programming. This allows you to make your survey more interactive and to use the full power of R to create custom functionality.\n\nDemo 1: Displaying content based on previous responses\nLet’s say you wanted to create a survey that asked the respondent’s name, and then displayed a personalized message based on their name. You could do this by first asking their name:\n\nsd_question(\n  type  = \"text\",\n  id    = \"name\",\n  label = \"What is your name?\"\n)\n\nThen you can use the sd_display_value(\"name\") function to display the value of the name question in other parts of your survey. For example:\n\nWelcome, `r sd_display_value(\"name\")`!\n\nWhich would render as something like “Welcome, Dave!” (assuming the respondent entered “Dave” in the name question). This works because the sd_display_value() function is reactive, meaning it will update the display based on the respondent’s responses.\n\n\nDemo 2: Displaying randomized question labels\nLet’s say you wanted to show a series of questions, but you wanted to randomize the labels shown for each question. You could do this by first defining a list of labels, and then using the sd_question_reactive() function to create a question that will display a random label from the list.\nFor example, let’s ask the respondent to rate different car brands from a random set of brands. You could first pre-define the randomized sets of brands for each respondent and store it as a csv file, like this:\n\nbrands &lt;- c(\"Toyota\", \"Ford\", \"Chevrolet\", \"Honda\", \"Nissan\", \"Tesla\")\ndesign &lt;- data.frame(\n  respondent_id = rep(1:10, each = 3),\n  brand = unlist(lapply(1:10, function(x) sample(brands, 3, replace = FALSE)))\n)\nwrite_csv(design, \"design.csv\")\n\nThis would make a design file that looks like this:\n\n\n#&gt;   respondent_id     brand\n#&gt; 1             1     Honda\n#&gt; 2             1     Tesla\n#&gt; 3             1    Nissan\n#&gt; 4             2     Tesla\n#&gt; 5             2      Ford\n#&gt; 6             2 Chevrolet\n\n\nNote that this would not be done in your survey.qmd file - it’s just a one-time thing to create the design (probably stored in an R file).\nThen in your server code chunk, you could read in the design file and use it to randomize the labels for each question based on a randomly chosen respondent:\n\ndesign &lt;- read_csv(\"design.csv\")\nresp_id &lt;- sample(design$respondent_id, 1)\ndf_resp &lt;- design %&gt;% filter(respondent_id == resp_id)\n\noptions &lt;- c(1, 2, 3)\nnames(options) &lt;- df_resp$brand\n\nsd_question_reactive(\n  type  = \"mc\",\n  id    = \"brands\",\n  label = \"Which of these brands do you like best?\",\n  option = options\n)\n\nHere the sd_question_reactive() function is used because the labels depend on the randomly chosen respondent. This means the labels will be different for each respondent.\nSince this is a reactive question, this code must be placed inside the server code chunk, not where you want it to appear in the survey. To define where in the survey the question should appear, you use the sd_display_question() function with the id set to the same value as the id in the sd_question_reactive() function, like this:\n\nsd_display_question(id = \"brands\")\n\nNow the brands question will be displayed in the survey where you put this code chunk.\nNote that all question responses are automatically saved to the database, but if you wanted to store some other value (e.g. the randomly chosen respondent_id), you could do that with the sd_store_value() function, like this:\n\nsd_store_value(resp_id)"
  }
]