[
  {
    "objectID": "templates/14_custom_plotly_chart.html",
    "href": "templates/14_custom_plotly_chart.html",
    "title": "Custom Plotly Chart",
    "section": "",
    "text": "To create this template, run this command in your R console:\n\nsurveydown::sd_create_survey(\n  #path = \"path/to/survey\",\n  template = \"custom_plotly_chart\"\n)\n\nRefer to the Start with a template section for more details.\n\n  Open in New Tab    GitHub Repo \n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Templates",
      "Custom",
      "Custom Plotly Chart"
    ]
  },
  {
    "objectID": "templates/12_conjoint_tables.html",
    "href": "templates/12_conjoint_tables.html",
    "title": "Choice-based-conjoint Survey with Tables",
    "section": "",
    "text": "To create this template, run this command in your R console:\n\nsurveydown::sd_create_survey(\n  #path = \"path/to/survey\",\n  template = \"conjoint_tables\"\n)\n\nRefer to the Start with a template section for more details.\n\n  Open in New Tab    GitHub Repo \n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Templates",
      "Conjoint",
      "Conjoint Tables"
    ]
  },
  {
    "objectID": "templates/10_live_polling.html",
    "href": "templates/10_live_polling.html",
    "title": "Live Polling",
    "section": "",
    "text": "To create this template, run this command in your R console:\n\nsurveydown::sd_create_survey(\n  #path = \"path/to/survey\",\n  template = \"live_polling\"\n)\n\nRefer to the Start with a template section for more details.\n\n  GitHub Repo \n\n\n\n\n\n\n\nNote\n\n\n\n\nThe live-polling feature requires connection to database and cannot be demonstrated in the template preview. Therefore, a screenshot of bar chart resulted by live-polling is shown here instead.\nTo make this template work, you should firstly define your credentials by calling sd_db_config(), and then delete the ignore = TRUE argument in the sd_db_connect() function call. Once your survey is up and running, try to go through the survey several times. You’ll see the bar chart updating in real-time as new responses are submitted.\n\n\n\n\n\n\nIn the screenshot above, the survey page shows the choice of the current session, as well as a bar chart of all responses from the database. The bar chart updates in real-time as new responses are submitted. This feature is useful for live polling or feedback sessions where you want to see how opinions change over time.\n\n\n\n Back to top",
    "crumbs": [
      "Templates",
      "Reactivity",
      "Live Polling"
    ]
  },
  {
    "objectID": "templates/08_reactive_drilldown.html",
    "href": "templates/08_reactive_drilldown.html",
    "title": "Reactive drilldown",
    "section": "",
    "text": "To create this template, run this command in your R console:\n\nsurveydown::sd_create_survey(\n  #path = \"path/to/survey\",\n  template = \"reactive_drilldown\"\n)\n\nRefer to the Start with a template section for more details.\n\n  Open in New Tab    GitHub Repo \n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Templates",
      "Reactivity",
      "Reactive drilldown"
    ]
  },
  {
    "objectID": "templates/06_random_options_predefined.html",
    "href": "templates/06_random_options_predefined.html",
    "title": "Predefined Random Options",
    "section": "",
    "text": "To create this template, run this command in your R console:\n\nsurveydown::sd_create_survey(\n  #path = \"path/to/survey\",\n  template = \"random_options_predefined\"\n)\n\nRefer to the Start with a template section for more details.\n\n  Open in New Tab    GitHub Repo \n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Templates",
      "Randomization",
      "Random Options Predefined"
    ]
  },
  {
    "objectID": "templates/04_conditional_navigation.html",
    "href": "templates/04_conditional_navigation.html",
    "title": "Conditional Navigation",
    "section": "",
    "text": "To create this template, run this command in your R console:\n\nsurveydown::sd_create_survey(\n  #path = \"path/to/survey\",\n  template = \"conditional_navigation\"\n)\n\nRefer to the Start with a template section for more details.\n\n  Open in New Tab    GitHub Repo \n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Templates",
      "Basic",
      "Conditional Navigation"
    ]
  },
  {
    "objectID": "templates/02_question_types.html",
    "href": "templates/02_question_types.html",
    "title": "Question Types",
    "section": "",
    "text": "To create this template, run this command in your R console:\n\nsurveydown::sd_create_survey(\n  #path = \"path/to/survey\",\n  template = \"question_types\"\n)\n\nRefer to the Start with a template section for more details.\n\n  Open in New Tab    GitHub Repo \n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Templates",
      "Basic",
      "Question Types"
    ]
  },
  {
    "objectID": "templates.html",
    "href": "templates.html",
    "title": "Templates",
    "section": "",
    "text": "To help you get started with surveydown, we created some templates that cover many of the features of the package. Feel free to use any as a starting point for your own surveys or as a reference for specific features.\nCall sd_create_survey() with proper arguments to create your desired templates in your preferred directory. Refer to the Start with a template section for more details.\n\n View the templates repo\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlain Template\n\n\n\nBasic\n\n\n\nA minimum template for starting from scratch.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion Types\n\n\n\nBasic\n\n\n\nA template showcasing all built-in question types.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConditional Display\n\n\n\nBasic\n\n\n\nA template for the conditional display feature.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConditional Navigation\n\n\n\nBasic\n\n\n\nA template for the conditional navigation feature.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRandom Options\n\n\n\nRandomization\n\n\n\nA template for creating randomized survey options.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPredefined Random Options\n\n\n\nRandomization\n\n\n\nA template for creating predefined randomized survey options.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReactive Questions\n\n\n\nReactivity\n\n\n\nA template for creating reactive survey questions.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReactive drilldown\n\n\n\nReactivity\n\n\n\nA reactive question template, with latter question options defined from former selection.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExternal Redirect\n\n\n\nReactivity\n\n\n\nA reactive question template with redirectional links, accepting URL parameters.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLive Polling\n\n\n\nReactivity\n\n\n\nA reactive question template of live-polling with responses shown as a bar chart.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChoice-based-conjoint Survey with Buttons\n\n\n\nConjoint\n\n\n\nA conjoint survey template with options shown in buttons.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChoice-based-conjoint Survey with Tables\n\n\n\nConjoint\n\n\n\nA conjoint survey template, with option contents shown in a table.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCustom Leaflet Map\n\n\n\nCustom\n\n\n\nA template of custom leaflet map question using sd_question_custom().\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCustom Plotly Chart\n\n\n\nCustom\n\n\n\nA template of custom plotly chart question using sd_question_custom().\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top",
    "crumbs": [
      "Templates"
    ]
  },
  {
    "objectID": "faq.html",
    "href": "faq.html",
    "title": "Frequently Asked Questions",
    "section": "",
    "text": "Note\n\n\n\nHave a question but don’t see an answer here? Feel free to make a post on GitHub:\n\nPost a bug report or documentation issue on the GitHub repo issues page.\nAsk a question, make a feature request, start a discussion, or show off your project on the discussion board."
  },
  {
    "objectID": "faq.html#is-surveydown-right-for-me",
    "href": "faq.html#is-surveydown-right-for-me",
    "title": "Frequently Asked Questions",
    "section": "Is surveydown right for me?",
    "text": "Is surveydown right for me?\nsurveydown might be a good fit for you today if…\n\nyou are comfortable using Quarto for rendering markdown into html outputs and  for basic coding (you certainly don’t need to be an R “expert” to use surveydown!)\nyou are frustrated with alternative survey platforms that require expensive licenses or have limited features.\nyou want to collaborate on surveys with others using reproducible tools like Git.\nyou don’t mind using a project that is not fully polished or finished.\n\nsurveydown might not be a good fit for you today if…\n\nyou need stable, polished software that is mature and completely bug-free.\nyou need a product with a guaranteed security level, such as HIPAA compliance (see our security page for more details).\nyou prefer a platform that uses a graphic interface to define survey content."
  },
  {
    "objectID": "faq.html#why-is-my-survey-app-so-slow-when-starting",
    "href": "faq.html#why-is-my-survey-app-so-slow-when-starting",
    "title": "Frequently Asked Questions",
    "section": "Why is my survey app so slow when starting?",
    "text": "Why is my survey app so slow when starting?\nWhen a {surveydown} survey first runs, it checks for files in a **_survey** folder that contain the rendered content from your survey.qmd file. If any of those files are missing or if changes have been detected in your survey.qmd or app.R files, it will re-render your survey, which can take a bit longer. But this only happens once, and afterwards so long as no further changes have been made to your survey files the app will use the saved content in the **_survey** folder to launch, which should load almost instantly. So if your app launches slowly, just close it and launch it again and you should immediately load. If you still see a slow launch, consider posting an issue to let us know that something might be wrong.\nAlso, it is important that you run your survey locally at least once before deploying it live. This will render all your survey content into the **_survey** folder, which will also get uploaded when you deploy it."
  },
  {
    "objectID": "faq.html#how-do-i-make-a-question-required",
    "href": "faq.html#how-do-i-make-a-question-required",
    "title": "Frequently Asked Questions",
    "section": "How do I make a question required?",
    "text": "How do I make a question required?\nUse the required_questions argument in sd_server() to control required responses (see the required questions page for more details)."
  },
  {
    "objectID": "faq.html#why-is-my-shinyapps-deployment-failing",
    "href": "faq.html#why-is-my-shinyapps-deployment-failing",
    "title": "Frequently Asked Questions",
    "section": "Why is my shinyapps deployment failing?",
    "text": "Why is my shinyapps deployment failing?\nFirst, make sure your Suppabase credentials are correctly defined, including your Supabase project settings and password settings. The password defined by sd_db_config() should be the same as your Supabase project password. Access the Storing Data page for how to set all Supabase credentials. Then, make sure your survey runs on your local machine and can successfully link with your Supabase project table. With these confirmed, your shinyapps deployment should work without problem.\nIf you still encounter an error (e.g., the page shows the app failed to start, or you see the page but it doesn’t run properly), try clearing your cache. The simplest way to do so is to reboot your computer. It may also help if you delete previously generated files, such as the survey.html file if you rendered it and the rsconnect folder. After re-rendering, you should be able to deploy the app without error."
  },
  {
    "objectID": "faq.html#how-should-i-install-the-surveydown-package",
    "href": "faq.html#how-should-i-install-the-surveydown-package",
    "title": "Frequently Asked Questions",
    "section": "How should I install the {surveydown} package?",
    "text": "How should I install the {surveydown} package?\nYou can install the {surveydown} package from CRAN or the GitHub repo of the package source code. Follow our installation instructions for either approach.\nSometimes neither of these approaches work, often because your path is managed by some package managing system like Anaconda. In this case, a third alternative is to download the zip file of the package source code and then install it locally.\nTo download the zip file, go the the surveydown repo, click on the green “Code” button and click on “Download Zip”, or simplify click on this link.\nUnzip this repo, then open the surveydown.Rproj file. In your R Console panel, run this code to install:\n\n# install.packages('devtools') \ndevtools::install(force = TRUE)"
  },
  {
    "objectID": "docs/system-translations.html",
    "href": "docs/system-translations.html",
    "title": "System Translations",
    "section": "",
    "text": "As of v0.4.2, {surveydown} supports the ability to set the system language for all system messages (i.e. text elements such as button labels and warnings) and to provide the language specific format for date type questions. You can also customize the system messages by providing a translations.yml file in your root project directory.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "System Translations"
    ]
  },
  {
    "objectID": "docs/system-translations.html#setting-the-language",
    "href": "docs/system-translations.html#setting-the-language",
    "title": "System Translations",
    "section": "Setting the Language",
    "text": "Setting the Language\nTo set the language of your survey, you can use the language argument in the sd_server() function in your app.R file. For example, to set the survey language to Spanish, you would write:\n\nserver &lt;- function(input, output, session) {\n  sd_server(\n    language = \"es\"\n  )\n}\n\nWhen setting the language argument, make sure to use a valid language code. The list of supported language codes is the same as those supported by Shiny’s dateInput() (a full list of codes is provided at the bottom of this page).\nFor now, {surveydown} comes with built-in translations for the following languages:\n\n\nen - English (Default)\n\nde - German\n\nes - Spanish\n\nfr - French\n\nit - Italian\n\nzh-CN - Chinese (Simplified)\n\nThese translations cover all system messages, meaning you can simply set the language and all default messages should be in the chosen language.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "System Translations"
    ]
  },
  {
    "objectID": "docs/system-translations.html#custom-messages",
    "href": "docs/system-translations.html#custom-messages",
    "title": "System Translations",
    "section": "Custom Messages",
    "text": "Custom Messages\nIf you want to customize the system translations or provide translations in a language that is not yet supported, you can create a translations.yml file in the root folder of your survey project using the following function:\n\nsurveydown::sd_create_translations(language = 'en')\n\nThis will create a file named translations.yml in your root project directory with the language set to whatever you provided as the language argument. You can modify any of the system messages in this file to be used in your survey.\nBelow is an example of the translations.yml file for all default English messages. The keys represent the system message identifiers, and the values are the translated messages:\nen:\n  cancel: Cancel\n  confirm_exit: Confirm Exit\n  sure_exit: Are you sure you want to exit the survey?\n  submit_exit: Submit and Exit\n  warning: Warning\n  required: Please answer all required questions before proceeding.\n  rating_title: Before you go...\n  rating_text: 'Rate your survey experience:'\n  rating_scale: from 1-poor to 5-excellent\n  next: Next\n  exit: Exit Survey\n  close_tab: Please close this tab manually to exit the survey.\n  choose_option: Choose an option...\n  click: Click here\n  redirect: Redirecting in\n  seconds: seconds\n  new_tab: Opens in a new tab\n  redirect_error: 'Error: This text won''t trigger any redirection...'\nWhen you run your survey, {surveydown} will detect the translations.yml file in your root folder and use it to override the default translations. If you provide translations for a language not supported by default, you can use the language argument in sd_server() to set your custom language code. Note that the chosen language still must be from the current list of supported languages.\nFor example, suppose you added translations for Portuguese in your translations.yml:\npt:\n  next: 'Próximo'\n  exit: 'Sair da Pesquisa'\n  # ... other messages\nIn your app.R file, set the language to Portuguese:\n\nserver &lt;- function(input, output, session) {\n  sd_server(\n    language = \"pt\"\n  )\n}\n\nIt is also possible to have multiple translations for different translations in a single translations.yml file and simply select the required language one within the sd_server() function with the matching country code.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "System Translations"
    ]
  },
  {
    "objectID": "docs/system-translations.html#overriding-specific-messages",
    "href": "docs/system-translations.html#overriding-specific-messages",
    "title": "System Translations",
    "section": "Overriding Specific Messages",
    "text": "Overriding Specific Messages\nYou don’t have to provide translations for all system messages. If you only want to change specific messages, you can provide translations only for those messages, and {surveydown} will use the default translations for any missing messages.\nFor example, to customize only all “Next” button label in English, you could include the following in your translations.yml file:\nen:\n  next: 'Continue'\nSince English is the default language, the language doesn’t even have to be defined in the sd_server() function in this case.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "System Translations"
    ]
  },
  {
    "objectID": "docs/system-translations.html#button-defaults",
    "href": "docs/system-translations.html#button-defaults",
    "title": "System Translations",
    "section": "Button Defaults",
    "text": "Button Defaults\nThe translations also apply to default labels in sd_next(), sd_close(), and sd_redirect(). For example, if you use sd_next() without specifying a label, it will use the translated label based on the chosen language.\n\n# In your survey.qmd file\n\n# This will display \"Weiter\" if language is set to \"de\" in your app.R file\nsd_next()\n\nHowever, it is still possible to manually adjust the translations in the mentioned functions inside the survey.qmd file using the label argument for each case.\n\n\n\n\n\n\nNote\n\n\n\nIf you separately render your survey.qmd file before running your app.R file, these buttons messages may appear in English in the rendered survey.html file in your root project folder. This is because the survey file doesn’t “know” the language setting until you locally run your app.R at least once. But don’t worry - just run the app.R file once and the language will then be set. Also, the language setting will always be used when the app is run regardless of what the local survey.html file looks like.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "System Translations"
    ]
  },
  {
    "objectID": "docs/system-translations.html#notes",
    "href": "docs/system-translations.html#notes",
    "title": "System Translations",
    "section": "Notes",
    "text": "Notes\n\nWhen providing custom translations, make sure the keys match exactly the expected message identifiers.\nIf you create the translations.yml file manually, please note that each text element containing a : character must be written in quotation marks and the last line must contain a line break.\nIf you provide an invalid language code in language, {surveydown} will fall back to English.\nIf a message is not translated in your translations.yml file, {surveydown} will use the default translation for that message.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "System Translations"
    ]
  },
  {
    "objectID": "docs/system-translations.html#full-language-code-list",
    "href": "docs/system-translations.html#full-language-code-list",
    "title": "System Translations",
    "section": "Full Language Code List",
    "text": "Full Language Code List\nThe full list of supported language codes can be found in the documentation for shiny::dateInput(). We list them here as a quick reference:\n\n\nar - Arabic\n\naz - Azerbaijani\n\nbg - Bulgarian\n\nbs - Bosnian\n\nca - Catalan\n\ncs - Czech\n\ncy - Welsh\n\nda - Danish\n\nde - German\n\nel - Greek\n\nen - English (Default)\n\nen-AU - English (Australia)\n\nen-GB - English (UK)\n\neo - Esperanto\n\nes - Spanish\n\net - Estonian\n\neu - Basque\n\nfa - Persian\n\nfi - Finnish\n\nfo - Faroese\n\nfr - French\n\nfr-CH - French (Switzerland)\n\ngl - Galician\n\nhe - Hebrew\n\nhr - Croatian\n\nhu - Hungarian\n\nhy - Armenian\n\nid - Indonesian\n\nis - Icelandic\n\nit - Italian\n\nit-CH - Italian (Switzerland)\n\nja - Japanese\n\nka - Georgian\n\nkh - Khmer\n\nkk - Kazakh\n\nko - Korean\n\nkr - Korean\n\nlt - Lithuanian\n\nlv - Latvian\n\nme - Montenegrin\n\nmk - Macedonian\n\nmn - Mongolian\n\nms - Malay\n\nnb - Norwegian Bokmål\n\nnl - Dutch\n\nnl-BE - Dutch (Belgium)\n\nno - Norwegian\n\npl - Polish\n\npt - Portuguese\n\npt-BR - Portuguese (Brazil)\n\nro - Romanian\n\nrs - Serbian\n\nrs-latin - Serbian (Latin)\n\nru - Russian\n\nsk - Slovak\n\nsl - Slovenian\n\nsq - Albanian\n\nsr - Serbian\n\nsr-latin - Serbian (Latin)\n\nsv - Swedish\n\nsw - Swahili\n\nth - Thai\n\ntr - Turkish\n\nuk - Ukrainian\n\nvi - Vietnamese\n\nzh-CN - Chinese (Simplified)\n\nzh-TW - Chinese (Traditional)",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "System Translations"
    ]
  },
  {
    "objectID": "docs/server-options.html",
    "href": "docs/server-options.html",
    "title": "Server Options",
    "section": "",
    "text": "All survey configuration settings are defined within the server function in the app.R file. The server() function is a standard Shiny server function that takes input, output, and session as arguments.\nIf you create a new survey using a template, the server() function looks like this:\nserver &lt;- function(input, output, session) {\n\n  # Define conditional skip logic (skip forward to page if a condition is TRUE)\n  sd_skip_forward()\n\n  # Define conditional display logic (show a question if a condition is TRUE)\n  sd_show_if()\n\n  # Main server to control the app\n  sd_server(db = db)\n\n}\nThe sd_skip_forward() and sd_show_if() functions are used to define Conditional Logic, including Conditional Question Display and Conditional Page Navigation.\nThe sd_server() function is used to run the survey. It handles the main logic, such as page navigation and managing the survey data. The db = db argument is required if you are using a database connection, which should be defined using the sd_database() function (see the Store Data page for more details).\nThe sd_server() function also has many other optional arguments that can be used to customize the survey behavior. This page details these options.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "Server Options"
    ]
  },
  {
    "objectID": "docs/server-options.html#required-questions",
    "href": "docs/server-options.html#required-questions",
    "title": "Server Options",
    "section": "Required questions",
    "text": "Required questions\nBy default, no questions are required. However, you can make questions required by providing a vector containing the id of the questions to be required to the required_questions argument in sd_server(), like\n\nsd_server(\n1  required_questions = c(\"vehicle_ownership\", \"penguins_other\")\n)\n\n\n1\n\nThe required_questions argument takes a vector of question IDs that you want to make required.\n\n\n\n\nThis will make the respondent unable to proceed until they have answered the required questions. It will also place a red asterisk (*) next to the question label to indicate that the question is required.\nYou can also make all questions required by setting all_questions_required = TRUE like this:\n\nsd_server(\n  all_questions_required = TRUE\n)",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "Server Options"
    ]
  },
  {
    "objectID": "docs/server-options.html#starting-page",
    "href": "docs/server-options.html#starting-page",
    "title": "Server Options",
    "section": "Starting page",
    "text": "Starting page\nWhen editing your survey, it can be helpful to start the survey at a specific page. You can define the starting page with the start_page argument in the sd_server() function, like this:\n\nsd_server(\n  start_page = \"page_id\"\n)",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "Server Options"
    ]
  },
  {
    "objectID": "docs/server-options.html#auto-scroll",
    "href": "docs/server-options.html#auto-scroll",
    "title": "Server Options",
    "section": "Auto scroll",
    "text": "Auto scroll\nThe auto scroll feature allows the page to automatically scroll according to the user’s working progress and is enabled by default.\n\nsd_server(\n  auto_scroll = TRUE # Change to FALSE to switch it off.\n)",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "Server Options"
    ]
  },
  {
    "objectID": "docs/server-options.html#rating-question",
    "href": "docs/server-options.html#rating-question",
    "title": "Server Options",
    "section": "Rating question",
    "text": "Rating question\nYou may want to add a rating question by the end of the survey to collect user reflections. Simply set rate_survey to TRUE (Default to FALSE):\n\nsd_server(\n  rate_survey = TRUE\n)\n\nSurvey rating is triggered by the “Exit Survey” button by the end of the survey. If you want to implement the survey rating, make sure you define the Exit Button by the end of the survey using the sd_close() function, and then define rate_survey = TRUE in sd_server().\nBelow are the TRUE and FALSE cases for rate_survey:\n\nTRUEFALSE\n\n\nIf rate_survey is TRUE, a survey rating question will pop up:\n\n\n\n\n\nIf rate_survey is FALSE, a confirm exit dialog box will pop up:",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "Server Options"
    ]
  },
  {
    "objectID": "docs/server-options.html#system-translations",
    "href": "docs/server-options.html#system-translations",
    "title": "Server Options",
    "section": "System translations",
    "text": "System translations\nTo systematically display the preset system messages and button text elements in a different language, change the system language using a different country code (default is \"en\" for English).\nFor example, to use Spanish use:\n\nsd_server(\n  language = \"es\"\n)\n\nFive languages are supported by default, but you can customize the messages to any language (or any message) you want. See the System Translations page for more details.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "Server Options"
    ]
  },
  {
    "objectID": "docs/server-options.html#cookies",
    "href": "docs/server-options.html#cookies",
    "title": "Server Options",
    "section": "Cookies",
    "text": "Cookies\nCookies are used to store user sessions, including their session ID, survey data storage (backend), and their survey progress (frontend).\nBy default, the cookies are enabled. You can disable the cookies by setting cookies = FALSE in the sd_server() function, like this:\n\nsd_server(\n  cookies = FALSE\n)",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "Server Options"
    ]
  },
  {
    "objectID": "docs/reactivity.html",
    "href": "docs/reactivity.html",
    "title": "Reactivity",
    "section": "",
    "text": "Because surveydown renders to a Shiny app, it can take advantage of Shiny’s reactivity features. This means you can create reactive expressions and reactive values that update the survey in response to user input or other events.\nThis page demonstrates some common use cases for reactive programming in surveydown.",
    "crumbs": [
      "Documentation",
      "Interactivity",
      "Reactivity"
    ]
  },
  {
    "objectID": "docs/reactivity.html#displaying-question-values-in-the-survey",
    "href": "docs/reactivity.html#displaying-question-values-in-the-survey",
    "title": "Reactivity",
    "section": "Displaying question values in the survey",
    "text": "Displaying question values in the survey\nA simple example of using a reactive value is displaying a question value somewhere else in the survey.\nFor example, you might ask the respondent’s name in a question and then display their name somewhere else in the survey, like in a greeting message. First, you would ask the respondent’s name in a question in your survey.qmd file:\n\nsd_question(\n  type  = \"text\",\n  id    = \"name\",\n  label = \"What is your name?\"\n)\n\nThen you can use the sd_output() function to display the value of the \"name\" question elsewhere in the survey. For example, you could display the name in a greeting message:\n\nWelcome, `r sd_output(\"name\", type = \"value\")`!\n\nIf the respondent entered “Dave” in the name question, this would render as:\n\nWelcome, Dave!\n\nThe type = \"value\" argument tells sd_output() to display the value of the question rather than the question itself.\n\n\n\n\n\n\nHow this works under the hood\n\n\n\nEvery question has it’s own id. To access the value that a respondent chose, we can’t use the same id. To address this, whenever you create a question we automatically create an object stored as id_value to store the value chosen by the respondent.\nFor example, if the question id was \"name\", then the value would be stored as \"name_value\". In the sd_output() function, when you use type = \"value\", the function automatically appends this _value to the id to get the question value we want to display, then uses an appropriate shiny output function to display it, e.g. shiny::textOutput().\nYou can also use type = \"question\" to display questions that are defined in the server() function in your app.R file (see the defining questions in the server function section below).",
    "crumbs": [
      "Documentation",
      "Interactivity",
      "Reactivity"
    ]
  },
  {
    "objectID": "docs/reactivity.html#displaying-stored-values-e.g.-a-completion-code",
    "href": "docs/reactivity.html#displaying-stored-values-e.g.-a-completion-code",
    "title": "Reactivity",
    "section": "Displaying stored values (e.g. a completion code)",
    "text": "Displaying stored values (e.g. a completion code)\nYou can use sd_output() with type = \"value\" to display values that you stored in the server() function.\nFor example, you might want to display a completion code at the end of the survey. You can do this by defining a completion code in the server() function and then storing it in the survey data using the sd_store_value() function.\nSince completion codes are often needed, we made a simple sd_completion_code() function that returns a random numeric completion code as a string. Here’s an example of how to use it:\n\n# Make a 10-digit random number completion code\ncompletion_code &lt;- sd_completion_code(10)\n\n# Store the completion code in the survey data\nsd_store_value(completion_code)\n\nThis will store the completion code in the survey data under the completion_code column.\nYou can then display the completion code at the end of the survey using the sd_output() function in your survey.qmd file, like this:\n\nYour code is: `r sd_output(\"completion_code\", type = 'value')`\n\nThis should render as something like this:\n\nYour code is: 7408931907",
    "crumbs": [
      "Documentation",
      "Interactivity",
      "Reactivity"
    ]
  },
  {
    "objectID": "docs/reactivity.html#displaying-the-same-value-in-multiple-places",
    "href": "docs/reactivity.html#displaying-the-same-value-in-multiple-places",
    "title": "Reactivity",
    "section": "Displaying the same value in multiple places",
    "text": "Displaying the same value in multiple places\nThe sd_output() function can only be used once per each unique question id because the id gets used in the rendered HTML divs, and HTML with more than one element with the same id is invalid HTML. This is a general issue for Shiny - outputs can only be used once per each unique id (see this GitHub issue on the topic).\nThe solution that we use is to simply make a copy of the value and then display the copy (this is also the solution on the GitHub issue linked above).\nTo do so, in the server function in the app.R file use the sd_copy_value() function to create a copy of the value, like this:\n\nsd_copy_value(id = \"name\", id_copy = \"name_copy\")\n\nYou can then use the sd_output() function in your survey.qmd file to display both the original and copied values. For example:\n\nWelcome, `r sd_output(\"name\", type = \"value\")`!\n\nIs it alright if we call you `r sd_output(\"name_copy\", type = \"value\")`?\n\nIf the respondent entered “Dave” in the name question, this would render as:\n\nWelcome, Dave!\nIs it alright if we call you Dave?\n\n\n\n\n\n\n\nNote\n\n\n\nIf you find this annoying, we agree! This is a bit of a hack and we are working on a better solution, but it is a limitation of Shiny that we have to live with, at least for now.",
    "crumbs": [
      "Documentation",
      "Interactivity",
      "Reactivity"
    ]
  },
  {
    "objectID": "docs/reactivity.html#working-with-calculated-values",
    "href": "docs/reactivity.html#working-with-calculated-values",
    "title": "Reactivity",
    "section": "Working with calculated values",
    "text": "Working with calculated values\nOften times you’ll need to create intermediate objects in your server that depend on question responses. In this situation, the intermediate objects won’t be generated when the survey launches since the question response(s) needed to calculate them are not yet answered. Instead, they’ll need to be reactively created once the respondent answers the questions.\nTo provide a concrete example, suppose you have a page in your survey.qmd file like the one below. In this page, the questions first_number and second_number define two numeric values. Below these questions, we have several lines that print out the following:\n\nThe values themselves\nTwo computed values based on the two input numbers (product and sum).\nA summary sentence that prints a summary of everything above, which is created in the server.\n\nExample page in survey.qmd** file**:\n\n::: {#page1 .sd-page}\n\n# Demo - Calculation\n\n```{r}\nsd_question(\n  type  = 'numeric',\n  id    = 'first_number',\n  label = \"Type in your first number:\"\n)\n\nsd_question(\n  type  = 'numeric',\n  id    = 'second_number',\n  label = \"Type in your second number:\"\n)\n```\n\nYour first number is: `r sd_output(\"first_number\", type = \"value\")`.\n\nYour second number is: `r sd_output(\"second_number\", type = \"value\")`.\n\nThe product of these 2 numbers is: `r sd_output(\"product\", type = \"value\")`.\n\nThe sum of these 2 numbers is: `r sd_output(\"sum\", type = \"value\")`.\n\n`r sd_output(\"summary\")`\n\n```{r}\nsd_next()\n```\n\n:::\n\nTo make these values display properly, you can create reactive values with the sd_reactive() function in the server, which reactively updates as the user changes any of the question values. Here is an example of how you might create the product value:\n\nproduct &lt;- sd_reactive(\"product\", {\n  input$first_number * input$second_number\n})\n\nThe sd_reactive() function takes an id (in this case \"product\"), which is the name that will be used in the resulting survey response data to store the returned value. The created object (in this case named product) is a reactive expression that can also be used anywhere else in the server using the () symbols, e.g. product(). Inside the function can be any expression that returns a value. In this case, we’re just multiplying together the two input numbers.\nTo create all of the objects in the example page above, our server would look like this:\napp.R file:\n\nlibrary(surveydown)\n\nserver &lt;- function(input, output, session) {\n\n  # Create reactive values for 'product' and 'sum'\n  product &lt;- sd_reactive(\"product\", {\n    input$first_number * input$second_number\n  })\n\n  sum &lt;- sd_reactive(\"sum\", {\n    input$first_number + input$second_number\n  })\n\n  # Use the reactive values to create an additional 'summary' output\n  output$summary &lt;- renderText({\n    paste(\"The product is:\", product(), \"and the sum is:\", sum())\n  })\n\n  sd_server()\n}\n\n# Launch Survey\nshiny::shinyApp(ui = sd_ui(), server = server)\n\nIn this server, we create two reactive values, product and sum, which get stored in our survey data under those respective names. We also use product() and sum() to create the output$summary object, which is just some rendered text to display on the survey page.",
    "crumbs": [
      "Documentation",
      "Interactivity",
      "Reactivity"
    ]
  },
  {
    "objectID": "docs/reactivity.html#defining-questions-in-the-server-function",
    "href": "docs/reactivity.html#defining-questions-in-the-server-function",
    "title": "Reactivity",
    "section": "Defining questions in the server function",
    "text": "Defining questions in the server function\nOften you will want to define questions where the label or options change based on the respondent’s answers to other questions. You can do this by defining the question in the server function and then displaying it in the survey.qmd file using the sd_output() function.\nFor example, let’s say you want to ask a follow-up question based on the respondent’s answer to a previous question. To do this, you would define the first question in the survey.qmd file as usual, e.g.:\n\nsd_question(\n  id     = \"pet_type\",\n  type   = \"mc\",\n  label  = \"Which do you like more, dogs or cats?\",\n  option = c(\"Dogs\" = \"dog\", \"Cats\" = \"cat\")\n)\n\nMy follow-up question is whether or not the respondent has a pet of the type they chose above. To do this, you would define the follow-up question in the app.R file’s server() function like this:\n\nserver &lt;- function(input, output, session) {\n\n  observe({\n    pet_type &lt;- input$pet_type\n\n    # Make the question label and options\n    label &lt;-glue::glue(\"Are you a {pet_type} owner?\")\n    options &lt;- c('yes', 'no')\n    names(options)[1] &lt;- glue::glue(\"Yes, am a {pet_type} owner\")\n    names(options)[2] &lt;- glue::glue(\"No, I am not a {pet_type} owner\")\n\n    # Make the question\n    sd_question(\n      type   = \"mc\",\n      id     = \"pet_owner\",\n      label  = label,\n      option = options\n    )\n  })\n\n  sd_server()\n}\n\nThe pet_owner question is a reactive question where the label and options will change based on the respondent’s answer to the pet_type question.\n\n\n\n\n\n\nNote\n\n\n\nThe observe() function is used to create the reactive question. This is a core concept in Shiny reactivity that allows you to create reactive expressions that can change based on the values of other reactive expressions.\nAlso, in this example we use the glue package to create the question label and options. This is a powerful package for creating strings that contain variable values.\n\n\nFinally, you can display the pet_owner question in the survey.qmd file using the sd_output() function, like this:\n\n```{r}\nsd_output(id = \"pet_owner\", type = \"question\")\n```",
    "crumbs": [
      "Documentation",
      "Interactivity",
      "Reactivity"
    ]
  },
  {
    "objectID": "docs/question-types.html",
    "href": "docs/question-types.html",
    "title": "Question Types",
    "section": "",
    "text": "All questions in a surveydown survey are created using the sd_question() function. Calls to sd_question() should be put inside code chunks in the survey.qmd file to define the survey questions.\nThe function requires the following three arguments:\nMany question types also require an option argument, which is a named vector of options for the question (e.g. for multiple choice questions). The function also includes many other optional arguments that can be used to customize the question appearance and behavior. See the package documentation for more details.\nBelow are examples of each question type.",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Types"
    ]
  },
  {
    "objectID": "docs/question-types.html#text",
    "href": "docs/question-types.html#text",
    "title": "Question Types",
    "section": "text",
    "text": "text\nUse type = 'text' to specify a text input type question.\n\n\nOutput\nCode\n\n\n\n\n\n\n\nWrite a word:\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type  = \"text\",\n  id    = \"word\",\n  label = \"Write a word:\"\n)\n```",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Types"
    ]
  },
  {
    "objectID": "docs/question-types.html#textarea",
    "href": "docs/question-types.html#textarea",
    "title": "Question Types",
    "section": "textarea",
    "text": "textarea\nUse type = 'textarea' to specify a text area input type question.\n\n\nOutput\nCode\n\n\n\n\n\n\n\nWrite a paragraph:\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type  = \"textarea\",\n  id    = \"paragraph\",\n  label = \"Write a paragraph:\"\n)\n```",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Types"
    ]
  },
  {
    "objectID": "docs/question-types.html#numeric",
    "href": "docs/question-types.html#numeric",
    "title": "Question Types",
    "section": "numeric",
    "text": "numeric\nUse type = 'numeric' to specify a numeric input type.\n\n\nOutput\nCode\n\n\n\n\n\n\n\nWhat’s your age?\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type  = 'numeric',\n  id    = 'age',\n  label = \"What's your age?\"\n)\n```",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Types"
    ]
  },
  {
    "objectID": "docs/question-types.html#mc",
    "href": "docs/question-types.html#mc",
    "title": "Question Types",
    "section": "mc",
    "text": "mc\nUse type = 'mc' to specify a multiple choice type question with a single choice option.\n\n\nOutput\nCode\n\n\n\n\n\n\n\nWhich artist do you prefer most from this list?\n\n\n\n\nTaylor Swift\n\n\n\n\nBeyoncé\n\n\n\n\nAdele\n\n\n\n\nRihanna\n\n\n\n\nLady Gaga\n\n\n\n\nEd Sheeran\n\n\n\n\nDrake\n\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type   = 'mc',\n  id     = 'artist',\n  label  = \"Which artist do you prefer most from this list?\",\n  option = c(\n    \"Taylor Swift\" = \"taylor_swift\",\n    \"Beyoncé\"      = \"beyonce\",\n    \"Adele\"        = \"adele\",\n    \"Rihanna\"      = \"rihanna\",\n    \"Lady Gaga\"    = \"ladygaga\",\n    \"Ed Sheeran\"   = \"ed_sheeran\",\n    \"Drake\"        = \"drake\"\n  )\n)\n```",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Types"
    ]
  },
  {
    "objectID": "docs/question-types.html#mc_multiple",
    "href": "docs/question-types.html#mc_multiple",
    "title": "Question Types",
    "section": "mc_multiple",
    "text": "mc_multiple\nUse type = 'mc_multiple' to specify a multiple choice type question with multiple selection enabled.\n\n\nOutput\nCode\n\n\n\n\n\n\n\nWhat are your favorite Taylor Swift albums (select all that apply)?\n\n\n\n\nTaylor Swift (2006)\n\n\n\n\nFearless (2008)\n\n\n\n\nSpeak Now (2010)\n\n\n\n\nRed (2012)\n\n\n\n\n1989 (2014)\n\n\n\n\nReputation (2017)\n\n\n\n\nLover (2019)\n\n\n\n\nFolklore (2020)\n\n\n\n\nEvermore (2020)\n\n\n\n\nMidnights (2022)\n\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type  = 'mc_multiple',\n  id    = 'swift',\n  label = \"What are your favorite Taylor Swift albums (select all that apply)?\",\n  option = c(\n    \"Taylor Swift (2006)\" = \"taylor_swift\",\n    \"Fearless (2008)\"     = \"fearless\",\n    \"Speak Now (2010)\"    = \"speak_now\",\n    \"Red (2012)\"          = \"red\",\n    \"1989 (2014)\"         = \"1989\",\n    \"Reputation (2017)\"   = \"reputation\",\n    \"Lover (2019)\"        = \"lover\",\n    \"Folklore (2020)\"     = \"folklore\",\n    \"Evermore (2020)\"     = \"evermore\",\n    \"Midnights (2022)\"    = \"midnights\"\n  )\n)\n```",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Types"
    ]
  },
  {
    "objectID": "docs/question-types.html#mc_buttons",
    "href": "docs/question-types.html#mc_buttons",
    "title": "Question Types",
    "section": "mc_buttons",
    "text": "mc_buttons\nUse type = 'mc_buttons' to generate the button version of mc.\n\n\nOutput\nCode\n\n\n\n\n\n\n\nWhich fruit do you prefer most from this list?\n\n\n\nApple\nBanana\nPear\nStrawberry\nGrape\nMango\nWatermelon\n\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type   = 'mc_buttons',\n  id     = 'fruit',\n  label  = \"Which fruit do you prefer most from this list?\",\n  option = c(\n    \"Apple\"      = \"apple\",\n    \"Banana\"     = \"banana\",\n    \"Pear\"       = \"pear\",\n    \"Strawberry\" = \"strawberry\",\n    \"Grape\"      = \"grape\",\n    \"Mango\"      = \"mango\",\n    \"Watermelon\" = \"watermelon\"\n  )\n)\n```\n\n\n\n\nUse direction = \"vertical\" to display the button options vertically.\n\n\nOutput\nCode\n\n\n\n\n\n\n\nWhich fruit do you prefer most from this list?\n\n\n\nApple\nBanana\nPear\nStrawberry\nGrape\nMango\nWatermelon\n\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type   = 'mc_buttons',\n  id     = 'fruit_vertical',\n  label  = \"Which fruit do you prefer most from this list?\",\n  option = c(\n    \"Apple\"      = \"apple\",\n    \"Banana\"     = \"banana\",\n    \"Pear\"       = \"pear\",\n    \"Strawberry\" = \"strawberry\",\n    \"Grape\"      = \"grape\",\n    \"Mango\"      = \"mango\",\n    \"Watermelon\" = \"watermelon\"\n  ), \n  direction = \"vertical\"\n)\n```",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Types"
    ]
  },
  {
    "objectID": "docs/question-types.html#mc_multiple_buttons",
    "href": "docs/question-types.html#mc_multiple_buttons",
    "title": "Question Types",
    "section": "mc_multiple_buttons",
    "text": "mc_multiple_buttons\nUse type = 'mc_multiple_buttons' to generate the button version of mc_multiple.\n\n\nOutput\nCode\n\n\n\n\n\n\n\nWhich are your favorite Michael Jackson songs (select all that apply)?\n\n\n\nThriller (1982)\nBillie Jean (1982)\nBeat It (1982)\nMan in the Mirror (1987)\nSmooth Criminal (1987)\nBlack or White (1991)\nBad (1987)\nHuman Nature (1982)\n\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type  = 'mc_multiple_buttons',\n  id    = 'michael_jackson',\n  label = \"Which are your favorite Michael Jackson songs (select all that apply)?\",\n  option = c(\n    \"Thriller (1982)\"          = \"thriller\",\n    \"Billie Jean (1982)\"       = \"billie_jean\",\n    \"Beat It (1982)\"           = \"beat_it\",\n    \"Man in the Mirror (1987)\" = \"man_in_the_mirror\",\n    \"Smooth Criminal (1987)\"   = \"smooth_criminal\",\n    \"Black or White (1991)\"    = \"black_or_white\",\n    \"Bad (1987)\"               = \"bad\",\n    \"Human Nature (1982)\"      = \"human_nature\"\n  )\n)\n```\n\n\n\n\nUse direction = \"vertical\" to display the button options vertically.\n\n\nOutput\nCode\n\n\n\n\n\n\n\nWhich are your favorite Michael Jackson songs (select all that apply)?\n\n\n\nThriller (1982)\nBillie Jean (1982)\nBeat It (1982)\nMan in the Mirror (1987)\nSmooth Criminal (1987)\nBlack or White (1991)\nBad (1987)\nHuman Nature (1982)\n\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type  = 'mc_multiple_buttons',\n  id    = 'michael_jackson_vertical',\n  label = \"Which are your favorite Michael Jackson songs (select all that apply)?\",\n  option = c(\n    \"Thriller (1982)\"          = \"thriller\",\n    \"Billie Jean (1982)\"       = \"billie_jean\",\n    \"Beat It (1982)\"           = \"beat_it\",\n    \"Man in the Mirror (1987)\" = \"man_in_the_mirror\",\n    \"Smooth Criminal (1987)\"   = \"smooth_criminal\",\n    \"Black or White (1991)\"    = \"black_or_white\",\n    \"Bad (1987)\"               = \"bad\",\n    \"Human Nature (1982)\"      = \"human_nature\"\n  ), \n  direction = \"vertical\"\n)\n```",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Types"
    ]
  },
  {
    "objectID": "docs/question-types.html#select",
    "href": "docs/question-types.html#select",
    "title": "Question Types",
    "section": "select",
    "text": "select\nUse type = 'select' to specify a drop down select type question.\n\n\nOutput\nCode\n\n\n\n\n\n\n\nWhat is the highest level of education you have attained?\n\n\nChoose an option...\nDid not attend high school\nSome high school\nHigh school graduate\nSome college\nCollege\nGraduate Work\nPrefer not to say\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type  = 'select',\n  id    = 'education',\n  label = \"What is the highest level of education you have attained?\",\n  option = c(\n    \"Did not attend high school\" = \"hs_no\",\n    \"Some high school\"           = \"hs_some\",\n    \"High school graduate\"       = \"hs_grad\",\n    \"Some college\"               = \"college_some\",\n    \"College\"                    = \"college_grad\",\n    \"Graduate Work\"              = \"grad\",\n    \"Prefer not to say\"          = \"no_response\"\n  )\n)\n```",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Types"
    ]
  },
  {
    "objectID": "docs/question-types.html#slider",
    "href": "docs/question-types.html#slider",
    "title": "Question Types",
    "section": "slider",
    "text": "slider\n\n\n\n\n\n\nNote\n\n\n\nThis widget only renders well in a Shiny environment, so we just show a screenshot here.\n\n\n\n\nOutput\nCode chunk\n\n\n\n\n\n\n\n\n\n```{r}\nsd_question(\n  type  = 'slider',\n  id    = 'climate_care',\n  label = \"To what extent do you believe human-caused climate change is real?\",\n  option = c(\n    \"Don't Believe\"    = \"dont_believe\",\n    \"Somewhat Believe\" = \"somewhat\",\n    \"Neutral\"          = \"neutral\",\n    \"Believe\"          = \"believe\",\n    \"Strongly Believe\" = \"strongly_believe\"\n  )\n)\n```",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Types"
    ]
  },
  {
    "objectID": "docs/question-types.html#slider_numeric",
    "href": "docs/question-types.html#slider_numeric",
    "title": "Question Types",
    "section": "slider_numeric",
    "text": "slider_numeric\n\n\n\n\n\n\nNote\n\n\n\nThis widget only renders well in a Shiny environment, so we just show a screenshot here.\n\n\nIf your slider uses numeric inputs, use the slider_numeric question type. This type of slider can be used for either single sliders or dual sliders that define a range of values.\nSingle slider:\n\n\nOutput\nCode chunk\n\n\n\n\n\n\n\n\n\n```{r}\nsd_question(\n  type = \"slider_numeric\", \n  id = 'slider_single_val',  \n  label = 'Single value example', \n  option = seq(0, 10, 1)\n)\n```\n\n\n\n\nRange slider:\n\n\nOutput\nCode chunk\n\n\n\n\n\n\n\n\n\n```{r}\nsd_question(\n  type = \"slider_numeric\", \n  id = 'slider_range',  \n  label = 'Range example', \n  option = seq(0, 10, 1), \n  default = c(3, 5)\n)\n```",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Types"
    ]
  },
  {
    "objectID": "docs/question-types.html#date",
    "href": "docs/question-types.html#date",
    "title": "Question Types",
    "section": "date",
    "text": "date\nUse type = 'date' to specify a date input type. The date value will be today’s date by default. Upon clicking on the text box, you are provided with a date dialog box to choose date from.\n\n\n\n\n\n\nNote\n\n\n\nThis widget only renders well in a Shiny environment, so we just show a screenshot here.\n\n\n\n\nOutput\nCode\n\n\n\n\n\n\n\n\n\n```{r}\nsd_question(\n  type  = 'date',\n  id    = 'dob',\n  label = \"What is your date of birth?\"\n)\n```",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Types"
    ]
  },
  {
    "objectID": "docs/question-types.html#daterange",
    "href": "docs/question-types.html#daterange",
    "title": "Question Types",
    "section": "daterange",
    "text": "daterange\nUse type = 'daterange' to specify a date range input type.\n\n\n\n\n\n\nNote\n\n\n\nThis widget only renders well in a Shiny environment, so we just show a screenshot here.\n\n\n\n\nOutput\nCode\n\n\n\n\n\n\n\n\n\n```{r}\nsd_question(\n  type  = 'daterange',\n  id    = 'hs_date',\n  label = \"When did you start and finish high school?\"\n)\n```",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Types"
    ]
  },
  {
    "objectID": "docs/question-types.html#matrix",
    "href": "docs/question-types.html#matrix",
    "title": "Question Types",
    "section": "matrix",
    "text": "matrix\nUse type = 'matrix' to specify a matrix input type.\n\n\nOutput\nCode\n\n\n\n\n\n\n\nPlease indicate your agreement with the following statements.\n\n\n\n\n\n\n\n\n\n\n\nDisagree\nNeutral\nAgree\n\n\n\nI would buy a gasoline car.\n\n\n\n\n\n Disagree \n\n\n Neutral \n\n\n Agree \n\n\n\n*\n\n\n\nI would buy an EV.\n\n\n\n\n\n Disagree \n\n\n Neutral \n\n\n Agree \n\n\n\n*\n\n\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type   = \"matrix\",\n  id     = \"car_preference\",\n  label  = \"Please indicate your agreement with the following statements.\",\n  row    = c(\n    \"I would buy a gasoline car.\" = \"buy_gasoline\",\n    \"I would buy an EV.\"          = \"buy_ev\"\n  ),\n  option = c(\n    \"Disagree\" = \"disagree\",\n    \"Neutral\"  = \"neutral\",\n    \"Agree\"    = \"agree\"\n  )\n)\n```",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Types"
    ]
  },
  {
    "objectID": "docs/performance.html",
    "href": "docs/performance.html",
    "title": "Performance",
    "section": "",
    "text": "Our goal in designing surveydown was to create a package that was both performant and easy to use. While we’ve worked to ensure that the package is efficient, the ultimate performance of your survey in the field will depend on the services you use to host your app, store your data, and field your survey.",
    "crumbs": [
      "Documentation",
      "Deployment & Operations",
      "Performance"
    ]
  },
  {
    "objectID": "docs/performance.html#hosting",
    "href": "docs/performance.html#hosting",
    "title": "Performance",
    "section": "Hosting",
    "text": "Hosting\nWe recommend using shinyapps.io to host your survey as it is designed to work with Shiny Apps. The platform offers a free tier that should work well for most simple surveys. However, more complex surveys may require paid plans to achieve better performance.\nOne thing you can do to improve the performance is to max out the memory settings for your app in the “settings” tab in your app dashboard. It should look something like this:\n\n\n\n\nThe free tier allows for 1 GB of memory, and paid plans can go up much higher (this screenhot is from an earlier period when the free tier memory limits were larger).\nThe other thing to consider is the number of active hours (the free tier allows for 25 active hours per month).\nDepending on your needs, a paid plan may be worth the investment during your actual survey fielding to ensure a smooth user experience. And of course, you can consider other hosting services that might have better options.",
    "crumbs": [
      "Documentation",
      "Deployment & Operations",
      "Performance"
    ]
  },
  {
    "objectID": "docs/performance.html#database",
    "href": "docs/performance.html#database",
    "title": "Performance",
    "section": "Database",
    "text": "Database\nThe surveydown package is designed to work with any PostgreSQL database, but we recommend using Supabase to store your survey responses as it is a fast, reliable, and scalable PostgreSQL database. Like shinyapps.io, Supabase offers a free tier that should work well for most simple surveys, but a paid plan may be needed if you expect to have a large number of concurrent respondents.\nThe free tier allows for 20 concurrent database connections, but since surveydown uses a pooled connection to the database, this limit not directly translate to a hard limit of 20 concurrent respondents.",
    "crumbs": [
      "Documentation",
      "Deployment & Operations",
      "Performance"
    ]
  },
  {
    "objectID": "docs/performance.html#fielding-options",
    "href": "docs/performance.html#fielding-options",
    "title": "Performance",
    "section": "Fielding Options",
    "text": "Fielding Options\nMany researchers use panel providers like Prolific to recruit respondents for their surveys. Given the large number of potential concurrent respondents, you may want to place a limit on the number of people who can complete your survey at once to avoid overloading your app. On prolific, for example, you can set a quota in your study settings, which looks something like this:\n\n\n\n\nAnother option to consider is what types of devices your respondents will be completing your survey on. You may want to test how your survey renders on phones versus computers to see if there are siginificant differences. Some panel providers have options to limit which devices respondents can use to take the survey. On prolific this looks like this:\n\n\n\n\nMany panel providers offer these kinds of fielding options, and we recommend checking with your panel provider to help prevent overloading your app.",
    "crumbs": [
      "Documentation",
      "Deployment & Operations",
      "Performance"
    ]
  },
  {
    "objectID": "docs/getting-started.html",
    "href": "docs/getting-started.html",
    "title": "Getting Started",
    "section": "",
    "text": "Note\n\n\n\nThis is a quick guide for surveydown setup. Proceed to Basic Components to learn about the main components of your survey.",
    "crumbs": [
      "Documentation",
      "Survey Basics",
      "Getting Started"
    ]
  },
  {
    "objectID": "docs/getting-started.html#overview",
    "href": "docs/getting-started.html#overview",
    "title": "Getting Started",
    "section": "Overview",
    "text": "Overview\nEvery surveydown survey is composed of a survey and an app, defined in two separate files:\n\n\nsurvey.qmd: A Quarto document that contains the survey content (pages, questions, etc), which renders to an HTML file.\n\napp.R: An R script defining a Shiny app that contains the global settings (libraries, database configuration, etc.) and server configuration options (e.g., conditional page skipping / question display, etc.).\n\nThese files must be named survey.qmd and app.R.\nThe {surveydown} R package provides a set of functions for defining the survey content and configuration options. Each function starts with sd_ to make them easy to identify.\nThe platform is based on some basic principles:\n\nAdd content to your survey.qmd file using markdown text (or in RStudio use the visual editor).\nDefine survey questions in R code chunks with the sd_question() function.\nDefine pages using fences (:::), with navigation buttons handled using the sd_next() function.\nAdd rich functionality to your survey using a variety of Server Options in the server() function in the app.R file.\nApply conditional logic to question display with sd_show_if() or page navigation with sd_skip_forward().\nStore your respondent data in a database (see Storing Data).\n\nThis approach ensures a flexible survey platform that is fully reproducible and easy to customize.\nThe remaining steps on this page will guide you through the process of creating a surveydown survey.",
    "crumbs": [
      "Documentation",
      "Survey Basics",
      "Getting Started"
    ]
  },
  {
    "objectID": "docs/getting-started.html#install",
    "href": "docs/getting-started.html#install",
    "title": "Getting Started",
    "section": "1. Install",
    "text": "1. Install\nInstall R & Quarto\nYou need both:\n\nInstall \n\nInstall Quarto\n\n\nWe also recommend working with an IDE that has good support for R, Quarto, and Shiny.\nRStudio is great, and we also like VSCode and Positron.\nInstall the {surveydown} R package\nYou can install {surveydown} from CRAN in your R console:\n\ninstall.packages(\"surveydown\")\n\nor you can install the development version from GitHub:\n\n# install.packages(\"pak\")\npak::pak(\"surveydown-dev/surveydown\")\n\nLoad the package with:\n\nlibrary(surveydown)\n\nYou can also check which version you have installed:\n\nsurveydown::sd_version()",
    "crumbs": [
      "Documentation",
      "Survey Basics",
      "Getting Started"
    ]
  },
  {
    "objectID": "docs/getting-started.html#start-with-a-template",
    "href": "docs/getting-started.html#start-with-a-template",
    "title": "Getting Started",
    "section": "2. Start with a template",
    "text": "2. Start with a template\n\n\n\n\n\n\nImportant\n\n\n\nEvery survey created with {surveydown} should be in its own separate project folder.\n\n\nProceed to the Templates tab for a showcase of all available templates.\nWe recommend starting with a template to build your surveydown survey. In the R console, run the following to to setup a template survey:\n\n# Create a plain template under your working directory\nsurveydown::sd_create_survey()\n\n# Create a specified template uner your designated path\nsurveydown::sd_create_survey(\n  path     = \"path/to/folder\",\n  template = \"question_types\"\n)\n\nThe sd_create_survey() function accepts two arguments. The path argument specifies the directory where you want to create your survey project. If left it blank, it will be your current working directory.\nThe template argument specifies which template to use. By default, it uses “plain_template”, but you can specify other templates. Here is the list of available templates:\n\n\nplain_template (default): A minimal template for starting from scratch.\n\nquestion_types: A template showcasing all built-in question types.\n\nconditional_display: A template for the conditional display feature.\n\nconditional_navigation: A template for the conditional navigation feature.\n\nrandom_options: A template for creating randomized survey options.\n\nrandom_options_predefined: A template for creating predefined randomized survey options.\n\nreactive_questions: A template for creating reactive survey questions.\n\nreactive_drilldown: A reactive question template, with latter question options defined from former selection.\n\nexternal_redirect: A reactive question template with redirectional links, accepting URL parameters.\n\nlive_polling: A reactive question template of live-polling with responses shown as a bar chart.\n\nconjoint_buttons: A conjoint survey template with options shown in buttons.\n\nconjoint_tables: A conjoint survey template, with option contents shown in a table.\n\ncustom_leaflet_map: A template of custom leaflet map question using sd_question_custom().\n\ncustom_plotly_chart: A template of custom plotly chart question using sd_question_custom().",
    "crumbs": [
      "Documentation",
      "Survey Basics",
      "Getting Started"
    ]
  },
  {
    "objectID": "docs/getting-started.html#add-survey-content",
    "href": "docs/getting-started.html#add-survey-content",
    "title": "Getting Started",
    "section": "3. Add survey content",
    "text": "3. Add survey content\n\n\n\n\n\n\nNote\n\n\n\nWe recommend using keyboard shortcuts on RStudio to add survey content. Proceed to the surveydown Gadgets for Page and Question Creation blog post for a detailed walkthrough.\n\n\nSurvey content is edited in the survey.qmd file. See the survey.qmd section in Basic Components for details on the main components in a surveydown survey.\nHere’s a basic structure of pages and questions:\n\n\nAdd pages with fences, like this:\n\n::: {.sd_page id=page1}\n\nPage 1 content here\n\n:::\n\n\n\nAdd questions with the sd_question() function in code chunks (see the Question Types page for more on the types of questions supported). For example, here’s a multiple choice question:\n\n\nCode chunk\nOutput\n\n\n\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'penguins',\n  label = \"Which is your favorite type of penguin?\",\n  option = c(\n    'Adélie'    = 'adelie',\n    'Chinstrap' = 'chinstrap',\n    'Gentoo'    = 'gentoo'\n  )\n)\n```\n\n\n\n\n\n\n\nWhich is your favorite type of penguin?\n\n\n\n\nAdélie\n\n\n\n\nChinstrap\n\n\n\n\nGentoo\n\n\n\n\n*",
    "crumbs": [
      "Documentation",
      "Survey Basics",
      "Getting Started"
    ]
  },
  {
    "objectID": "docs/getting-started.html#add-control-options",
    "href": "docs/getting-started.html#add-control-options",
    "title": "Getting Started",
    "section": "4. Add control options",
    "text": "4. Add control options\nIn the server() function in the app.R file, add rich functionality to your survey using a variety of Server Options or Conditional Logic.",
    "crumbs": [
      "Documentation",
      "Survey Basics",
      "Getting Started"
    ]
  },
  {
    "objectID": "docs/getting-started.html#setup-your-database",
    "href": "docs/getting-started.html#setup-your-database",
    "title": "Getting Started",
    "section": "5. Setup your database",
    "text": "5. Setup your database\nIn the global settings at the top of the app.R file, setup your database with the sd_database() function. You can also leave it blank to preview / edit your survey without database connected, or set ignore = TRUE to run the survey without storing data. See the Storing Data page for more details.",
    "crumbs": [
      "Documentation",
      "Survey Basics",
      "Getting Started"
    ]
  },
  {
    "objectID": "docs/getting-started.html#locally-preview",
    "href": "docs/getting-started.html#locally-preview",
    "title": "Getting Started",
    "section": "6. Locally preview",
    "text": "6. Locally preview\nPreview your survey by clicking the “Run App” button in RStudio or in your R console running the runApp() command.",
    "crumbs": [
      "Documentation",
      "Survey Basics",
      "Getting Started"
    ]
  },
  {
    "objectID": "docs/getting-started.html#deploy",
    "href": "docs/getting-started.html#deploy",
    "title": "Getting Started",
    "section": "7. Deploy",
    "text": "7. Deploy\nDeploy your survey by hosting it on your favorite server, like shinyapps.io, HuggingFace, Posit Connect Cloud, Heroku, etc. See the Deployment page for more details.",
    "crumbs": [
      "Documentation",
      "Survey Basics",
      "Getting Started"
    ]
  },
  {
    "objectID": "docs/feature-highlights.html",
    "href": "docs/feature-highlights.html",
    "title": "Feature Highlights",
    "section": "",
    "text": "Supported Features\n\n\n\n\n    \n\n      \n\n\nFeature\nDocs\nVersion\nDiscussion\n\n\n\nWide variety of question types\nQuestion Types\nv0.0.1\n\n105, 109\n\n\n\nConditional logic capability\nConditional Display\nv0.0.1\n\n\n\nMarkdown formatting for options and buttons\nMarkdown Formatting\nv0.0.1\n\n\n\nRequire specific questions or all questions be answered\nRequired Questions\nv0.0.2\n\n\n\nSupport for bootstrap themes\nThemes\nv0.0.4\n\n\n\nCustomizable scss theme file\nThemes\nv0.0.4\n\n\n\nAbility to Ignore the database connection\nSupabase Ignore\nv0.0.8\n\n\n\nTime stamps recorded for each question and page interaction\n\nv0.0.9\n\n\n\nProgress bar that updates on each question interaction\nProgress Bar\nv0.0.9\n\n\n\nCustomizable progress bar color and position on page\nProgress Bar\nv0.0.9\n\n\n\nAbility to use latest survey results in the survey itself\nFetching Data\nv0.1.1\n\n\n\nPass parameters through the url e.g. to track user IDs\nReactive Redirect\nv0.2.2\n92\n\n\nRedirect users to an external url\nExternal Redirect\nv0.2.2\n\n\n\nStart the survey from a specific page (helpful when editing survey)\nStarting Page\nv0.3.0\n\n\n\nCreate a random numeric completion code\nCompletion Code\nv0.3.2\n\n\n\nAuto scroll according to the answering progress\nAuto Scroll\nv0.3.3\n104\n\n\nCustom languages / messages for system messages\nSystem Translations\nv0.4.2\n134\n\n\nStore session ID in browser cookies to store user progress if they refresh the page\nCookies\nv0.6.0\n\n\n\nCustom question type to enable custom html widgets\nCustom Questions\nv0.7.2\n111\n\n\nDashboard page with password login to preview / download data / pause survey, etc.\nDashboard\nv0.8.0\n\n\n\nFooter on every survey page\n\nv0.8.0\n\n\n\n\n\n\n\n\nTo Do / Roadmap\n\n\n\n\n    \n\n      \n\n\nFeature\nDocs\nVersion\nDiscussion\n\n\n\nForm validation (limit input based on question type, limit value range for numeric type)\n\n\n125\n\n\nQuestion type - Best worst\nBest-worst Discussion\n\n127\n\n\nQuestion type - Single checkbox with on and off toggle switches\nshinyWidgets - Single Checkbox\n\n\n\n\nQuestion type - Tree inputs\nshinyWidgets - Tree\n\n\n\n\nQuestion type of select menu - Dropdown select type with multiple selections\nshinyWidgets - Select Menu\n\n\n\n\nDefine questions using an external yml file\n\n\n132\n\n\n\nsd_store_data() function - store any values generated after survey launches in the db\n\n\n\n178\n\n\n\nsd_server(print_mode = TRUE) - Trigger the print feature\nRefer to {renderthis}\n\n\n\n\nClipboard problem - quarto-html-after-body div in quarto\n\n\n\n\n\nEnter key JS bug - not working if a conditional problem is shown\n\n\n\n\n\n\nskip_if() split into skip_forward() and skip_backward()\n\nIssue 169\n\n\n\n\nBug - cannot make matrix questions required\nIssue 170\n\n\n\n\nMake the gssencmode argument optional in sd_db_connect()\n\nIssue 174\n\n\n\n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Documentation",
      "Survey Basics",
      "Feature Highlights"
    ]
  },
  {
    "objectID": "docs/external-redirect.html",
    "href": "docs/external-redirect.html",
    "title": "External Redirect",
    "section": "",
    "text": "Like other operations, there are also two types of redirection: static and reactive. A static redirect provides a hard-coded URL, like google.com, apple.com, etc. A reactive redirect grabs parameters from your survey URL and allows you to use them to construct a new redirect URL.\nWe recommend you try out our demo survey that showcases both static and reactive redirects so that you can have a full understanding of how this works:",
    "crumbs": [
      "Documentation",
      "Interactivity",
      "External Redirect"
    ]
  },
  {
    "objectID": "docs/external-redirect.html#static-redirect",
    "href": "docs/external-redirect.html#static-redirect",
    "title": "External Redirect",
    "section": "Static Redirect",
    "text": "Static Redirect\nIn your survey body, use the sd_redirect() function and define your parameters. Below is an example of a redirect button that goes to google.com.\n\n\nCode chunk\nOutput\n\n\n\n\n# Static redirect\nsd_redirect(\n  id     = \"redirect\",\n  url    = \"https://www.google.com\",\n  label  = \"Redirect to Google\",\n  button = TRUE,\n  newtab = TRUE\n)\n\n\n\n\n\n\n\nRedirect to Google",
    "crumbs": [
      "Documentation",
      "Interactivity",
      "External Redirect"
    ]
  },
  {
    "objectID": "docs/external-redirect.html#reactive-redirect",
    "href": "docs/external-redirect.html#reactive-redirect",
    "title": "External Redirect",
    "section": "Reactive Redirect",
    "text": "Reactive Redirect\nReactive redirect is essentially useful if you deploy your survey on survey panels like Prolific or Dynata. These survey panels usually use different IDs to identify survey respondents.\nTo make reactive redirect work, you need to edit both in your server chunk, and your survey body. We’ll use an example to explain the process. This is the same example in our demo survey.\nFirstly, in your server chunk, define url_normal. It is an reactive expression in Shiny apps. You’ll use the sd_get_url_pars() function to retrieve all the parameters in your survey URL, and concatenate with customized texts including id names, status values, etc. In this example, we defined 3 IDs: id_a, id_b, and id_c, which should be grabbed from your survey link.\n\n# Reactive expression that generates a url for a normal ending\nurl_normal &lt;- reactive({\n  params &lt;- sd_get_url_pars()\n  id_a &lt;- params[\"id_a\"]\n  id_b &lt;- params[\"id_b\"]\n  id_c &lt;- params[\"id_c\"]\n  return(paste0(\n    \"https://www.google.com?id_a=\", id_a,\n    \"&id_b=\", id_b,\n    \"&id_c=\", id_c,\n    \"&status=0\" # status of 0 indicates normal ending\n})\n\nSecondly, also in your server chunk, create the redirect button using sd_redirect(). Note that we passed url_normal() value, with a pair of parentheses, to the url parameter.\n\n# Create the redirect button for normal ending\nsd_redirect(\n  id = \"redirect_normal\",\n  url = url_normal(),\n  button = TRUE,\n  label = \"Redirect with Normal Status\"\n)\n\n\n\n\n\n\n\nTip\n\n\n\nYou may have noticed that we created url_normal, and then passed url_normal() to sd_redirect(). This is how Shiny app deals with reactivity. Here url_normal is created by reactive() and is called “reactive expression”. url_normal() is a string value containing the concatenated URL. In other words, the url_normal() value is the result of the url_normal expression.\n\n\nFinally, in your survey body, output this redirect_normal URL using the sd_output() function:\n\n# Put this in the desired place of your survey body\nsd_output(\"redirect_normal\")\n\nAfter all these are done, your sd_output() function will generate a button that redirects you to this link:\n\nhttps://www.google.com/?id_a=a123id_b=b234id_c=c345&status=0\n\n\n\n\n\n\n\nTip\n\n\n\nCount-down delay (only applies for static redirect):\n\n# count-down of 10 seconds\nsd_redirect(\n  # previous parameters...\n  delay  = 10\n)\n\nOpen at a new tab (applies for both static and reactive):\n\nsd_redirect(\n  # previous parameters...\n  newtab  = TRUE\n)\n\nIf newtab is used together with delay, the new tab opened after count-down might be blocked by the browser. We’ve tested it with Safari and Edge. It worked fine on Safari, but Edge blocks it with a pop-up notice.",
    "crumbs": [
      "Documentation",
      "Interactivity",
      "External Redirect"
    ]
  },
  {
    "objectID": "docs/custom-questions.html",
    "href": "docs/custom-questions.html",
    "title": "Custom Questions",
    "section": "",
    "text": "If you have an html widget that isn’t yet directly supported by surveydown, you can still use it by defining it in the server and using the sd_question_custom() function to store the value in the resulting survey data.",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Custom Questions"
    ]
  },
  {
    "objectID": "docs/custom-questions.html#basic-syntax",
    "href": "docs/custom-questions.html#basic-syntax",
    "title": "Custom Questions",
    "section": "Basic Syntax",
    "text": "Basic Syntax\nUse the sd_question_custom() function to create custom questions. The function requires the following arguments:\n\n\nid: A unique identifier for the question, which will be used as the variable name in the resulting survey data (just like the id in sd_question()).\n\nlabel: The label that will be displayed on the question in the survey.\n\noutput: The output widget. This needs to be an output function designed for shiny, e.g. leafletOutput(), plotOutput(), etc.\n\nvalue: The value to be returned by the question. This must be a reactive value that updates based on user interaction with the output widget (e.g. selecting a state on a leaflet map).\n\nheight (optional): The height of the widget in pixels, defaults to 400.\n\nBelow is the basic syntax for creating a custom question:\nsd_question_custom(\n  id     = \"some_id\",\n  label  = \"Some Label\",\n  output = \"some_output_widget\",\n  value  = \"some_reactive_value\"\n)\nTo make sd_question_custom() work, you need to define the UI and functionality you want in the server() function in the app.R file. We have two examples that show how to set this up: an interactive map using leaflet, and an interactive plot using plotly.",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Custom Questions"
    ]
  },
  {
    "objectID": "docs/custom-questions.html#leaflet-map-example",
    "href": "docs/custom-questions.html#leaflet-map-example",
    "title": "Custom Questions",
    "section": "Leaflet Map Example",
    "text": "Leaflet Map Example\nTo reproduce this example, proceed to the Custom Leaflet Map template. This template has a leaflet map that looks like the map below. When a user clicks on the map, it turns orange and stores the selected state in the resulting survey response data:\n\nWhich state do you live in?",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Custom Questions"
    ]
  },
  {
    "objectID": "docs/custom-questions.html#plotly-chart-example",
    "href": "docs/custom-questions.html#plotly-chart-example",
    "title": "Custom Questions",
    "section": "Plotly Chart Example",
    "text": "Plotly Chart Example\nTo reproduce this example, proceed to the Custom Plotly Chart template. This template has a plotly scatterplot map that looks like the chart below. When a user clicks on one of the points, it displays the point value and stores the point in the resulting survey response data:\n\nClick on a point to select it:",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Custom Questions"
    ]
  },
  {
    "objectID": "docs/basic-components.html",
    "href": "docs/basic-components.html",
    "title": "Basic Components",
    "section": "",
    "text": "Every surveydown survey is composed of a survey and an app, defined in two separate files:\n\n\nsurvey.qmd: This file is for main survey content, such as pages, questions, and navigation buttons. It is a standard Quarto document, so you can use markdown editors (we recommend RStudio) to insert text, images, etc. just like you would in any Quarto document. See the survey.qmd section for details.\n\napp.R: This file is where you define the global settings (libraries, database configuration, etc.) and server logic (e.g., conditional page skipping / question display, etc.) for your survey. It defines a Shiny app, so if you are familiar with Shiny you should feel right at home. See the app.R section for details.\n\n\n\n\n\n\n\nNote\n\n\n\n\nYou do NOT need to render the survey.qmd file, and in fact we do not recommend doing so as the rendered output will not necessarily look like your final survey. Instead, to preview your survey you should locally run your survey.\nThe survey is triggerred by app.R. It launches a Shiny app, so if you are familiar with Shiny you should feel right at home.\nThese files must be named survey.qmd and app.R.\n\n\n\nThey typically look something like this:\n\n\nsurvey.qmd\napp.R\n\n\n\n\n---\nformat: html\necho: false\nwarning: false\n---\n\n```{r}\nlibrary(surveydown)\n```\n\n::: {.sd_page id=welcome}\n\n# Welcome to our survey!\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'penguins',\n  label = \"Which type of penguin do you like the best?\",\n  option = c(\n    'Adélie'    = 'adelie',\n    'Chinstrap' = 'chinstrap',\n    'Gentoo'    = 'gentoo'\n  )\n)\n\nsd_next()\n```\n\n:::\n\n::: {.sd_page id=end}\n\nThis is the last page of the survey.\n\n```{r}\nsd_close()\n```\n\n:::\n\n\n\n\nlibrary(surveydown)\n\n# Connects to database\ndb &lt;- sd_db_connect()\n\n# Main UI\nui &lt;- sd_ui()\n\nserver &lt;- function(input, output, session) {\n  # Main server\n  sd_server(db)\n}\n\nshiny::shinyApp(ui = ui, server = server)\n\n\n\n\nOther than the 2 files, there are also some important functions that you can call in the R console:\n\n\nsd_db_config(): Call this function to define your database credentials. The prompts will walk you through.\n\nsd_dashboard(): Call this function to summon the local survey dashboard (also a Shiny app). You can access survey statistics as well your database credentials. See Local Dashboard for more details.",
    "crumbs": [
      "Documentation",
      "Survey Basics",
      "Basic Components"
    ]
  },
  {
    "objectID": "docs/basic-components.html#overview",
    "href": "docs/basic-components.html#overview",
    "title": "Basic Components",
    "section": "",
    "text": "Every surveydown survey is composed of a survey and an app, defined in two separate files:\n\n\nsurvey.qmd: This file is for main survey content, such as pages, questions, and navigation buttons. It is a standard Quarto document, so you can use markdown editors (we recommend RStudio) to insert text, images, etc. just like you would in any Quarto document. See the survey.qmd section for details.\n\napp.R: This file is where you define the global settings (libraries, database configuration, etc.) and server logic (e.g., conditional page skipping / question display, etc.) for your survey. It defines a Shiny app, so if you are familiar with Shiny you should feel right at home. See the app.R section for details.\n\n\n\n\n\n\n\nNote\n\n\n\n\nYou do NOT need to render the survey.qmd file, and in fact we do not recommend doing so as the rendered output will not necessarily look like your final survey. Instead, to preview your survey you should locally run your survey.\nThe survey is triggerred by app.R. It launches a Shiny app, so if you are familiar with Shiny you should feel right at home.\nThese files must be named survey.qmd and app.R.\n\n\n\nThey typically look something like this:\n\n\nsurvey.qmd\napp.R\n\n\n\n\n---\nformat: html\necho: false\nwarning: false\n---\n\n```{r}\nlibrary(surveydown)\n```\n\n::: {.sd_page id=welcome}\n\n# Welcome to our survey!\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'penguins',\n  label = \"Which type of penguin do you like the best?\",\n  option = c(\n    'Adélie'    = 'adelie',\n    'Chinstrap' = 'chinstrap',\n    'Gentoo'    = 'gentoo'\n  )\n)\n\nsd_next()\n```\n\n:::\n\n::: {.sd_page id=end}\n\nThis is the last page of the survey.\n\n```{r}\nsd_close()\n```\n\n:::\n\n\n\n\nlibrary(surveydown)\n\n# Connects to database\ndb &lt;- sd_db_connect()\n\n# Main UI\nui &lt;- sd_ui()\n\nserver &lt;- function(input, output, session) {\n  # Main server\n  sd_server(db)\n}\n\nshiny::shinyApp(ui = ui, server = server)\n\n\n\n\nOther than the 2 files, there are also some important functions that you can call in the R console:\n\n\nsd_db_config(): Call this function to define your database credentials. The prompts will walk you through.\n\nsd_dashboard(): Call this function to summon the local survey dashboard (also a Shiny app). You can access survey statistics as well your database credentials. See Local Dashboard for more details.",
    "crumbs": [
      "Documentation",
      "Survey Basics",
      "Basic Components"
    ]
  },
  {
    "objectID": "docs/basic-components.html#architecture",
    "href": "docs/basic-components.html#architecture",
    "title": "Basic Components",
    "section": "Architecture",
    "text": "Architecture\nIf you are interested in what is happening under the hood, here is a flow diagram that illustrates the overall architecture of a typical surveydown survey application:\n\n\n\n\nFollowing this flow diagram, survey designers only need to edit survey.qmd and app.R. Since the survey is launched by app.R, which holds the core control logic of the survey, we’ve placed it at top left as starting point of the logic flows.\nIn app.R, we have three logic flows:\n\n\nsd_db_connect(), as colored in green, creates database connection.\n\nsd_ui(), in orange, serves two purposes: 1) it renders the survey.qmd file into survey content in the “_survey” folder, and re-renders if changes detected; 2) it initializes the user interface container for the survey app.\n\nsd_server(), in blue, also serves two purposes: 1) it grabs the generated “_survey” folder and serves processed page content to the survey app; 2) it updates database with responses.\n\nOn the right most part of the flow diagram, we reach to the ending point of the logic flow. The survey app is what is presented to the survey participants, and the data in PostgreSQL is a collection of survey results for survey analysts to study for. As this flow diagram illustrates, the surveydown platform is the one product that streamlines the experience of survey designers, survey participants, and survey analysts.",
    "crumbs": [
      "Documentation",
      "Survey Basics",
      "Basic Components"
    ]
  },
  {
    "objectID": "docs/basic-components.html#survey.qmd-1",
    "href": "docs/basic-components.html#survey.qmd-1",
    "title": "Basic Components",
    "section": "survey.qmd",
    "text": "survey.qmd\nYAML header\nThe YAML header is at the top of the survey.qmd file. It contains some basic settings, like this:\n---\nformat: html\necho: false\nwarning: false\n---\nThe format: html setting is optional since by default a Quarto doc is formatted as HTML. We put it here to explicitly state that this document should be rendered as an HTML document. The other settings, echo: false and warning: false, are recommended for a clean user experience, so that the survey does not display any code scripts or warnings to the participants.\nAppearance settings\nBecause the survey.qmd is a Quarto document, you can use any of the Quarto formatting options to change the appearance of your survey.\nFor example, you can change the overall survey theme using the theme key:\n---\ntheme: united # Any bootswatch theme \n---\nThere are 25 bootswatch themes to choose from. You can also provide a custom.scss file to further modify the theme, or even combine the two, e.g.:\n---\ntheme: [united, custom.scss]\n---\nProgress bar\nYou can modify the survey progress bar with the barcolor and barposition keys, e.g.:\n---\nbarcolor: \"#768692\"\nbarposition: top \n---\nThe barcolor key defines the color of the progress bar. It defaults to the primary theme color, but you can change it to any hex code you wish here to overwrite the theme color.\nThe barposition key defines the position of the progress bar. It defaults to top, but can also be changed to bottom or none (to remove the bar). The progress bar updates on every question the user clicks on, not pages.\nThe rest of the content in the survey.qmd file is the content you want in your survey, including pages, navigation buttons, and questions.\nAdding pages\n\n\n\n\n\n\nNote\n\n\n\nWe recommend using keyboard shortcuts on RStudio to add survey content. Proceed to the surveydown Gadgets for Page and Question Creation blog post for a detailed walkthrough.\n\n\nIn surveydown, pages are defined using fences (:::), like this:\n\n::: {.sd_page id=page1}\n\nPage 1 content here\n\n:::\n\n::: {.sd_page id=page2}\n\nPage 2 content here\n\n:::\n\nWe use three colon symbols :::, called a “fence”, to mark the start and end of pages. This notation is commonly used in Quarto for a variety of use cases, like defining subfigures in images.\nIn the starting fence, you need to define a page name (e.g. welcome and page2 in the example above) and you need to define the class as .sd_page. Then anything you put between the page fences will appear on that page.\nAdding navigation buttons\nTo navigate to the next page, you need to insert a sd_next() function call inside a code chunk, like this:\n\n```{r}\nsd_next()\n```\n\nThe above code chunk will create a “Next” button that goes on to the immediate next page. The button will look like this:\n\n\n\nNext\n\n\n\nYou can also send the user to other pages by just changing the value assigned to the next_page argument. For example, to send the user to a page with the id page3, you can use:\n\n```{r}\nsd_next(next_page = 'page3')\n```\n\nFinally, you can also change the label of the button by changing the label argument, like this:\n\n```{r}\nsd_next(label = 'Next page')\n```\n\n\n\n\nNext page\n\n\n\nWhile the sd_next() function controls basic, static page navigation, you can conditionally override these controls using the sd_skip_forward() function in your server function. See the Conditional Survey Flow page for more details.\nAdding questions\n\n\n\n\n\n\nNote\n\n\n\nWe recommend using keyboard shortcuts on RStudio to add survey content. Proceed to the surveydown Gadgets for Page and Question Creation blog post for a detailed walkthrough.\n\n\nEvery survey question is created using the sd_question() function inside a code chunk. The question type is defined by the type argument. For example, to add a multiple choice question, you could insert the following code chunk:\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'penguins',\n  label = \"Which is your favorite type of penguin?\",\n  option = c(\n    'Adélie'    = 'adelie',\n    'Chinstrap' = 'chinstrap',\n    'Gentoo'    = 'gentoo'\n  )\n)\n```\n\nThe above code chunk will create a multiple choice question that looks like this:\n\n\n\n\nWhich is your favorite type of penguin?\n\n\n\n\nAdélie\n\n\n\n\nChinstrap\n\n\n\n\nGentoo\n\n\n\n\n*\n\n\n\nThe sd_question() function can be used to create a variety of question types, like text input, select drop down choices, and more by changing the type argument (see the Questions Types page).\nThe function has many other arguments for customizing the look and feel of the question, such as the height and width (see the Question Formatting page).\nBy default all questions are optional, but you can make questions required in the server options (see the Server Options page for details).\nEnding the survey\nThe simplest way to end a survey is to create a page with no sd_next() button on it. This will effectively serve as a ending page, because the respondent will not be able to navigate anywhere else once reaching a page with no next button.\nFor example, you may want to have a screen-out page that respondents are sent to if they answer a certain way on a question (e.g., see Conditional Survey Flow. You can do this by creating a page with no sd_next() button on it, like this:\n\n::: {.sd_page id=screenout}\n\nSorry, you are not eligible for this survey.\n\nYou can close this window now.\n\n:::\n\nWhen a respondent reaches this page, they will not be able to navigate anywhere else, so the survey is over.\nYou can also add a button to end the survey programmatically using the sd_close() function inside a code chunk, like this:\n\n```{r}\nsd_close()\n```\n\nThis will create a button with the label “Exit Survey” that the respondent can click on to close the survey window. If you want to customize the label, use the label argument, like this:\n\n```{r}\nsd_close(label = 'Close Window')\n```\n\nThis button can be added anywhere in the survey, not necessarily on the last page - all it does is close the browser window.\nFinally, you can also add a button to end the survey and redirect the respondent to another page. You can do this using the sd_redirect() function, like this:\n\n\nCode chunk\nOutput\n\n\n\n\nsd_redirect(\n  id     = \"redirect\",\n  url    = \"https://www.google.com\",\n  label  = \"Redirect to Google\",\n  button = TRUE,\n  newtab = TRUE\n)\n\n\n\n\n\n\n\nRedirect to Google\n\n\n\n\n\n\n\nThis will create a button with the label “Redirect to Google” that the respondent can click on to be redirected to Google. You can also customize the url to include url parameters. See the External Redirect page for more details.",
    "crumbs": [
      "Documentation",
      "Survey Basics",
      "Basic Components"
    ]
  },
  {
    "objectID": "docs/basic-components.html#app.r-1",
    "href": "docs/basic-components.html#app.r-1",
    "title": "Basic Components",
    "section": "app.R",
    "text": "app.R\nThe main components of the app.R file are:\n\n\nGlobal settings: where you load the surveydown package and define the database connection.\n\nServer: where you define the logic of the survey (conditional question display / conditional survey flow, etc.)\n\nGlobal settings\nThe global settings are at the top of the app.R file. At a minimum, you need to load the surveydown package and define the database connection. You can also load other packages / global objects here if you need to. It typically looks like this:\n\nlibrary(surveydown)\n\n# sd_db_config()\ndb &lt;- sd_db_connect()\n\nThe db object is used to store survey data - see the Storing Data page for details on how to set up the database connection.\nServer\nThe server() function is a standard Shiny server function that takes input, output, and session as arguments. It is where you can set custom control logic and other configuration options, such as conditional question display logic with the sd_show_if() function, or conditional survey flow logic with the sd_skip_forward() function.\nIf you create a new survey using a template, the server() function looks like this:\n\nserver &lt;- function(input, output, session) {\n\n  # Define conditional skip logic (skip forward to page if a condition is TRUE)\n  sd_skip_forward()\n\n  # Define conditional display logic (show a question if a condition is TRUE)\n  sd_show_if()\n\n  # Main server to control the app\n  sd_server(db = db)\n\n}\n\nThe sd_server() function at the bottom makes everything run. It also includes some optional arguments that you can use to customize the survey.\nSee the Server Options page for details on the different options you can use to customize the server.\n\n\n\n\n\n\nNote\n\n\n\nThe db = db argument in sd_server() is required if you are using a database connection, which should be defined using the sd_database() function as mentioned above in the Global Settings section. See the Store Data page for more details.\n\n\nLaunch app\nAt the very bottom of the app.R file, you will see the following code:\n\nshiny::shinyApp(ui = sd_ui(), server = server)\n\nThis code defines the Shiny app and should always be at the bottom of the app.R file.\n\n\n\n\n\n\nNote\n\n\n\nWhat’s with the sd_ui() thing?\nIn a typical Shiny app, you have to define the UI and server functions separately. In a surveydown survey, the UI is a fixed structure that is defined by the sd_ui() function, so simply provide it to the ui argument in shiny::shinyApp() to run the survey.\n\n\nLocal run\nTo preview your survey, you can run the Shiny app locally by clicking the “Run App” button in RStudio or in your R console run the code shiny::runApp('app.R'). Typically, RStudio will launch the app in a new window, but you can also choose to have the app launch in a dedicated viewer pane, or in your external web browser. Make your selection by clicking the icon next to Run App:",
    "crumbs": [
      "Documentation",
      "Survey Basics",
      "Basic Components"
    ]
  },
  {
    "objectID": "blog/index.html",
    "href": "blog/index.html",
    "title": "Blog",
    "section": "",
    "text": "surveydown Gadgets for Page and Question Creation\n\n\n\n\n\nA brief walkthrough of surveydown gadgets for creating pages and questions using RStudio. \n\n\n\n\n\n2025-04-08\n\n\nJohn Paul Helveston, Pingfan Hu\n\n\n\n\n\n\n\n\n\n\n\n\nsurveydown is on CRAN 🎉!\n\n\n\n\n\nIt’s actually been on CRAN since v0.4.0, but we’ve been making so many updates that we’re now already on v0.7.2! \n\n\n\n\n\n2024-12-20\n\n\nJohn Paul Helveston\n\n\n\n\n\n\n\n\n\n\n\n\nNew architecture in v0.3.0 (and loads of breaking changes)!\n\n\n\n\n\nWe’re releasing v0.3.0, and with it multiple breaking changes. \n\n\n\n\n\n2024-09-18\n\n\nJohn Paul Helveston\n\n\n\n\n\n\n\n\n\n\n\n\nChoice-based conjoint surveys in R with surveydown\n\n\n\n\n\nA how-to guide for using R to design and implement choice-based conjoint surveys using the surveydown R package \n\n\n\n\n\n2024-08-28\n\n\nJohn Paul Helveston\n\n\n\n\n\n\n\n\n\n\n\n\nIntroducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny\n\n\n\n\n\nA quick overview of the {surveydown} R package for making markdown-based surveys with open-source technologies: Quarto, shiny, and supabase. \n\n\n\n\n\n2024-08-21\n\n\nJohn Paul Helveston\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "blog/2024-12-20-surveydown-on-cran/index.html",
    "href": "blog/2024-12-20-surveydown-on-cran/index.html",
    "title": "surveydown is on CRAN 🎉!",
    "section": "",
    "text": "We have some exciting news to share - surveydown is on CRAN 🎉!\nYou can now install surveydown from CRAN using the usual install.packages() function:\ninstall.packages(\"surveydown\")\nActually, surveydown has been on CRAN since v0.4.0, but we’ve been making so many updates that we’re now already on v0.7.2 before we could even make a post about being on CRAN!\nSo it seems about time we highlight some of the improvements and new features we’ve added recently."
  },
  {
    "objectID": "blog/2024-12-20-surveydown-on-cran/index.html#new-functions-features",
    "href": "blog/2024-12-20-surveydown-on-cran/index.html#new-functions-features",
    "title": "surveydown is on CRAN 🎉!",
    "section": "New functions / features",
    "text": "New functions / features\nWe added a whole bunch of new functions and features since v0.3.0, which was a major architectural change to the package. But the changes we made in v0.3.0 made it lot easier to support more features. There have been a lot, so I’m probably missing some, but here are some quick highlights that are worth calling out:\n\nIn sd_question(), we added a new type = \"matrix\" to support matrix type questions.\nWe added a new sd_is_answered() function to check if a question is answered or not. This is useful for conditional reactive questions defined in the server.\nWe added a new sd_completion_code() function that generates a random completion code for your survey.\nWe added a new sd_close() function to make a button that closes the survey.\n\nStefan Munnes added a translation feature that allows you to customize the system messages in the app to any language you want.\nWe modified how data handling is done so that each respondent’s state in the survey can be restored via cookies if they refresh the browser window or close and re-open the window. Before, respondents would be sent back to the start of the survey and a new entry in the database would be created, so this features allows respondents to pause and come back to the survey without that happening.\nWe added two new helper functions, sd_add_question() and sd_add_page(), that make it easier to quickly create template questions and pages. They work like this:"
  },
  {
    "objectID": "blog/2024-12-20-surveydown-on-cran/index.html#performance-improvements",
    "href": "blog/2024-12-20-surveydown-on-cran/index.html#performance-improvements",
    "title": "surveydown is on CRAN 🎉!",
    "section": "Performance improvements",
    "text": "Performance improvements\nOne major improvement we’ve made is to streamline how the survey.qmd file is updating. Before you needed to render the survey.qmd file yourself before running the app.R file, but now you actually never need to render it. All rendering is handled when you run the shiny app via the app.R file.\nAnd this rendering is “smart” too - it renders the survey.qmd file into an html file, then it parses that file for all of the content needed for the survey and stores each piece in a _survey folder. This folder is then what the shiny app uses to load the survey. If no changes are detected in the survey.qmd file or any of the components in the _survey folder, then the app will always load content from the pre-rendered content in the _survey folder, which will load nearly instantaneously! Only if you make a change to your survey will it be re-rendered, and again once that rendering is done once it won’t run again until another change is detected. This results in a much more efficient app that loads nearly instantaneously.\nWe also improved the database updating to be much more efficient. It used to run a write operation to the database on every single question ineraction, but that slowed down the app significantly. Now that we have cookies enabled, we do the immediate record keeping in the cookies and only write to the database when the respondent closes the survey or turns the page. This is a more reasonable compromise that makes the app feel snappy while still ensuring that the data is saved even if the respondent accidentally closes the window."
  },
  {
    "objectID": "blog/2024-12-20-surveydown-on-cran/index.html#our-first-community-contributions",
    "href": "blog/2024-12-20-surveydown-on-cran/index.html#our-first-community-contributions",
    "title": "surveydown is on CRAN 🎉!",
    "section": "Our first community contributions!",
    "text": "Our first community contributions!\nOver the past few months, we’ve been getting a lot of contributions from the community! We’ve been able to merge a few pull requests that add some new features and fix some bugs. Here are some of the highlights:\n\n\nStefan Munnes added a new translation feature that allows you to customize the system messages in the app to any language you want. He also helped us update sd_output() to be able to output the chosen question values, chosen question option label(s), and the question label itself. This addresses feature request #128.\n\nZain Hoda contributed a new auto_scroll parameter to the sd_server() function that allows you to turn off auto scrolling. This is useful if you have a lot of questions and want to make sure the respondent can see the entire question.\n\nWe’re excited to see what the community will build with surveydown! If you build something with surveydown, please let us know on the GitHub Discussions so we can highlight your work!"
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "",
    "text": "Important\n\n\n\nThis post was updated on 2024-09-23 to match the new architecture introduced in v0.3.0. See the blog post on the v0.3.0 release for more details.\nBecause surveydown surveys run as a shiny app, you can include custom logic in the background by writing some  code in your server. In this post, I’m going to show you one approach for using surveydown to create a particular type of complex survey: a choice-based conjoint survey.\nThe key component of a choice-based conjoint survey is asking repsondents to make choices from randomized sets of choice questions. So the hard part is figuring out a way to show each respondent a different set of randomized questions. This post shows how you can achieve this in surveydown.\nThroughout this post, I will use a demo survey about people’s preferences for apples with three attributes: type, price, and freshness.1\nYou can view the live demo survey here, and all files used to create the survey are on this GitHub repo."
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#introduction",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#introduction",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Introduction",
    "text": "Introduction\nIf you’ve never used surveydown before, take a look at the Getting Started page to get a quick introduction to the package and how to use it to make a survey.\nThe basic concept is this:\n\nDesign your survey as a Quarto document using markdown and R code.\nConvert your survey into a Shiny app that can be hosted online and sent to respondents.\nStore your survey responses in a Supabase database."
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#getting-started",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#getting-started",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Getting started",
    "text": "Getting started\nIf you want to start from a blank slate, take a look at the Getting Started documentation page.\nFor this post, we recommend starting from the demo survey available at this GitHub repo. It provides an already working survey that you can modify to the needs of your conjoint survey.\nThe demo repo has a lot of files in it, but the main files defining the survey itself are:\n\n\nsurvey.qmd: The main body of the survey.\n\napp.R: The app file containing the server logic implemented in the survey, including randomizing questions, connecting to a database, etc.\n\n\n\n\n\n\n\nNote\n\n\n\nWe recommend opening the survey.Rproj if you’re working in RStudio to make sure RStudio opens to the correct project folder."
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#content-in-the-survey-body",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#content-in-the-survey-body",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Content in the survey body",
    "text": "Content in the survey body\nAfter the setup code chunk where we load the surveydown package, we have a series of pages (defined with ::: fences) that include markdown-formatted text and survey questions (defined with sd_question()). You can modify any of this content as you wish to suit the needs of your survey.\nIn this demo, we have a few other examples included, like a conditionally displayed question (the fav_fruit question will not display if you choose “No” on the first question about liking fruit) as well as a question that skips people to the end (if you choose “blue” and not “red” on the screening page). The logic controlling the conditional display and skipping is defined with the sd_skip_if() function in the app.R file.\nNone of this is necessary for a conjoint survey, but often times these are features that you may want to include, such as screening people out of the survey if they don’t qualify to take it, so we include it for demonstration purposes."
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#defining-the-choice-questions",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#defining-the-choice-questions",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Defining the choice questions",
    "text": "Defining the choice questions\nThe central component of every conjoint survey is the set of randomized choice questions. To implement these in surveydown, we pre-define our choice questions in a design file that we later use in the survey to select randomized sets of choice questions to display each respondent.\nWe use the cbcTools package to create the pre-defined design file. The code to create the choice questions for this demo survey is in the make_choice_questions.R file in the demo repo. This code generates a data frame of randomized choice questions that we then save in the project directory as choice_questions.csv."
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#implementing-the-choice-questions",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#implementing-the-choice-questions",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Implementing the choice questions",
    "text": "Implementing the choice questions\nThe choice questions are implemented at the top of the server() function in the app.R file in the demo repo. This code does the following steps:\n1. Read in the design file\nPretty straightforward - this is one line to read in the choice_questions.csv design file that we saved in the project folder.\n\ndesign &lt;- readr::read_csv(\"choice_questions.csv\")\n\n2. Sample and store a random respondent ID\nSince we want each respondent to see a different set of choice questions, we randomly sample a respondent ID from the set of all respondent IDs in the design file. We also need to keep track of this and store it in our response data so that later we can know what each respondent was actually shown.\nSince this is a value that we generated in the server (and not a value from a survey question to a respondent), we have to manually add it to the survey response data using sd_store_value(). Here we modified the name so that in the resulting survey data the column name will be \"respID\".\n\n# Sample a random respondentID\nrespondentID &lt;- sample(design$respID, 1)\n\n# Store the respondentID\nsd_store_value(respondentID, \"respID\")\n\n3. Filter the design for the respondentID\nWe create a subset dataframe called df that stores only the rows for the randomly chosen respondent ID. We also append the \"images/\" string onto the values in the image column as this will create the relative path to the images in our survey, e.g. \"images/fuji.jpg\" (all the images we show are in the \"images\" folder in the repo).\n\n# Filter for the rows for the chosen respondentID\ndf &lt;- design %&gt;%\n  filter(respID == respondentID) %&gt;%\n  mutate(image = paste0(\"images/\", image))\n\n4. Define a function to create question options\nThis is the most complex component in the server logic. Here we created a function that takes a dataframe and returns a named vector defining the options to show in each choice question. In this case, we only have 3 options per choice question, so each time we call this function we will use a small dataframe that has just 3 rows defining the 3 choice alternatives in a single choice question.\nThe function does several things. First, it extracts three single-row data frames that store the values of each of the 3 alternatives (alt1, alt2, and alt3). It then creates an options vector that has just 3 values: \"option_1\", \"option_2\", and \"option_3\". Then we have to define the names of each of those options. Remember that the values in the options vector are what gets stored in our resulting survey data based on what the respondent chooses, but the names are what respondents see. So in the context of a choice survey like this, we need to embed all of the attributes and their levels in the names of the options vector.\nWe use the glue() function to easily inject the values stored in alt1, alt2, and alt3 into our labels. The glue() function is similar to paste() in that is just concatenates object values into a string, but it has an easier syntax to work with. Anything inside {} brackets is evaluated, and the resulting value is inserted into the string. So for example, the line glue(\"1 plus 1 equals {1+1}\") would produce the string \"1 plus 1 equals 2\".\nIn our case, we’re including some html code to insert an image of the apple type (&lt;img src='{alt1$image}' width=100&gt;), the apply type itself (**Type**: {alt1$type}), and the apple price (**Price**: $ {alt1$price} / lb).\nNotice also that we’re mixing markdown (e.g. **Option 1**) and html (e.g. &lt;br&gt;), which will all get rendered into proper html in the resulting shiny app. The full function looks like this:\n\n# Function to create the labels for a choice question\n# based on the values in df\n\nmake_cbc_options &lt;- function(df) {\n  alt1 &lt;- df |&gt; filter(altID == 1)\n  alt2 &lt;- df |&gt; filter(altID == 2)\n  alt3 &lt;- df |&gt; filter(altID == 3)\n\n  options &lt;- c(\"option_1\", \"option_2\", \"option_3\")\n\n  names(options) &lt;- c(\n    glue(\"\n      **Option 1**&lt;br&gt;\n      &lt;img src='{alt1$image}' width=100&gt;&lt;br&gt;\n      **Type**: {alt1$type}&lt;br&gt;\n      **Price**: $ {alt1$price} / lb\n    \"),\n    glue(\"\n      **Option 2**&lt;br&gt;\n      &lt;img src='{alt2$image}' width=100&gt;&lt;br&gt;\n      **Type**: {alt2$type}&lt;br&gt;\n      **Price**: $ {alt2$price} / lb\n    \"),\n    glue(\"\n      **Option 3**&lt;br&gt;\n      &lt;img src='{alt3$image}' width=100&gt;&lt;br&gt;\n      **Type**: {alt3$type}&lt;br&gt;\n      **Price**: $ {alt3$price} / lb\n    \")\n  )\n  return(options)\n}\n\n5. Create the options for each choice question\nOne of the benefits of making the function the way we did in the previous step is that we can now easily call it to generate the option vector for each of the 6 choice questions in df:\n\n# Create the options for each choice question\n\ncbc1_options &lt;- make_cbc_options(df |&gt; filter(qID == 1))\ncbc2_options &lt;- make_cbc_options(df |&gt; filter(qID == 2))\ncbc3_options &lt;- make_cbc_options(df |&gt; filter(qID == 3))\ncbc4_options &lt;- make_cbc_options(df |&gt; filter(qID == 4))\ncbc5_options &lt;- make_cbc_options(df |&gt; filter(qID == 5))\ncbc6_options &lt;- make_cbc_options(df |&gt; filter(qID == 6))\n\n6. Create each choice question (6 in total)\nFinally, we now have everything we need to generate each choice question. Here we’re using the mc_buttons question type so that the labels we generated will be displayed on a large button, which looks good both on a computer and phone. We give the question a unique id (e.g. cbc_q1), and a label, and then set the option to the corresponding option vector we defined above.\n\nsd_question(\n  type   = 'mc_buttons',\n  id     = 'cbc_q1',\n  label  = \"(1 of 6) If these were your only options, which would you choose?\",\n  option = cbc1_options\n)\n\n# ...and 5 more questions like this\n\nRemember that since the labels in the options are being dynamically generated on each new session (each respondent), they have to be created in the server, not in the main survey body. As a result, the sd_question() function must also be created in the server code (if you put this code in the main body, only one random set of choice options will be generated, and they’ll be the same for everyone).\nTo display each question in the survey body, we use sd_output(\"id\", type = \"question\"), changing id to each corresponding choice question we created. In the demo survey.qmd file, you’ll see that there are 6 choice questions displayed in the main survey body (each on their own page), and each of those 6 questions are defined in the server() function in the app.R file.\nWhen rendered, a choice question will look like this, with the values matching whatever alternative was chosen in the design file:\n\n\n\n\n(1 of 6) If these were your only options, which would you choose? *\n\n\n\n\n\nOption 1Type: HoneycrispPrice: $ 1 / lb\n\n\n\n\nOption 2Type: FujiPrice: $ 3 / lb\n\n\n\n\nOption 3Type: Red DeliciousPrice: $ 2.5 / lb\n\n\n\n\n\n\n\n\n\n\nAnd that’s it! You now have 6 randomized choice questions!"
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#preview-and-check",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#preview-and-check",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Preview and check",
    "text": "Preview and check\nThe rest of the server() function in the app.R file has the remaining components we need, like any conditional display or skip logic. This is all standard features of any surveydown survey, so we won’t cover them in detail here and instead direct you to the documentation for details.\nBut before you go live, it’s a good idea to do some quick testing. You can test your survey even without having it connected to a database by setting ignore = TRUE in the sd_database() function. Of course, you probably should also test it after connecting it to a database to ensure that responses are being properly stored.\nWhen testing, you might get an error - don’t panic! Read the terminal output carefully and debug. There’s a good chance you may have missed a bug somewhere in your server code. Look in your app.R file to see if you can spot the error."
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#getting-the-data",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#getting-the-data",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Getting the data",
    "text": "Getting the data\nOnce your survey is live and you start collecting responses, you can easily access your data with the sd_get_data() function. This is typically done in a separate R file, which might look something like this:\n\nlibrary(surveydown)\n\ndb &lt;- sd_database(\n  user   = 'postgres.axzkymswaxcasjdflkurrj',\n  host   = 'aws-0-us-east-1.pooler.supabase.com',\n  port   = 5678,\n  db_name = 'postgres',\n  table_name = 'my_table'\n)\n\ndata &lt;- sd_get_data(db)\n\nObviously your settings in sd_database() would need to match those of your Supabase database that you created for your survey.\nAnd that’s it! We hope this post was helpful, and do go check out the this GitHub repo to try out the demo yourself."
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#footnotes",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#footnotes",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Footnotes",
    "text": "Footnotes\n\nYes, people have actually done conjoint surveys on fruit before.↩︎"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "surveydown.org",
    "section": "",
    "text": "surveydown is a flexible, open-source platform for making surveys with , Quarto, Shiny, and PostgreSQL. Here’s how it works:\n\nDesign your survey as a Quarto document using markdown and R code.\nRender your survey into a Shiny app that can be hosted online and sent to respondents.\nStore survey response data in a PostgreSQL database. We recommend Supabase as a free, secure, and easy to use option.\n\nThe {surveydown} R package provides functions to bring this all together.\n\nWe recommend reading the Getting Started page to get a sense of how to use surveydown and perform your basic setups. The rest of the documentation covers more details on how to use surveydown.\n\nClick here to get started!"
  },
  {
    "objectID": "about.html#what-is-surveydown",
    "href": "about.html#what-is-surveydown",
    "title": "surveydown.org",
    "section": "",
    "text": "surveydown is a flexible, open-source platform for making surveys with , Quarto, Shiny, and PostgreSQL. Here’s how it works:\n\nDesign your survey as a Quarto document using markdown and R code.\nRender your survey into a Shiny app that can be hosted online and sent to respondents.\nStore survey response data in a PostgreSQL database. We recommend Supabase as a free, secure, and easy to use option.\n\nThe {surveydown} R package provides functions to bring this all together.\n\nWe recommend reading the Getting Started page to get a sense of how to use surveydown and perform your basic setups. The rest of the documentation covers more details on how to use surveydown.\n\nClick here to get started!"
  },
  {
    "objectID": "about.html#why-surveydown",
    "href": "about.html#why-surveydown",
    "title": "surveydown.org",
    "section": "Why surveydown?",
    "text": "Why surveydown?\nMost survey platforms (e.g., Google forms, Qualtrics, etc.) use graphic interfaces or spreadsheets to define survey content, making version control, collaboration, and reproducibility difficult or impossible. The surveydown package was designed to address these problems. As an open-source, markdown-based platform, all survey content is defined using plain text (markdown and R code) in two files:\n\nsurvey.qmd: A Quarto document that contains the survey content (pages, questions, etc).\napp.R: An R script defining a shiny app that contains global settings (libraries, database configuration, etc.) and server configuration options (e.g., conditional page skipping / conditional display, etc.).\n\nThis approach makes your survey easy to reproduce, share, and version control with common tools like Git. And since all survey data is stored in a PostgreSQL database, you have total control over where your survey data lives. We provide direct support for Supabase as a free, secure, and easy to use option.\nIn case you’re interested in the background behind the project, this blog post provides something of an origin story. Note that the design discussed in the post is now quite outdated with what ultimately became surveydown."
  },
  {
    "objectID": "about.html#authors",
    "href": "about.html#authors",
    "title": "surveydown.org",
    "section": "Authors",
    "text": "Authors\nThe surveydown project is led by professor John Paul Helveston at George Washington University and was originally developed in collaboration with his students Pingfan Hu and Bogdan Bunea.\nAs an open-source package, surveydown now has many more contributors who have added features and improved the project over time. See the Contributors’ Page for details.\n\n\n\n\n\n\nJohn Paul Helveston, Ph.D.\nJohn Paul Helveston is an Assistant Professor in the Department of Engineering Management and Systems Engineering at George Washington University. Professor Helveston is the core designer and developer, and maintainer of both the surveydown project and this documentation website.\n\n\n\n\n\n\n\nPingfan Hu\nPingfan Hu is a Ph.D. student in Systems Engineering at George Washington University, supervised by professor Helveston. Pingfan is mainly responsible for UI design, user interactions, and website maintenance.\n\n\n\n\n\n\n\nBogdan Bunea\nBogdan Bunea is an undergraduate student majoring in Systems Engineering and minoring in Computer Science at George Washington University. Bogdan is mainly responsible for database connection and data management."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html",
    "href": "blog/2024-08-21-introducing-surveydown/index.html",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "",
    "text": "This post introduces the {surveydown} R package, a new way to design surveys using markdown, R, Quarto, and shiny. The idea for this platform has been brewing for a while (see this blog post for more on the motivation for this project), but now the package is finally here!\nIn this post, I’m going to show you a quick overview of the {surveydown} R package for making markdown-based surveys as well as a little about why we built surveydown."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#open-source",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#open-source",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Open source",
    "text": "Open source\nsurveydown is built entirely with open-source technologies, making it transparent and customizable. Best of all, no expensive licenses! Just install and use it!"
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#own-your-data",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#own-your-data",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Own your data",
    "text": "Own your data\nWith surveydown, you retain full ownership and control of your survey data. The responses are stored in your own Supabase database, ensuring that you have complete access to the data. This is particularly important for researchers dealing with sensitive information or those who need to comply with specific data protection regulations. We’re still working on enabling you to use your own hosted database, which will provide even more flexibility."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#ease-of-editing",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#ease-of-editing",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Ease of editing",
    "text": "Ease of editing\nDesigning a survey in surveydown is a pretty straightforward process. The markdown-based approach allows for quick modifications and easy navigation through your survey. And since it’s built on Quarto, you can use all of the features of Quarto to make your survey look great, like changing the theme, adding custom CSS, etc. You can also easily preview your survey as you edit it, and even run your survey locally to test it out before you deploy it, either with a button click in RStudio or with a quarto serve command in the terminal."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#did-i-mention-you-can-run-r-code-in-your-survey",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#did-i-mention-you-can-run-r-code-in-your-survey",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Did I mention you can run R code in your survey?",
    "text": "Did I mention you can run R code in your survey?\nEvery surveydown survey uses R code chunks for questions. But you can also insert R code for all sorts of other things. For example, if you wanted to randomize the values shown in a question, you could write some R code for that. Want to insert a plot of something? Write a little ggplot code. You can also add interactive components to your surveys, such as showing a respondent how their responses compare to others in real time."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#easy-version-control-and-collaboration",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#easy-version-control-and-collaboration",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Easy version control and collaboration",
    "text": "Easy version control and collaboration\nBecause the entire survey is defined in a single plain text file, surveydown naturally integrates with version control systems like Git. This allows you to track changes over time, collaborate with team members, and maintain a clear history of your survey’s development."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#reproducible",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#reproducible",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Reproducible",
    "text": "Reproducible\nSurveydown promotes reproducible research by allowing you to define your entire survey in a single, self-contained plain text document. This has a ton of benefits:\n\nWant someone else to be able to reproduce your experiment? Just give them the .qmd file and any other files they need (e.g., images, data, etc.), and they can reproduce your survey on their own computer.\nWant to print out your survey for an appendix? Render the survey with all pages visible then print it to pdf.\nWant others to see your survey live? Just set the database into pause mode and your survey will function without recording any responses.\n\nReproducibility is something we had in mind from the start with this project, and we’ve tried to make it as easy as possible for your surveydown surveys to be fully reproducible."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#getting-started",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#getting-started",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Getting started",
    "text": "Getting started\nAfter getting everything installed, we recommend starting with a template survey project. To do so, run the following in the R console:\n\nsurveydown::sd_create_survey(\"path/to/folder\")\n\nThis will create a folder with the following files:\n\n\nexample.qmd: a template survey you should edit.\n\nexample.Rproj: An RStudio project file (helpful if you’re working in RStudio)\n\n_extensions: A folder with the surveydown Quarto extension needed to make everything work (don’t modify this).\n\nIf you have the example open in RStudio, you can click the “Run document” button, or in your terminal run quarto serve example.qmd. Either approach should render the example survey into a shiny app that you can preview in a browser. Don’t worry just yet about setting up your database or making the survey live - for now, we’re going to focus on designing the survey and running it locally to preview it. The example survey should look like this:"
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#adding-pages",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#adding-pages",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Adding pages",
    "text": "Adding pages\nIn surveydown, pages are delineated using “fences”, like this:\n\n::: {#welcome .sd-page}\n\nPage 1 content here\n\n:::\n\n::: {#page2 .sd-page}\n\nPage 2 content here\n\n:::\n\nAs you can see, we use three colon symbols :::, called a “fence”, to mark the start and end of pages. This notation is commonly used in Quarto for a variety of use cases, like defining subfigures in images.\nIn the starting fence, you need to define a page name (e.g. welcome and page2 in the example above) and you need to define the class as .sd-page. Then anything you put between the page fences will appear on that page.\nTo navigate to the next page, you need to insert a sd_next() function call inside a code chunk, like this:\n\n```{r}\nsd_next(next_page = 'page2')\n```\n\nThe above code chunk will create a “Next” button that goes on to page 2 that looks like this:\n\n\n\nNext\n\n\n\nYou would need to place the code chunk in between the ::: fences of the welcome page in order to have a “Next” button that goes on to page 2. You can also send the user to other pages by just changing the next_page argument. Finally, you can also change the label of the button by changing the label argument, like this:\n\n```{r}\nsd_next(next_page = 'page2', label = 'Next page')\n```\n\n\n\n\nNext page"
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#adding-questions",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#adding-questions",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Adding questions",
    "text": "Adding questions\nEvery survey question is created using the sd_question() function inside a code chunk. The question type is defined by the type argument. For example, to add a multiple choice question, you could insert the following code chunk:\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'penguins',\n  label = \"Which is your favorite type of penguin?\",\n  option = c(\n    'Adélie'    = 'adelie',\n    'Chinstrap' = 'chinstrap',\n    'Gentoo'    = 'gentoo'\n  )\n)\n```\n\nThe above code chunk will create a multiple choice question that looks like this:\n\n\n\n\nWhich is your favorite type of penguin?\n\n\n\n\nAdélie\n\n\n\n\nChinstrap\n\n\n\n\nGentoo\n\n\n\n\n*\n\n\n\n\nThe sd_question() function can be used to create a variety of question types, like text input, select drop down choices, and more by changing the type argument.\nThe function has many other arguments for customizing the look and feel of the question (e.g., height and width, etc.)."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#the-server-chunk",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#the-server-chunk",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "The server chunk",
    "text": "The server chunk\nAt the very bottom of the .qmd file is a special “server” code chunk (that’s the #| context: server bit) that defines the app server. This is where you can customize and control the survey flow logic as well as where you define the database that will store the survey response data. It looks like this:\n\n```{r}\n#| context: server\n\n# Define the database settings\ndb &lt;- sd_database()\n\n# Define the configuration settings\nconfig &lt;- sd_config()\n\n# The sd_server() function initiates your survey - don't change this\nsd_server(\n  input   = input,\n  session = session,\n  config  = config,\n  db      = db\n)\n```\n\nThe sd_database() function is where you set up your database. The sd_server() function makes everything run, which you can safely ignore - just don’t change it and all will be good!\nThe middle part (the sd_config() function) is where you can define custom control logic for the survey, such as conditional display (conditionally displaying a question based on responses to questions), or conditional skip (conditionally sending the respondent to a page based on responses to questions)."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#going-live",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#going-live",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Going live!",
    "text": "Going live!\nOnce you are happy with your survey, you can deploy it live to any server of your choice. Since it’s a shiny app, you can deploy it to shinyapps.io for free!"
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#conditional-display",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#conditional-display",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Conditional display",
    "text": "Conditional display\nLet’s say we had a fourth option for “other” in our multiple choice question about penguins. If the respondent chose it, you may want a second question to popup that allows them to specify the other penguin type. To implement this, you would need to define both questions, e.g.:\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'penguins',\n  label = \"Which is your favorite type of penguin?\",\n  option = c(\n    'Adélie'    = 'adelie',\n    'Chinstrap' = 'chinstrap',\n    'Gentoo'    = 'gentoo',\n    'Other'     = 'other'\n  )\n)\n\nsd_question(\n  type  = \"text\",\n  id    = \"penguins_other\",\n  label = \"Please specify the other penguin type:\"\n)\n```\n\nThen in the server code chunk, you could use the show_if argument to define that the penguins_other question would only be shown if the respondent chose the other option in the penguins question, like this:\n\nconfig &lt;- sd_config(\n  show_if = tibble::tribble(\n    ~question_id,  ~question_value, ~target,\n    \"penguins\",    \"other\",         \"penguins_other\"\n  )\n)\n\nThis will make the penguins_other question only appear if the respondent chose the other option in the penguins question, like this:\n\n\n\n\nHere we’re using the tibble::tribble() function to define a data frame with three columns:\n\n\nquestion_id: The id of the triggering question.\n\nquestion_value: The triggering value.\n\ntarget: The id of the target question to display.\n\nYou don’t have to use tibble::tribble(), and in fact if you have a lot of show_if conditions, then you could create a csv file with all of your conditions in it and read it in to set the show_if conditions (just make sure the header has the same three column names), e.g.:\n\nconfig &lt;- sd_config(\n  show_if = readr::read_csv('path/to/show_if_conditions.csv')\n  )\n)"
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#conditional-skip",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#conditional-skip",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Conditional skip",
    "text": "Conditional skip\nOften times you’ll want to screen people out of a survey based on responses to questions. For example, let’s say you only wanted to only include people who own a vehicle. On your first page (e.g., with page name welcome), you could screen out people who do not own a vehicle.\nFirst, define a question about their vehicle ownership, e.g.:\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'vehicle_ownership',\n  label = \"Do you own your vehicle?\",\n  option = c(\n    'Yes' = 'yes',\n    'No'  = 'no'\n  )\n)\n```\n\nThen in the server code chunk, you could use the skip_if argument in sd_config() to define the behavior of the next button on the welcome page, like this:\n\nconfig &lt;- sd_config(\n  skip_if = tibble::tribble(\n    ~question_id,        ~question_value, ~target,\n    \"vehicle_ownership\", \"no\",            \"screenout\"\n  )\n)\n\nThis sets up a condition where if the respondent chooses no on the vehicle_ownership question, they will be sent to a page named screenout. You could put such a page at the end of the survey, something like this:\n\n::: {#screenout .sd-page}\n\nSorry, but you are not qualified to take our survey.\n\n:::\n\nNotice that I don’t have a sd_next() on this screenout page. That is how you define an end point for the survey taker. If there’s no “Next” button, then they cannot navigate anywhere else, so the survey is over."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#required-responses",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#required-responses",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Required responses",
    "text": "Required responses\nBy default, no questions are required. However, you can make questions required by adding the question id to the required argument in sd_config(), like this:\n\nconfig &lt;- sd_config(\n  required_questions = c(\"vehicle_ownership\", \"penguins_other\")\n)\n\nThis will make the respondent unable to proceed until they have answered the required questions. It will also place a red asterisk (*) next to the question label to indicate that the question is required.\nYou can also make all questions required by setting all_questions_required = TRUE like this:\n\nconfig &lt;- sd_config(\n  all_questions_required = TRUE\n)"
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#reactivity",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#reactivity",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Reactivity",
    "text": "Reactivity\nOne other feature that is particularly powerful is the ability to use R code in your survey via Shiny’s reactive programming. This allows you to make your survey more interactive and to use the full power of R to create custom functionality.\nDemo 1: Displaying content based on previous responses\nLet’s say you wanted to create a survey that asked the respondent’s name, and then displayed a personalized message based on their name. You could do this by first asking their name:\n\nsd_question(\n  type  = \"text\",\n  id    = \"name\",\n  label = \"What is your name?\"\n)\n\nThen you can use the sd_display_value(\"name\") function to display the value of the name question in other parts of your survey. For example:\n\nWelcome, `r sd_display_value(\"name\")`!\n\nWhich would render as something like “Welcome, Dave!” (assuming the respondent entered “Dave” in the name question). This works because the sd_display_value() function is reactive, meaning it will update the display based on the respondent’s responses.\nDemo 2: Displaying randomized question labels\nLet’s say you wanted to show a series of questions, but you wanted to randomize the labels shown for each question. You could do this by first defining a list of labels, and then using the sd_question_reactive() function to create a question that will display a random label from the list.\nFor example, let’s ask the respondent to rate different car brands from a random set of brands. You could first pre-define the randomized sets of brands for each respondent and store it as a csv file, like this:\n\nbrands &lt;- c(\"Toyota\", \"Ford\", \"Chevrolet\", \"Honda\", \"Nissan\", \"Tesla\")\ndesign &lt;- data.frame(\n  respondent_id = rep(1:10, each = 3),\n  brand = unlist(lapply(1:10, function(x) sample(brands, 3, replace = FALSE)))\n)\nwrite_csv(design, \"design.csv\")\n\nThis would make a design file that looks like this:\n\n\n#&gt;   respondent_id     brand\n#&gt; 1             1     Honda\n#&gt; 2             1    Nissan\n#&gt; 3             1    Toyota\n#&gt; 4             2    Toyota\n#&gt; 5             2 Chevrolet\n#&gt; 6             2     Honda\n\n\nNote that this would not be done in your survey.qmd file - it’s just a one-time thing to create the design (probably stored in an R file).\nThen in your server code chunk, you could read in the design file and use it to randomize the labels for each question based on a randomly chosen respondent:\n\ndesign &lt;- read_csv(\"design.csv\")\nresp_id &lt;- sample(design$respondent_id, 1)\ndf_resp &lt;- design %&gt;% filter(respondent_id == resp_id)\n\noptions &lt;- c(1, 2, 3)\nnames(options) &lt;- df_resp$brand\n\nsd_question_reactive(\n  type  = \"mc\",\n  id    = \"brands\",\n  label = \"Which of these brands do you like best?\",\n  option = options\n)\n\nHere the sd_question_reactive() function is used because the labels depend on the randomly chosen respondent. This means the labels will be different for each respondent.\nSince this is a reactive question, this code must be placed inside the server code chunk, not where you want it to appear in the survey. To define where in the survey the question should appear, you use the sd_display_question() function with the id set to the same value as the id in the sd_question_reactive() function, like this:\n\nsd_display_question(id = \"brands\")\n\nNow the brands question will be displayed in the survey where you put this code chunk.\nNote that all question responses are automatically saved to the database, but if you wanted to store some other value (e.g. the randomly chosen respondent_id), you could do that with the sd_store_value() function, like this:\n\nsd_store_value(resp_id)"
  },
  {
    "objectID": "blog/2024-09-18-new-app-design/index.html",
    "href": "blog/2024-09-18-new-app-design/index.html",
    "title": "New architecture in v0.3.0 (and loads of breaking changes)!",
    "section": "",
    "text": "The surveydown package is only a couple months old, and thanks to many early users we learned about some design flaws that needed to be fixed. As a result, with the release of {surveydown} 0.3.0, the package has undergone a major overhaul to improve security, modularity, and extensibility.\nWe introduced several major breaking changes in this release, so we felt we should make a blog post to both explain why we felt these changes were needed as well as introduce the new architecture we have adopted."
  },
  {
    "objectID": "blog/2024-09-18-new-app-design/index.html#motivation",
    "href": "blog/2024-09-18-new-app-design/index.html#motivation",
    "title": "New architecture in v0.3.0 (and loads of breaking changes)!",
    "section": "Motivation",
    "text": "Motivation\nIn the original conception of surveydown, the entire survey was defined in a single Quarto shiny document that would render into a shiny app. While this was a rather parsimonious design, it also had some flaws that weren’t immediately apparent.\nPerhaps the largest issue was page security (see this issue). With Quarto shiny documents, the qmd file is first rendered into a static html page that is then used to define the elements of the user interface in the resulting shiny app. This meant that for us to introduce pages, we relied on a combination of JS and CSS to hide and show the page divs based on users clicking on next buttons. While this resulted in a nice user experience, under the hood the entire app was still just one big html page with all of the content available.\nThis design meant that anyone could still see the source code to any component of the survey they wanted. A user could simply right-click and open “Inspect” then manually change the CSS of a page div from style=\"display: none;\" to style=\"display: show;\" and boom - the “page” would appear!\nThis was obviously a major security issue as pages with things like completion codes or redirect buttons at the end could be easily shown without going through the whole survey. The only solution was an architectural overhaul that would only show the content on one page at a time."
  },
  {
    "objectID": "blog/2024-09-18-new-app-design/index.html#new-architecture",
    "href": "blog/2024-09-18-new-app-design/index.html#new-architecture",
    "title": "New architecture in v0.3.0 (and loads of breaking changes)!",
    "section": "New architecture",
    "text": "New architecture\nThe new architecture employs a two-file design composed of a survey and an app that renders to a traditional Shiny app:\n\n\nsurvey.qmd: A Quarto document that contains the survey content (pages, questions, etc), which renders to an HTML file.\n\napp.R: An R script defining a Shiny app that contains the global settings (libraries, database configuration, etc.) and server configuration options (e.g., conditional skipping / display, etc.).\n\nThese files must be named survey.qmd and app.R.\nThey typically look something like this:\n\n\nsurvey.qmd file\napp.R file\n\n\n\n\n---\nformat: html\necho: false\nwarning: false\n---\n\n```{r}\nlibrary(surveydown)\n```\n\n::: {#welcome .sd-page}\n\n# Welcome to our survey!\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'penguins',\n  label = \"Which type of penguin do you like the best?\",\n  option = c(\n    'Adélie'    = 'adelie',\n    'Chinstrap' = 'chinstrap',\n    'Gentoo'    = 'gentoo'\n  )\n)\n\nsd_next(next_page = 'end')\n```\n\n:::\n\n::: {#end .sd-page}\n\nThis it the last page in the survey\n\n:::\n\n\n\n\n\nlibrary(surveydown)\n\ndb &lt;- sd_database(\n  host   = \"\",\n  dbname = \"\",\n  port   = \"\",\n  user   = \"\",\n  table  = \"\",\n  ignore = TRUE\n)\n\nserver &lt;- function(input, output, session) {\n\n  # Define conditional skip logic here (skip to page if a condition is true)\n  sd_skip_if()\n\n  # Define  conditional display logic here (show a question if a condition is true)\n  sd_show_if()\n\n  # Main server to control the app\n  sd_server()\n}\n\nshiny::shinyApp(ui = sd_ui(), server = server)\n\n\n\n\nThis approach allows us to separate the survey content (in the survey.qmd file) from the survey logic (in the app.R file), which comes with a few benefits:\n\n\nSecurity: Since the rendered survey content is no longer directly embedded in the app as a single html page, it makes it much harder for users to tamper with the content. Only the content on one page at a time will be rendered by the server.\n\nClarity: With two files, it is now clearer where the survey content versus control logic should be defined. Before, all of the server logic was in a single server code chunk at the end of the survey.qmd file, which required the user to scroll up and down to edit the server logic versus the survey content. Now a user can have both files open in two tabs in an IDE and more easily edit the survey content and server content.\n\nSimplicity: The new design eliminates the need for a Quarto extension to render the survey. This allows us to ship all of the core functionality of surveydown as a single R package, which is installed globally on your system.\n\nThe updated documentation of the Survey Components page reflects this new design."
  },
  {
    "objectID": "blog/2024-09-18-new-app-design/index.html#new-page-architecture",
    "href": "blog/2024-09-18-new-app-design/index.html#new-page-architecture",
    "title": "New architecture in v0.3.0 (and loads of breaking changes)!",
    "section": "New page architecture",
    "text": "New page architecture\nThe motivation to secure the page content led to a totally new approach to designing the survey pages. Our new approach actually renders the survey.qmd into a static html page and then parses it into a list of page objects. Each page object is itself a list of elements, including the page ID, question IDs, etc., as well as the rendered html content for that page.\nThe sd_server() function then uses this list of page objects to display one page at a time via a shiny::renderUI() function into a single “main” output. This approach allowed us to control what content is being served, eliminating the ability of survey respondents to see anything other than the content on the current page.\nThis approach also gave us the opportunity to overhaul how pagination works in general. Previously, users had to add a sd_next(next_page = \"page_id\") button at the end of each page, making sure to specify the next page to go to. This was a bit annoying as most of the time you just want to go to the next page, so specifying it felt redundant. Now users can simply add sd_next() at the bottom of each page and the server will go to the next page by default. If you want to direct the respondent to a different page, then you specify the target page using sd_next(next_page = \"page_id\")."
  },
  {
    "objectID": "blog/2024-09-18-new-app-design/index.html#improved-conditional-show-and-skip-logic",
    "href": "blog/2024-09-18-new-app-design/index.html#improved-conditional-show-and-skip-logic",
    "title": "New architecture in v0.3.0 (and loads of breaking changes)!",
    "section": "Improved conditional show and skip logic",
    "text": "Improved conditional show and skip logic\nConditionally displaying questions or skipping to pages is a core logic that many surveys need. Our original approach was relatively clunky, so since we were already introducing many breaking designs, we figured we should overhaul the logic for conditional skipping and displaying.\nThe new approach uses just two functions: sd_skip_if() and sd_show_if(). These functions can be provided in the main server() function in the app.R file to define the conditions and targets for either conditional displaying a question or conditionally skipping to a page. The structure for each condition in these new functions is always as follows:\n\n&lt;condition&gt; ~ \"target_question_id\"\n\nAs an example, let’s say we want to show a question called \"penguins_other\" if the respondent chose the \"other\" option in a question called \"penguins\". We could do this with the following code in the app.R file:\n\nserver &lt;- function(input, output, session) {\n\n  sd_show_if(\n    input$penguins == \"other\" ~ \"penguins_other\"\n  )\n\n  sd_server(db = db)\n\n}\n\nYou can provide multiple conditions to the sd_show_if() function, each separated by a comma. The sd_skip_if() function works the same way, but it will skip to a target page instead of showing a target question. See the revised Configuration Options page for more details on the new changes."
  },
  {
    "objectID": "blog/2024-09-18-new-app-design/index.html#no-more-sd_config-function",
    "href": "blog/2024-09-18-new-app-design/index.html#no-more-sd_config-function",
    "title": "New architecture in v0.3.0 (and loads of breaking changes)!",
    "section": "No more sd_config() function",
    "text": "No more sd_config() function\nOne more small change we made is that the sd_config() function is no longer needed. Since we moved the conditional skip and show logic into their own functions, we took the remaining arguments that used to be provided to sd_config() and added them to the sd_server() function as options. You can now simply pass these arguments to the sd_server() function in the app.R file."
  },
  {
    "objectID": "blog/2024-09-18-new-app-design/index.html#our-apologies",
    "href": "blog/2024-09-18-new-app-design/index.html#our-apologies",
    "title": "New architecture in v0.3.0 (and loads of breaking changes)!",
    "section": "Our apologies",
    "text": "Our apologies\nThat’s about it for the changes with v0.3.0. We want to send our deepest apologies for anyone who has already begun a study using the orginal design. The most recent version prior to v0.3.0 was v0.2.4, so this is the version you should install if you want to stick with the old design.\nThat said, all development will now continue on this new design, so we strongly recommend updating to the new version and converting any existing surveys to the new design. The biggest change you’ll need to make is to move your server logic out of the survey.qmd file and into the app.R file. We’ve also updated all our demos to the new design, so you can refer to these for examples on how to convert your existing surveys."
  },
  {
    "objectID": "blog/2025-04-08-surveydown-gadgets/index.html",
    "href": "blog/2025-04-08-surveydown-gadgets/index.html",
    "title": "surveydown Gadgets for Page and Question Creation",
    "section": "",
    "text": "As of version 0.10.0, surveydown now has shiny gadgets to make it easier to insert pages and questions into your survey.qmd file. This post highlights how to use them in your survey building workflow."
  },
  {
    "objectID": "blog/2025-04-08-surveydown-gadgets/index.html#introduction",
    "href": "blog/2025-04-08-surveydown-gadgets/index.html#introduction",
    "title": "surveydown Gadgets for Page and Question Creation",
    "section": "1 Introduction",
    "text": "1 Introduction\nWhile surveydown works with various IDEs, the gadget features perform best in RStudio. These gadgets provide a user-friendly interface for creating survey elements without having to remember the exact syntax or function parameters.\nTwo primary gadgets are offered by surveydown:\n\nSurvey Page Gadget - Creates a new survey page\nSurvey Question Gadget - Creates a new survey question\n\nHere is a showcase of the Survey Page Gadget in RStudio:\n\n\n\n\n\nThe Survey Question Gadget:\n\n\n\n\n\nAs you can see, these gadgets simplify the process of adding survey components. This blog walks you through how to access and use these gadgets."
  },
  {
    "objectID": "blog/2025-04-08-surveydown-gadgets/index.html#accessing-the-gadgets",
    "href": "blog/2025-04-08-surveydown-gadgets/index.html#accessing-the-gadgets",
    "title": "surveydown Gadgets for Page and Question Creation",
    "section": "2 Accessing the Gadgets",
    "text": "2 Accessing the Gadgets\nThe gadgets are powered by the sd_page_gadget() and sd_question_gadget() functions, but you don’t need to call these functions directly.\nYou can access these gadgets in RStudio in two ways:\n\n2.1 Using the Addins Menu\n\nClick on the “Addins” dropdown menu in the RStudio toolbar\nType “surveydown” in the search box\nSelect either “Add Survey Page” or “Add Survey Question”\n\nBelow is a screenshot of the Addins menu with surveydown gadgets:\n\n\n\n\n\n\n\n2.2 Keyboard Shortcuts (Recommended)\nFor more efficient workflow, set up keyboard shortcuts:\n\nGo to Tools → Addins → Browse Addins…\n\n\n\n\n\n\n\nIn the Addins popup window, click on the “Keyboard shortcuts…” button on the bottom left corner.\n\n\n\n\n\n\n\nInput “survey” in the search box.\n\n\n\n\n\n\n\nAssign the following shortcuts:\n\nCtrl+Shift+P for the Survey Page Gadget\nCtrl+Shift+Q for the Survey Question Gadget\n\nOr if you have other preferences, feel free to customize them."
  },
  {
    "objectID": "blog/2025-04-08-surveydown-gadgets/index.html#using-the-gadgets",
    "href": "blog/2025-04-08-surveydown-gadgets/index.html#using-the-gadgets",
    "title": "surveydown Gadgets for Page and Question Creation",
    "section": "3 Using the Gadgets",
    "text": "3 Using the Gadgets\n\n3.1 Survey Page Gadget\n\n\n\n\n\nThe page gadget is straightforward:\n\nPress Ctrl+Shift+P (or use the Addins menu)\nEnter a Page ID (no spaces allowed)\nClick “Create Page” or press Enter\n\nThis will insert a properly formatted page block at your cursor position, including an R code chunk ready for adding questions.\n\n\n3.2 Survey Question Gadget\n\n\n\n\n\nThe question gadget offers more options:\n\nPress Ctrl+Shift+Q (or use the Addins menu)\nFill in the following:\n\nQuestion Type: Select from the dropdown (default is “Multiple Choice”)\nQuestion ID: Enter a unique identifier (no spaces)\nQuestion Label: Enter the actual question text\n\nR Chunk Option: Check this box if you need the question to be inserted within an R code chunk\nClick “Create Question” or press Enter\n\nNote that if you created the question inside an existing page’s R chunk, you don’t need to check the “R Chunk Option”. If you’re adding a question elsewhere and need it to be in an R chunk, check that box."
  },
  {
    "objectID": "blog/2025-04-08-surveydown-gadgets/index.html#example-workflow",
    "href": "blog/2025-04-08-surveydown-gadgets/index.html#example-workflow",
    "title": "surveydown Gadgets for Page and Question Creation",
    "section": "4 Example Workflow",
    "text": "4 Example Workflow\nHere’s how a typical workflow might look:\n\nCreate a new page:\n\nPress Ctrl+Shift+P\nKey in your Page ID\nPress Enter\n\nAdd a question:\n\nPress Ctrl+Shift+Q\nSelect your desired question type\nKey in your Question ID\nKey in your Question Label\nPress Enter\nModify your Question Options as needed\n\nAdd more questions as needed by repeating step 2.\n\nBy following these steps and using the gadgets, you’ll create well-structured surveys much faster than coding everything manually."
  },
  {
    "objectID": "docs.html",
    "href": "docs.html",
    "title": "surveydown.org",
    "section": "",
    "text": "Welcome to your first surveydown survey!\nWe recommend reading the Getting Started page to get a sense of how to use surveydown and perform your basic setups. The rest of the documentation covers more details on how to use surveydown.\n\nClick here to get started!\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Documentation"
    ]
  },
  {
    "objectID": "docs/conditional-logic.html",
    "href": "docs/conditional-logic.html",
    "title": "Conditional Logic",
    "section": "",
    "text": "This page talks about the sd_show_if() function for Conditional Display of Questions, and the sd_skip_forward() function for Conditional Navigation of Pages in surveydown, followed by examples of Common Conditions that you can use with these functions. These functions allow you to control the flow of your survey based on the respondent’s answers.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "Conditional Logic"
    ]
  },
  {
    "objectID": "docs/conditional-logic.html#conditional-display-of-questions",
    "href": "docs/conditional-logic.html#conditional-display-of-questions",
    "title": "Conditional Logic",
    "section": "Conditional Display of Questions",
    "text": "Conditional Display of Questions\nIt is often useful to have a question display based on some condition, such as the respondent choosing a particular value in a multiple choice question. This can be achieved by the sd_show_if() function.\nFor example, let’s say we have a choice question about people’s favorite penguin type, and the last option is “other”. If the respondent chose it, you may want a second question to display that allows them to specify the “other” penguin type, like this:\n\n\n\n\nTo implement this, you first need to define both the conditional question and the target question in the survey.qmd file, like this:\n\n```{r}\n# Conditional question\nsd_question(\n  type  = \"mc\",\n  id    = \"penguins\",\n  label = \"Which is your favorite type of penguin?\",\n  option = c(\n    \"Adélie\"    = \"adelie\",\n    \"Chinstrap\" = \"chinstrap\",\n    \"Gentoo\"    = \"gentoo\",\n    \"Other\"     = \"other\"\n  )\n)\n\n# Target question\nsd_question(\n  type  = \"text\",\n  id    = \"penguins_other\", \n  label = \"Please specify the other penguin type:\"\n)\n```\n\nThen in the server function in the app.R file, you can use the sd_show_if() function to define that the \"penguins_other\" question would only be shown if the respondent chose the \"other\" option in the \"penguins\" question, like this:\n\n\n\n\n\n\nNote\n\n\n\nThe input object is a Shiny object that stores each question id defined by sd_question() in your survey.qmd file, so whenever referring to a question in a condition, you must use the format input$question_id.\n\n\n\nserver &lt;- function(input, output, session) {\n\n  sd_show_if(\n    input$penguins == \"other\" ~ \"penguins_other\" \n  )\n\n  sd_server(db = db)\n\n}\n\nThe structure of the condition in the sd_show_if() function is always:\n\n&lt;condition&gt; ~ \"target_question_id\"\n\nYou can provide multiple conditions to the sd_show_if() function, each separated by a comma.\nIn the example above, input$penguins == \"other\" is the condition, and \"penguins_other\" is the target question that will be shown if the condition is met. The ~ symbol is used to separate the condition from the target question.\nTake a look at the Common Conditions section for examples of other types of supported conditions you can use to conditionally display questions.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "Conditional Logic"
    ]
  },
  {
    "objectID": "docs/conditional-logic.html#conditional-navigation-of-pages",
    "href": "docs/conditional-logic.html#conditional-navigation-of-pages",
    "title": "Conditional Logic",
    "section": "Conditional Navigation of Pages",
    "text": "Conditional Navigation of Pages\nBasic page navigation is handled using the sd_next() function in your survey file. But you can override this static navigation in your server function with the sd_skip_forward() function.\nFor example, often times you’ll want to send respondents to different parts of the survey based on some condition, such as the respondent choosing a particular value in a multiple choice question. A common example is the need to screen out people based on their response(s) to a question.\nHere’s a concrete example. Let’s say you need to screen out people who do not own a vehicle. To do this, you would first define a question in your survey.qmd file about their vehicle ownership, e.g.:\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'vehicle_ownership',\n  label = \"Do you own your vehicle?\",\n  option = c(\n    'Yes' = 'yes',\n    'No'  = 'no'\n  )\n)\n```\n\nYou would also need to define a screenout page to send respondents to, like this:\n\n::: {#screenout .sd-page}\n\nSorry, but you are not qualified to take our survey.\n\n:::\n\nThen in the server function in the app.R file, you can use the sd_skip_forward() function to define the condition under which the respondent will be sent to the target screenout page, like this:\n\n\n\n\n\n\nNote\n\n\n\nAgain, the input object is a Shiny object that stores each question id defined by sd_question() in your survey.qmd file, so whenever referring to a question in a condition, you must use the format input$question_id.\n\n\n\nserver &lt;- function(input, output, session) {\n\n  sd_skip_forward(\n    input$vehicle_ownership == \"no\" ~ \"screenout\"\n  )\n\n  sd_server(db = db)\n\n}\n\nJust like the sd_show_if() function, you can provide multiple conditions to the sd_skip_forward() function, each separated by a comma. The structure for each condition in sd_skip_forward sd_skip_forward() function is always:\n\n&lt;condition&gt; ~ \"target_page_id\"\n\nIn the example above, input$vehicle_ownership == \"no\" is the condition, and \"screenout\" is the target page that the respondent will be sent to if the condition is met.\nTake a look at the Common Conditions section for examples of other types of supported conditions you can use to conditionally control the survey flow.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "Conditional Logic"
    ]
  },
  {
    "objectID": "docs/conditional-logic.html#common-conditions",
    "href": "docs/conditional-logic.html#common-conditions",
    "title": "Conditional Logic",
    "section": "Common Conditions",
    "text": "Common Conditions\nThis section highlights some of the most common types of conditions you might need.\n\n\n\n\n\n\nNote\n\n\n\nWhile we use the sd_show_if() function in most of these examples, the same logic applies to conditions used in the sd_skip_forward() function.\n\n\nQuestion responses\nOne of the most common situations is conditioning on the response of a single question or multiple questions, like this:\n\nsd_show_if(\n\n # Simple condition based on single question choice\n input$penguins1 == \"other\" ~ \"penguins1_other\",\n\n # Multiple condition based on multiple question choices\n input$penguins2 == \"other\" & input$show_other == \"show\" ~ \"penguins2_other\"\n\n)\n\nIn the first condition, the penguins1 question is checked to see if the respondent chose the \"other\" option. If they did, the penguins1_other question will be shown.\nIn the second condition, the penguins2 question is checked to see if the respondent chose the \"other\" option, and the show_other question is checked to see if the respondent chose the \"show\" option. With this condition, the penguins2_other question will only be shown if both conditions are TRUE.\nNumeric values\nAnother common condition is checking the value of a numeric question. To do so, you need to wrap the input$question_id in the as.numeric() function because all question values are stored as strings, like this:\n\nsd_show_if(\n as.numeric(input$car_number) &gt; 1 ~ \"car_ownership\"\n)\n\nIn the condition above, the car_number question is checked to see if the respondent chose a number greater than 1. If they did, the car_ownership question will be shown.\nMultiple response questions\nFor multiple response question types (e.g. mc_multiple), the question returns a vector storing all the chosen values. You can use this vector to check for different conditions, such as whether the chosen values are in some set of values using the %in% operator, or whether the respondent chose a number of options using the length() function, like this:\n\nsd_show_if(\n\n # Check if the respondent chose \"apple\", \"banana\", or both\n all(input$fav_fruits %in% c(\"apple\", \"banana\")) ~ \"apple_or_banana\",\n\n # Check if the respondent chose more than 3 fruits\n length(input$fav_fruits) &gt; 3 ~ \"fruit_number\"\n\n)\n\nIn the first example, the fav_fruits question is checked to see if the respondent chose \"apple\", \"banana\", or both; if so, the apple_or_banana question will be shown.\nIn the second example, the fav_fruits question is checked to see if the respondent chose more than 3 fruits; if so, the fruit_number question will be shown.\nAnswering status\nYou may want to show a target question if a question is answered at all or not. To do this, we created the sd_is_answered() function that returns TRUE if a question is answered and FALSE otherwise.\nFor example, let’s say you had a multiple choice question fav_fruit that asked you to choose your favorite fruit from a list of options, and a target question num_fruit that asked how many fruit you eat per day. If we wanted to show the num_fruit question so long as the fav_fruit question is answered, we can use sd_is_answered(\"fav_fruit\") in the sd_show_if() function, like this:\n\nsd_show_if(\n  sd_is_answered(\"fav_fruit\") ~ \"num_fruit\" \n)\n\nThis way, as long as the fav_fruit question is answered, no matter which option the user picks the num_fruit question will appear.\nFor \"matrix\" type questions, sd_is_answered() will only be TRUE if all sub-questions (matrix rows) in it are answered.\nCustom functions\nFor situations where the conditional logic is more complex, we recommend defining a custom function that will return a logical value (TRUE or FALSE). You can then pass this function to the sd_show_if() or sd_skip_forward() functions as a condition.\nFor example, let’s say we had a mc type question where we asked how many cars the respondent owned, and we included numeric options 1 through 5 as well as a final option \"6 or more\". If we wanted to set a condition that would return TRUE if the user had more than one car, using as.numeric(input$question_id) &gt; 1 as the condition would be problematic, because this would return NA if the respondent chose the \"6 or more\" option.\nTo address this, we could create a custom function to handle this special condition:\n\nserver &lt;- function(input, output, session) {\n\n  more_than_one_car &lt;- function(input) {\n    if (is.null(input$car_number)) {\n      return(FALSE)\n    }\n    num_cars &lt;- suppressWarnings(as.numeric(input$car_number))\n    if (is.na(num_cars)) {\n      return(TRUE)\n    }\n    return(num_cars &gt; 1)\n  }\n\n  sd_show_if(\n    more_than_one_car(input) ~ \"car_ownership\"\n  )\n\n  sd_server(db = db)\n\n}\n\nIn the more_than_one_car() function, we first return FALSE if the question is not yet answered (that’s the if (is.null(input$car_number)) part). Then we obtain the numeric value of the car_number question using as.numeric(input$car_number). We included a suppressWarnings() call here only because R will warn you if the result is NA by coercion. This will only happen if the respondent chose the \"6 or more\" option, in which case we return TRUE. If not, then we return the simple condition num_cars &gt; 1 since we can safely know that the value of num_cars is a number.\nCustom values\nSometimes you’ll want to condition on values that aren’t directly related to question responses. For example, you might want to randomly assign respondents to different survey versions or experimental conditions.\nLet’s say you have two versions of a page, e.g. page2a and page2b, and you want half of your respondents to see page 2a and the other half to see page 2b. You can accomplish this by:\n\nGenerating a random condition value\nStoring that value for later use\nUsing sd_skip_forward() to direct respondents to the appropriate page\n\nHere’s how to implement this:\n\nserver &lt;- function(input, output, session) {\n  \n  # Generate random condition\n  a_or_b &lt;- sample(c('a', 'b'), 1)\n  \n  # Store the condition value for later use if needed\n  sd_store_value(a_or_b)\n  \n  # Use sd_skip_forward to direct to either page2a or page2b based on condition\n  sd_skip_forward(\n    a_or_b == 'a' ~ 'page2a',\n    a_or_b == 'b' ~ 'page2b'\n  )\n  \n  sd_server()\n  \n}\n\nIn this example, sample(c('a', 'b'), 1) randomly selects either 'a' or 'b'. The sd_store_value() function saves this value to the database, making it available for later analysis. Then, sd_skip_forward() uses this value to determine which page version the respondent should see.\nThis approach can be also be used for sd_show_if(). For example, here is how you could randomly assign a question to be hidden or shown:\n\nserver &lt;- function(input, output, session) {\n  # Create a static value to control question visibility\n  show_condition &lt;- sample(c(TRUE, FALSE), 1)\n\n  # Store the static value for display in the UI\n  sd_store_value(show_condition, \"show_condition\")\n\n  # Show the conditional question based on the static value\n  sd_show_if(\n    show_condition ~ \"conditional_question\"\n  )\n\n  sd_server()\n}\n\nReactive expressions\nThe same behavior as the above example for custom values can also be achieved using reactive expressions, using the sd_reactive() function. In this example, we define a reactive expressions, a_or_b, and then use it to control the conditional navigation.\nNote here that the conditions must be defined using a_or_b() instead of a_or_b - this is because in this example this object is a reactive expression rather than a static value and must be evaluated like a function call.\nNote also that we don’t have to explicitly store the value in our data with a call to sd_store_value(). This is because the sd_reactive() function automatically stores the value in the data and will save it according to the specified id (in this case, \"a_or_b\").\n\nserver &lt;- function(input, output, session) {\n\n  a_or_b &lt;- sd_reactive(\"a_or_b\", {\n    sample(c('a', 'b'), 1)\n  })\n\n  # Use sd_skip_forward to direct to either page2a or page2b based on condition\n  sd_skip_forward(\n    a_or_b() == 'a' ~ 'page2a',\n    a_or_b() == 'b' ~ 'page2b'\n  )\n\n  sd_server()\n\n}\n\nshiny::shinyApp(ui = sd_ui(), server = server)\n\nLikewise, the same concept can be applied to conditionally displaying a question based on a reactive expression:\n\nserver &lt;- function(input, output, session) {\n\n  # Create a reactive value that will control question visibility\n  show_condition &lt;- sd_reactive(\"show_condition\", {\n    sample(c(TRUE, FALSE), 1) # Randomly choose TRUE or FALSE\n  })\n\n  # Show the conditional question based on the reactive value\n  sd_show_if(\n    show_condition() ~ \"conditional_question\"\n  )\n\n  sd_server()\n}",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "Conditional Logic"
    ]
  },
  {
    "objectID": "docs/deployment.html",
    "href": "docs/deployment.html",
    "title": "Deploying Your Survey",
    "section": "",
    "text": "Before deploying your survey, make sure everything is working locally. You should have done the following:\n\nYou have locally previewed your app.R file by clicking the “Run App” button in RStudio or in your R console running the code shiny::runApp('app.R').\nYou have set up a database connection to store survey responses (e.g. using Supabase) and have already stored the database credentials using the sd_db_config() function (see the Storing Data page for details).\n\nWith these steps completed, you are ready to deploy your survey online.",
    "crumbs": [
      "Documentation",
      "Deployment & Operations",
      "Deployment"
    ]
  },
  {
    "objectID": "docs/deployment.html#preparing-to-deploy",
    "href": "docs/deployment.html#preparing-to-deploy",
    "title": "Deploying Your Survey",
    "section": "",
    "text": "Before deploying your survey, make sure everything is working locally. You should have done the following:\n\nYou have locally previewed your app.R file by clicking the “Run App” button in RStudio or in your R console running the code shiny::runApp('app.R').\nYou have set up a database connection to store survey responses (e.g. using Supabase) and have already stored the database credentials using the sd_db_config() function (see the Storing Data page for details).\n\nWith these steps completed, you are ready to deploy your survey online.",
    "crumbs": [
      "Documentation",
      "Deployment & Operations",
      "Deployment"
    ]
  },
  {
    "objectID": "docs/deployment.html#deploying-to-shinyapps.io",
    "href": "docs/deployment.html#deploying-to-shinyapps.io",
    "title": "Deploying Your Survey",
    "section": "Deploying to shinyapps.io",
    "text": "Deploying to shinyapps.io\nDeploying your survey is pretty much the same as deploying any other Shiny app. We recommend using shinyapps.io to host your survey as it is designed to work with Shiny Apps, but you can also use other hosting services.\n\n\n\n\n\n\nNote\n\n\n\nYou may have deployed other Quarto documents on Quarto Pub before, but this site is only for static websites, so you SHOULD NOT use Quarto Pub for your survey deployment.\n\n\nTo start using shinyapps.io, you’ll need to create an account and follow the basic instructions to set up your sub-domain and authorize your IDE. See more information here.\nOnce you have your account and sub-domain ready, make sure you have the rsconnect package installed. You should have done this while authorizing your IDE, but in case you didn’t, you can install it with:\n\ninstall.packages('rsconnect')\n\nThen to deploy your survey, run:\n\n# Define your app name with the appName parameter\nrsconnect::deployApp(appName = \"my_survey\")\n\nThat’s it! Now you should have your survey site deployed on shinyapps.io. Congratulations! 🎉",
    "crumbs": [
      "Documentation",
      "Deployment & Operations",
      "Deployment"
    ]
  },
  {
    "objectID": "docs/deployment.html#deploying-to-other-hosting-services",
    "href": "docs/deployment.html#deploying-to-other-hosting-services",
    "title": "Deploying Your Survey",
    "section": "Deploying to Other Hosting Services",
    "text": "Deploying to Other Hosting Services\nYou can deploy shiny apps to other hosting services. Here are some guides for several other alternatives:\n\nPosit Connect Cloud\nHugging Face\nHeroku\n\nYou can also install Posit Connect on your own server, which is the recommended approach for remaining compliant with any security protocols your organization requires.",
    "crumbs": [
      "Documentation",
      "Deployment & Operations",
      "Deployment"
    ]
  },
  {
    "objectID": "docs/external-resources.html",
    "href": "docs/external-resources.html",
    "title": "External Resources",
    "section": "",
    "text": "Often times you will want to include external resources in your survey, things like images, videos, etc. While you can easily include these in your survey.qmd file by referencing their location in your survey project folder, these resources may not always be available in the shiny app defined in your app.R file.\nTo address this, you should always place external resources in a separate folder and then make sure that folder is added to Shiny’s resource path. You can do this in your app.R file by using the sd_include_folder() function at the beginning of the file after loading the surveydown package, like this:\nlibrary(surveydown)\n\nsd_include_folder(\"resources\")\nThis will make all files in a folder called resources available to Shiny.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "External Resources"
    ]
  },
  {
    "objectID": "docs/external-resources.html#default-folders",
    "href": "docs/external-resources.html#default-folders",
    "title": "External Resources",
    "section": "Default folders",
    "text": "Default folders\nThe surveydown package will automatically add the following folders to Shiny’s resource path:\n\nwww\nimages\ncss\njs\n\nIf any of these folders exist in your project, they will automatically be added to Shiny’s resource path. For this reason, we recommend that you always put images inside a images folder in your project directory, css files inside a css folder, and so on. This will make it easier to manage your resources and ensure that they are always available to Shiny.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "External Resources"
    ]
  },
  {
    "objectID": "docs/fetching-data.html",
    "href": "docs/fetching-data.html",
    "title": "Fetching Data",
    "section": "",
    "text": "Once you have your database properly set up and your survey is live, you can fetch the data using the sd_get_data() function.\nTo do so, you have to first create a database connection using the sd_db_connect() function:\n\ndb &lt;- sd_db_connect()\n\nOnce you have created a successful database connection, you need to use the connection to fetch the data, like this:\n\ndata &lt;- sd_get_data(db)\n\nHere the data object will be a data.frame with the data from your database table.",
    "crumbs": [
      "Documentation",
      "Data Management",
      "Fetching Data"
    ]
  },
  {
    "objectID": "docs/fetching-data.html#static-fetching",
    "href": "docs/fetching-data.html#static-fetching",
    "title": "Fetching Data",
    "section": "",
    "text": "Once you have your database properly set up and your survey is live, you can fetch the data using the sd_get_data() function.\nTo do so, you have to first create a database connection using the sd_db_connect() function:\n\ndb &lt;- sd_db_connect()\n\nOnce you have created a successful database connection, you need to use the connection to fetch the data, like this:\n\ndata &lt;- sd_get_data(db)\n\nHere the data object will be a data.frame with the data from your database table.",
    "crumbs": [
      "Documentation",
      "Data Management",
      "Fetching Data"
    ]
  },
  {
    "objectID": "docs/fetching-data.html#reactive-fetching",
    "href": "docs/fetching-data.html#reactive-fetching",
    "title": "Fetching Data",
    "section": "Reactive Fetching",
    "text": "Reactive Fetching\n\n\n\n\n\n\nTip\n\n\n\nRun the Demo survey of a reactive plot for an example of reactively fetching data.\n\n\nThe above example is intended for an analysis context, where all you want to do is fetch the latest data from your database. However, you may also want to fetch the data in a reactive context (i.e. in your survey). For example, perhaps you want to show respondents a bar chart of the most common responses to a question. The sd_get_data() function is compatible with reactive fetching as well - just call it inside the server() function in your app.R file:\n\nserver &lt;- function(input, output, session) {\n\n  data &lt;- sd_get_data(db)\n\n  sd_server()\n\n}\n\nNow the data object will be a reactive expression, not a data.frame. To use it, you have to call it with () to get the latest data as a data.frame. For example:\n\nserver &lt;- function(input, output, session) {\n\n  data &lt;- sd_get_data(db, refresh_interval = 5)\n\n  output$my_plot &lt;- renderPlot({  \n    my_data &lt;- data()\n    # insert code here to make a plot with my_data\n  })\n\n  sd_server()\n\n}\n\nHere the my_data object will be a data.frame with the latest data from your database, refreshed every 5 sections according to the refresh_interval parameter (5 seconds is the default value), which you could then use to make a plot.\nIn this example, the output$my_plot object will be a plot, which you can then display in your survey by placing plotOutput(\"my_plot\") in a code chunk somewhere in your survey.qmd file.\nSee the Reactivity page for more information on how to use reactivity in your survey.",
    "crumbs": [
      "Documentation",
      "Data Management",
      "Fetching Data"
    ]
  },
  {
    "objectID": "docs/local-dashboard.html",
    "href": "docs/local-dashboard.html",
    "title": "Local Dashboard",
    "section": "",
    "text": "The surveydown package has a dashboard app for viewing and modifying your database credentials as well as viewing your survey data. To launch the dashboard, run the following in your R console:\nsurveydown::sd_dashboard()\nThis will open a new browser window where you can navigate to the dashboard for your project. It has two tabs: “Dashboard” and “DB Config”.",
    "crumbs": [
      "Documentation",
      "Data Management",
      "Local Dashboard"
    ]
  },
  {
    "objectID": "docs/local-dashboard.html#dashboard-tab",
    "href": "docs/local-dashboard.html#dashboard-tab",
    "title": "Local Dashboard",
    "section": "Dashboard Tab",
    "text": "Dashboard Tab\nThe “Dashboard” tab looks like this:\n\n\n\n\nThe “Dashboard” tab allows you to view your survey data in a user-friendly interface. It contains survey answering statistics and response summarization charts. On the lower part you can preview the survey data sheet. There is a download button for you to obtain the survey data in CSV format.",
    "crumbs": [
      "Documentation",
      "Data Management",
      "Local Dashboard"
    ]
  },
  {
    "objectID": "docs/local-dashboard.html#db-config-tab",
    "href": "docs/local-dashboard.html#db-config-tab",
    "title": "Local Dashboard",
    "section": "DB Config Tab",
    "text": "DB Config Tab\nThe “DB Config” tab looks like this:\n\n\n\n\nIn the “DB Config” tab, you can view and edit your database credentials. Therefore, you can either set up your credentials using the sd_db_config() function in your R console, or simply launch this dashboard app and modify them here.",
    "crumbs": [
      "Documentation",
      "Data Management",
      "Local Dashboard"
    ]
  },
  {
    "objectID": "docs/question-formatting.html",
    "href": "docs/question-formatting.html",
    "title": "Question Formatting",
    "section": "",
    "text": "The sd_question() function has many optional arguments for modifying the appearance and behavior of questions. This page demonstrates some of the formatting options.",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Formatting"
    ]
  },
  {
    "objectID": "docs/question-formatting.html#markdown-formatting",
    "href": "docs/question-formatting.html#markdown-formatting",
    "title": "Question Formatting",
    "section": "Markdown formatting",
    "text": "Markdown formatting\nMarkdown is supported for question labels and option labels.\nQuestion labels\nThe label argument for any question type can accept markdown formatting. For example, the question below uses the * symbol to make some words bold, italic, and bold italic.\n\n\nCode chunk\nOutput\n\n\n\n\n```{r}\nsd_question(\n  type   = 'mc',\n  id     = 'markdown_label',\n  label  = \"**This** is a question *label* supporting ***markdown***:\",\n  option = c(\n    \"Option A\" = \"option_a\",\n    \"Option B\" = \"option_b\",\n    \"Option C\" = \"option_c\"\n  )\n)\n```\n\n\n\n\n\n\n\nThis is a question label supporting markdown:\n\n\n\n\nOption A\n\n\n\n\nOption B\n\n\n\n\nOption C\n\n\n\n\n*\n\n\n\n\n\n\nOption labels\nMarkdown formatting is also supported for the option labels in question types that have options, such as mc, mc_multiple, mc_buttons, and mc_multiple_buttons. For example:\n\n\nCode chunk\nOutput\n\n\n\n\n```{r}\nsd_question(\n  type   = 'mc_buttons',\n  id     = 'markdown_buttons',\n  label  = \"The 3 options below support markdown:\",\n  option = c(\n    \"*Option A*\"     = \"option_a\",\n    \"**Option B**\"   = \"option_b\",\n    \"***Option C***\" = \"option_c\"\n  )\n)\n```\n\n\n\n\n\n\n\nThe 3 options below support markdown:\n\n\n\nOption A\nOption B\nOption C\n\n\n\n\n*",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Formatting"
    ]
  },
  {
    "objectID": "docs/question-formatting.html#html-formatting",
    "href": "docs/question-formatting.html#html-formatting",
    "title": "Question Formatting",
    "section": "HTML formatting",
    "text": "HTML formatting\nHTML formatting is supported for the option labels in question types that have options, such as mc_buttons and mc_multiple_buttons. This allows you to insert mixed content to achieve more complex labels, including plain text, markdown, and HTML code.\nFor example, here is a question with some complex labels for a choice question that include markdown and HTML code to embed images.\n\n\nCode chunk\nOutput\n\n\n\n\n```{r}\n# Define the option vector\nhtml_button_options &lt;- c(\"option_1\", \"option_2\", \"option_3\")\n\n# Define option labels that include markdown and HTML code to embed images\nnames(html_button_options) &lt;- c(\n\n  \"**Option 1**&lt;br&gt;\n   &lt;img src='https://github.com/surveydown-dev/demos/blob/main/conjoint-buttons/images/fuji.jpg?raw=true' width=100&gt;&lt;br&gt;\n   **Type**: Fuji&lt;br&gt;\n   **Price**: $ 2 / lb&lt;br&gt;\n   **Freshness**: Average\",\n\n  \"**Option 2**&lt;br&gt;\n   &lt;img src='https://github.com/surveydown-dev/demos/blob/main/conjoint-buttons/images/pinkLady.jpg?raw=true' width=100&gt;&lt;br&gt;\n    **Type**: Pink Lady&lt;br&gt;\n    **Price**: $ 1.5 / lb&lt;br&gt;\n    **Freshness**: Excellent\",\n\n  \"**Option 3**&lt;br&gt;\n    &lt;img src='https://github.com/surveydown-dev/demos/blob/main/conjoint-buttons/images/honeycrisp.jpg?raw=true' width=100&gt;&lt;br&gt;\n    **Type**: Honeycrisp&lt;br&gt;\n    **Price**: $ 2 / lb&lt;br&gt;\n    **Freshness**: Poor\"\n)\n\nsd_question(\n  type   = 'mc_buttons',\n  id     = 'html_buttons',\n  label  = \"A sample survey question using `mc_buttons`\",\n  option = html_button_options\n)\n```\n\n\n\n\n\n\n\nA sample survey question using mc_buttons\n\n\n\nOption 1Type: FujiPrice: $ 2 / lbFreshness: Average\nOption 2Type: Pink LadyPrice: $ 1.5 / lbFreshness: Excellent\nOption 3Type: HoneycrispPrice: $ 2 / lbFreshness: Poor\n\n\n\n\n*",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Formatting"
    ]
  },
  {
    "objectID": "docs/question-formatting.html#size-formatting",
    "href": "docs/question-formatting.html#size-formatting",
    "title": "Question Formatting",
    "section": "Size formatting",
    "text": "Size formatting\nUse the width, height arguments to change the size of the question.\nFor example, the question below uses the width and height arguments to change the size of a text area question.\n\n\nCode chunk\nOutput\n\n\n\n\n```{r}\nsd_question(\n  type  = \"textarea\",\n  id    = \"change_width\",\n  label = \"This text area has width set as 40% and height set as 100px:\",\n  width = \"40%\", \n  height = \"100px\"\n)\n```\n\n\n\n\n\n\n\nThis text area has width set as 40% and height set as 100px:\n\n\n\n*",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Formatting"
    ]
  },
  {
    "objectID": "docs/randomization.html",
    "href": "docs/randomization.html",
    "title": "Randomization",
    "section": "",
    "text": "This page explains how to show a question with randomized labels (unique labels for each respondent). While this is not the only use case for randomization, it illustrates in general how to implement something where each respondent sees something unique to their survey.\nThe key is to define anything random in the server (app.R file), not the survey (survey.qmd file). If you define a value or question in the survey.qmd file, it will be the same for every respondent.\nBefore reading this, we suggest you first read the reactivity manual to get a general understanding of how reactivity works in surveydown.",
    "crumbs": [
      "Documentation",
      "Interactivity",
      "Randomization"
    ]
  },
  {
    "objectID": "docs/randomization.html#live-randomization",
    "href": "docs/randomization.html#live-randomization",
    "title": "Randomization",
    "section": "Live randomization",
    "text": "Live randomization\nOne approach is to generate the random labels in the server function “live”, meaning that the labels will be generated when the survey is first loaded. For example, let’s say in my server function I generate three random numbers between 1 and 100 and use them to create the option labels for a multiple choice question:\n\n# Create a vector of options\nq1_options &lt;- c('option 1', 'option 2', 'option 3')\n\n# Randomly sample 3 labels from 1 to 100\nq1_labels &lt;- sample(seq(100), 3) \n\n# Assign the labels to the options\nnames(q1_options) &lt;- q1_labels \n\nq1_options\n\n#&gt;         49         65         25 \n#&gt; \"option 1\" \"option 2\" \"option 3\"\n\n\nRemember that the names of the vector are the labels, so the respondents will see the numbers in the names of the above vector, and the values ('option1', etc.) will be stored in the resulting survey data.\nTo then use these options in a multiple choice question, you would use the sd_question() function also in the server function (not in the survey.qmd file) like this:\n\nsd_question(\n  id = \"q1\",\n  type = \"mc\",  \n  label = \"Which of these numbers is the largest?\",\n  option = q1_options\n)\n\nBy defining this question inside the server function, the question will be created as a reactive question that can then be displayed in the survey.qmd file using the sd_output() function, like this:\n\n```{r}\nsd_output(id = \"q1\", type = \"question\")\n```\n\nOne important caveat to this approach is that the random numbers that are generated are not automatically stored in the survey data (because they are generated live). If you needed to store the random numbers, you can use the sd_store_value() function, like this:\n\nsd_store_value(q1_labels, id = \"q1_labels\")\n\nThis would store the numbers in the q1_labels column of the survey data, which would be concatenated into the single string: 49, 65, 25.\nYou could alternatively use the sd_store_value() function to store each of the random numbers in separate columns, like this:\n\nsd_store_value(q1_labels[1], id = \"q1_label_1\")\nsd_store_value(q1_labels[2], id = \"q1_label_2\")\nsd_store_value(q1_labels[3], id = \"q1_label_3\")",
    "crumbs": [
      "Documentation",
      "Interactivity",
      "Randomization"
    ]
  },
  {
    "objectID": "docs/randomization.html#predefined-randomization",
    "href": "docs/randomization.html#predefined-randomization",
    "title": "Randomization",
    "section": "Predefined randomization",
    "text": "Predefined randomization\nAn alternative approach is to predefine the randomized labels and store them in a separate design file, and then randomly select a set of labels for each respondent from the design file.\nFor example, let’s generate 10 sets of 3 random numbers between 1 and 100 and store them in a data frame:\n\ndesign &lt;- data.frame(\n  id = rep(1:10, each = 3),\n  numbers = unlist(lapply(1:10, function(x) sample(seq(100), 3)))\n)\n\nhead(design)\n\n#&gt;   id numbers\n#&gt; 1  1      74\n#&gt; 2  1      18\n#&gt; 3  1      49\n#&gt; 4  2      47\n#&gt; 5  2      24\n#&gt; 6  2      71\n\n\nNow we can write this design to a csv file:\n\nreadr::write_csv(design, \"design.csv\")\n\nThen in your server function in the app.R file, you could read in the design file and use it to randomize the labels for each question. Here the only thing you would need to keep track of the randomly chosen row id:\n\n# Read in the design file\ndesign &lt;- readr::read_csv(\"design.csv\")\n\n# Randomly choose a row id\nq1_id &lt;- sample(design$id, 1)\n\n# Store the chosen row id in the survey data (here q1_id will be the column name)\nsd_store_value(q1_id) \n\n# Filter the design to get the chosen row\nnumbers &lt;- design |&gt; \n  filter(id == q1_id) |&gt; \n  pull(numbers)\n\n# Create the options\nq1_options &lt;- c('option 1', 'option 2', 'option 3')\nnames(q1_options) &lt;- numbers\n\n# Create the reactive question\nsd_question(\n  id = \"q1\",\n  type = \"mc\",  \n  label = \"Which of these numbers is the largest?\",\n  option = q1_options\n)\n\nOnce again, you would be able to then display this question in the survey.qmd file using the sd_output() function:\n\n```{r}\nsd_output(id = \"q1\", type = \"question\")\n```",
    "crumbs": [
      "Documentation",
      "Interactivity",
      "Randomization"
    ]
  },
  {
    "objectID": "docs/security.html",
    "href": "docs/security.html",
    "title": "Security",
    "section": "",
    "text": "There are three main security considerations when working with a surveydown survey:\nWhile we have worked to make our application code secure, it is ultimately up to you to choose appropriate host and data storage environments that are also secure for your needs.",
    "crumbs": [
      "Documentation",
      "Deployment & Operations",
      "Security"
    ]
  },
  {
    "objectID": "docs/security.html#the-surveydown-application-code",
    "href": "docs/security.html#the-surveydown-application-code",
    "title": "Security",
    "section": "The surveydown application code",
    "text": "The surveydown application code\nThe application code refers to the resulting Shiny app generated from a surveydown survey. Since surveydown users will be collecting potentially sensitive data from survey respondents, we have tried to develop the platform with data security in mind. We have taken care to follow many best practices, such as using SQL injection prevention strategies in how we store the survey response data, and ensuring that users store their database credentials as a .env file that is also added to a .gitignore file. We also adopted an architecture where all content on any page in the survey is served entirely from the shiny server, meaning that respondents taking the survey cannot see the underlying html source code for any of the content being displayed in the survey. This is important so respondents cannot see content on other pages (e.g., completion codes) before getting there from the survey navigation buttons.\nDespite our efforts, however, we do not (yet) have any form of security compliance certificate that we can provide. This means we cannot guarantee the application code is compliant with common security protocols, such as SOC2 Type 2 or HIPPA. This is an eventual goal, but for now this is a limitation for using this package for some domains that require certain certifications.",
    "crumbs": [
      "Documentation",
      "Deployment & Operations",
      "Security"
    ]
  },
  {
    "objectID": "docs/security.html#the-hosting-environment",
    "href": "docs/security.html#the-hosting-environment",
    "title": "Security",
    "section": "The hosting environment",
    "text": "The hosting environment\n\nShinyapps.io\nThe free service we use for hosting a surveydown survey is shinyapps.io, which is not HIPPA compliant. According to the Posit Documentation on Security and Compliance for shinyapps.io:\n\nshinyapps.io is currently hosted on Amazon’s Web Services (AWS) infrastructure in the us-east-1 region. The infrastructure used is not the HIPAA-compliant stack, so if you need to be in a HIPAA-compliant environment, we recommend deploying and operating your own Posit Connect or Shiny Server Open Source instance.\n\nThis means that if you require a HIPPA compliant hosting service, we recommend that follow Posit’s guidelines and deploy your own instance of Posit Connect.\n\n\nOther Hosting Services\nYou can deploy shiny apps to other hosting services. Here are some guides for several other alternatives:\n\nPosit Connect Cloud\nHugging Face\nHeroku\n\nYou can also install Posit Connect on your own server, which is the recommended approach for remaining compliant with any security protocols your organization requires.\nWhatever hosting service you choose, please read carefully about the security implications of the environment you choose.",
    "crumbs": [
      "Documentation",
      "Deployment & Operations",
      "Security"
    ]
  },
  {
    "objectID": "docs/security.html#the-data-storage-environment",
    "href": "docs/security.html#the-data-storage-environment",
    "title": "Security",
    "section": "The data storage environment",
    "text": "The data storage environment\nWe designed surveydown to be able to store data on any PostgreSQL database. This gives you flexibility on where you choose to store your data, and it is up to you to find a suitable host.\nFortunately, the default service we recommend using (Supabase) is actually SOC2 Type 2 and HIPPA compliant 🎉\nAs with the hosting service, please choose a data storage environment carefully and read about the security implications of the environment you choose.",
    "crumbs": [
      "Documentation",
      "Deployment & Operations",
      "Security"
    ]
  },
  {
    "objectID": "docs/storing-data.html",
    "href": "docs/storing-data.html",
    "title": "Storing Data",
    "section": "",
    "text": "Survey response data is stored in a PostgreSQL database. We recommend using Supabase as it is free and open-source, though you can use any service you want.\nIn this guide, we’ll walk you through the steps for setting up a Supabase project and connecting your surveydown survey to it.",
    "crumbs": [
      "Documentation",
      "Data Management",
      "Storing Data"
    ]
  },
  {
    "objectID": "docs/storing-data.html#setting-up-a-supabase-project",
    "href": "docs/storing-data.html#setting-up-a-supabase-project",
    "title": "Storing Data",
    "section": "Setting up a Supabase project",
    "text": "Setting up a Supabase project\nFirst, navigate to the Supabase website and create an account.\nOnce you are logged in, the page will prompt you to create a project (it’s a green button). Click on it and select your organization. A dialog box will pop up like this:\n\n\n\n\nFill in the project name and give it a strong password. Choose a region that is close to you (or close to your survey audience). All settings can be modified at any time.\n\n\n\n\n\n\nNote\n\n\n\nEach Supabase project is a database that can store multiple tables. Since each surveydown survey requires only one table, you can use the same Supabase project for multiple surveydown surveys.",
    "crumbs": [
      "Documentation",
      "Data Management",
      "Storing Data"
    ]
  },
  {
    "objectID": "docs/storing-data.html#getting-your-supabase-credentials",
    "href": "docs/storing-data.html#getting-your-supabase-credentials",
    "title": "Storing Data",
    "section": "Getting your Supabase credentials",
    "text": "Getting your Supabase credentials\nOnce your Supabase project is ready, click on the “connect” button at the top, it should look like this:\n\n\n\n\nOn the connection page, scroll down to the “Transaction pooler” section. There you can click on the “View parameters” drop down to see your connection parameters. It should look somethinglike this:\n\n\n\n\nYou will need these parameters and your password to connect to your database in surveydown.",
    "crumbs": [
      "Documentation",
      "Data Management",
      "Storing Data"
    ]
  },
  {
    "objectID": "docs/storing-data.html#storing-your-database-credentials",
    "href": "docs/storing-data.html#storing-your-database-credentials",
    "title": "Storing Data",
    "section": "Storing your database credentials",
    "text": "Storing your database credentials\nBefore connecting to your database, you need to store your credentials. You can do this by running the following code in your R console:\n\nsurveydown::sd_db_config()\n\nThis function will prompt you to enter your database credentials and password, one by one. The current credential values will be shown in square brackets. When done it should look like this:\n\n\n\n\nOnce you have entered your credentials, the function will store them in a .env file in your project folder. We strongly recommend that you do not manually edit this file or share it with others as it stores all of your database credentials, including your password.",
    "crumbs": [
      "Documentation",
      "Data Management",
      "Storing Data"
    ]
  },
  {
    "objectID": "docs/storing-data.html#modifying-credentials",
    "href": "docs/storing-data.html#modifying-credentials",
    "title": "Storing Data",
    "section": "Modifying credentials",
    "text": "Modifying credentials\nIf you want to modify your credentials stored in the .env file, you can just run sd_db_config() again and press ‘Enter’ on any parameter you want to leave unchanged while modifying the ones you want to change.\nYou can also pass any of the parameters as arguments to sd_db_config() to change them. For example, if you wanted to only change the table name, you could do this:\n\nsd_db_config(table = 'mytable')\n\nOnce run in the R console, a message will print out confirming that the stored table parameter will now be mytable.\nYou can pass any of the following as arguments: host, dbname, port, user, table, password, and gssencmode\nFinally, you can also view / modify your database credentials in the surveydown dashboard app. To do this, launch the dashboard by running this command in the R console:\n\nsurveydown::sd_dashboard()\n\nThis will open a new browser window where you can navigate to the dashboard for your project. Click on the “Connection Settings” tab to see and edit your database credentials. Once you have made changes, click on the “Test Connection” button to save your updated credentials.\nSee the Local Dashboard page for more information.",
    "crumbs": [
      "Documentation",
      "Data Management",
      "Storing Data"
    ]
  },
  {
    "objectID": "docs/storing-data.html#connecting-to-your-database-in-surveydown",
    "href": "docs/storing-data.html#connecting-to-your-database-in-surveydown",
    "title": "Storing Data",
    "section": "Connecting to your database in surveydown",
    "text": "Connecting to your database in surveydown\nNow that you have set your credentials stored, you can connect to your database in surveydown by running the following code in your app.R file:\n\ndb &lt;- sd_db_connect()\n\nYou do not need to specify any arguments to this function as it will automatically use the credentials stored in your .env file. If the connection is successful, you should see a message in the console that says “✔ Successfully connected to the database.”\nYou can also ignore the database connection by setting ignore = TRUE in sd_db_connect():\n\ndb &lt;- sd_db_connect(ignore = TRUE)\n\nWith this setting, no database connection will be attempted, and the db object will store the value NULL. Instead, data will be stored in a local preview_data.csv file for previewing purposes only. This is useful when you are still editing your survey and do not want to store any data in your database yet.",
    "crumbs": [
      "Documentation",
      "Data Management",
      "Storing Data"
    ]
  },
  {
    "objectID": "docs/storing-data.html#disabling-gssencmode",
    "href": "docs/storing-data.html#disabling-gssencmode",
    "title": "Storing Data",
    "section": "Disabling gssencmode\n",
    "text": "Disabling gssencmode\n\nIf you have set all of your credentials correctly but are still encountering connection errors, try setting the gssencmode parameter to \"disable\" when running sd_db_config().\nBy default, gssencmode is set as \"prefer\". It secures your connection with PostgreSQL. We generally recommend that you DO NOT disable gssencmode, but sometimes this is necessary, especially when you are working on a protected network, such as a VPN.",
    "crumbs": [
      "Documentation",
      "Data Management",
      "Storing Data"
    ]
  },
  {
    "objectID": "docs/tips.html",
    "href": "docs/tips.html",
    "title": "Tips",
    "section": "",
    "text": "This page has some helpful suggestions for working with surveydown surveys.",
    "crumbs": [
      "Documentation",
      "Recipes & Patterns",
      "Tips"
    ]
  },
  {
    "objectID": "docs/tips.html#programmatically-generate-survey-questions",
    "href": "docs/tips.html#programmatically-generate-survey-questions",
    "title": "Tips",
    "section": "Programmatically generate survey questions",
    "text": "Programmatically generate survey questions\nYou can use  code to programmatically generate survey questions in your survey.qmd file, which can be useful if you have a large number of questions that are similar to each other. One way to do this is to first create a data frame with the question parameters, and then use the sd_question() function to create the questions.\nHere’s an example using map() over the items data frame to generate a list of questions. Note that the list of questions is wrapped in shiny::tagList(), which is necessary for the survey to render properly since the map() function returns a list.\n\n\n\n\n\n\nNote\n\n\n\nThis approach inserts all the questions on the same page. We haven’t found a way to insert these questions on different pages, which would require more sophistication in the map() function.\n\n\n\n\nCode chunk\nOutput\n\n\n\n\n```{r}\n# Generate data frame of question parameters\nitems &lt;- tibble::tibble(\n  type = \"mc\",\n  id = as.character(1:3),\n  label = LETTERS[1:3],\n  option = list(c(\n    \"None\" = \"0\", \n    \"A Little\" = \"1\",\n    \"A lot\" = \"2\"\n  ))\n)\n\n# Generate questions\nshiny::tagList(\n  purrr::map(1:nrow(items), function(i) {\n    args &lt;- items[i, ]\n    sd_question(\n      id     = as.character(args$id),\n      type   = args$type,\n      label  = args$label,\n      option = unlist(args$option)\n    )\n  })\n)\n```\n\n\n\n\n\n\n\nA\n\n\n\n\nNone\n\n\n\n\nA Little\n\n\n\n\nA lot\n\n\n\n\n*\n\n\n\nB\n\n\n\n\nNone\n\n\n\n\nA Little\n\n\n\n\nA lot\n\n\n\n\n*\n\n\n\nC\n\n\n\n\nNone\n\n\n\n\nA Little\n\n\n\n\nA lot\n\n\n\n\n*",
    "crumbs": [
      "Documentation",
      "Recipes & Patterns",
      "Tips"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to surveydown.org!",
    "section": "",
    "text": "Welcome to surveydown.org!\nsurveydown is a flexible, open-source platform for making surveys with , Quarto, Shiny, and Supabase.\n\n\n\n\n\n\nImportant\n\n\n\nsurveydown is an early stage project under active development and may not yet be a good fit for you. If you are interested in experimenting with it, we welcome your feedback!\n\n\n\n\n\n\n\nAbout the package and the open-source technologies behind it.\n\n\nABOUT\n\n\n\n\n\n\n\n\nTemplates for easy start.\n\n\nTEMPLATES\n\n\n\n\n\n\n\n\nDocumentation for building surveys with surveydown.\n\n\nDOCUMENTATION\n\n\n\n\n\n\n\n\nFrequently asked questions.\n\n\nFAQ"
  },
  {
    "objectID": "templates/01_plain_template.html",
    "href": "templates/01_plain_template.html",
    "title": "Plain Template",
    "section": "",
    "text": "To create this template, run this command in your R console:\n\nsurveydown::sd_create_survey(\n  #path = \"path/to/survey\"\n)\n\nThere is a template = \"plain_template\" argument in the sd_create_survey() function, but it is set as default so no need to specify it.\nRefer to the Start with a template section for more details.\n\n  Open in New Tab    GitHub Repo \n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Templates",
      "Basic",
      "Plain Template"
    ]
  },
  {
    "objectID": "templates/03_conditional_display.html",
    "href": "templates/03_conditional_display.html",
    "title": "Conditional Display",
    "section": "",
    "text": "To create this template, run this command in your R console:\n\nsurveydown::sd_create_survey(\n  #path = \"path/to/survey\",\n  template = \"conditional_display\"\n)\n\nRefer to the Start with a template section for more details.\n\n  Open in New Tab    GitHub Repo \n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Templates",
      "Basic",
      "Conditional Display"
    ]
  },
  {
    "objectID": "templates/05_random_options.html",
    "href": "templates/05_random_options.html",
    "title": "Random Options",
    "section": "",
    "text": "To create this template, run this command in your R console:\n\nsurveydown::sd_create_survey(\n  #path = \"path/to/survey\",\n  template = \"random_options\"\n)\n\nRefer to the Start with a template section for more details.\n\n  Open in New Tab    GitHub Repo \n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Templates",
      "Randomization",
      "Random Options"
    ]
  },
  {
    "objectID": "templates/07_reactive_questions.html",
    "href": "templates/07_reactive_questions.html",
    "title": "Reactive Questions",
    "section": "",
    "text": "To create this template, run this command in your R console:\n\nsurveydown::sd_create_survey(\n  #path = \"path/to/survey\",\n  template = \"reactive_questions\"\n)\n\nRefer to the Start with a template section for more details.\n\n  Open in New Tab    GitHub Repo \n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Templates",
      "Reactivity",
      "Reactive Questions"
    ]
  },
  {
    "objectID": "templates/09_external_redirect.html",
    "href": "templates/09_external_redirect.html",
    "title": "External Redirect",
    "section": "",
    "text": "To create this template, run this command in your R console:\n\nsurveydown::sd_create_survey(\n  #path = \"path/to/survey\",\n  template = \"external_redirect\"\n)\n\nRefer to the Start with a template section for more details.\n\n  Open in New Tab    GitHub Repo \n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Templates",
      "Reactivity",
      "External Redirect"
    ]
  },
  {
    "objectID": "templates/11_conjoint_buttons.html",
    "href": "templates/11_conjoint_buttons.html",
    "title": "Choice-based-conjoint Survey with Buttons",
    "section": "",
    "text": "To create this template, run this command in your R console:\n\nsurveydown::sd_create_survey(\n  #path = \"path/to/survey\",\n  template = \"conjoint_buttons\"\n)\n\nRefer to the Start with a template section for more details.\n\n  Open in New Tab    GitHub Repo \n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Templates",
      "Conjoint",
      "Conjoint Buttons"
    ]
  },
  {
    "objectID": "templates/13_custom_leaflet_map.html",
    "href": "templates/13_custom_leaflet_map.html",
    "title": "Custom Leaflet Map",
    "section": "",
    "text": "To create this template, run this command in your R console:\n\nsurveydown::sd_create_survey(\n  #path = \"path/to/survey\",\n  template = \"custom_leaflet_map\"\n)\n\nRefer to the Start with a template section for more details.\n\n  Open in New Tab    GitHub Repo \n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Templates",
      "Custom",
      "Custom Leaflet Map"
    ]
  }
]