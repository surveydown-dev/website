[
  {
    "objectID": "templates/reactive_questions.html",
    "href": "templates/reactive_questions.html",
    "title": "Reactive Questions",
    "section": "",
    "text": "To create this template, run this command in your R console:\n\nsurveydown::sd_create_survey(\n  #path = \"path/to/survey\",\n  template = \"reactive_questions\"\n)\n\nRefer to the Start with a template section for more details.\n\n Open in New Tab  GitHub Repo\n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Templates",
      "Reactivity",
      "Reactive Questions"
    ]
  },
  {
    "objectID": "templates/random_options_predefined.html",
    "href": "templates/random_options_predefined.html",
    "title": "Predefined Random Options",
    "section": "",
    "text": "To create this template, run this command in your R console:\n\nsurveydown::sd_create_survey(\n  #path = \"path/to/survey\",\n  template = \"random_options_predefined\"\n)\n\nRefer to the Start with a template section for more details.\n\n Open in New Tab  GitHub Repo\n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Templates",
      "Randomization",
      "Random Options Predefined"
    ]
  },
  {
    "objectID": "templates/questions_yml.html",
    "href": "templates/questions_yml.html",
    "title": "Questions Defined with YAML",
    "section": "",
    "text": "To create this template, run this command in your R console:\n\nsurveydown::sd_create_survey(\n  #path = \"path/to/survey\",\n  template = \"questions_yml\"\n)\n\nRefer to the Start with a template section for more details.\n\n Open in New Tab  GitHub Repo\n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Templates",
      "Basic",
      "Questions Defined with YAML"
    ]
  },
  {
    "objectID": "templates/live_polling.html",
    "href": "templates/live_polling.html",
    "title": "Live Polling",
    "section": "",
    "text": "To create this template, run this command in your R console:\n\nsurveydown::sd_create_survey(\n  #path = \"path/to/survey\",\n  template = \"live_polling\"\n)\n\nRefer to the Start with a template section for more details.\n\n GitHub Repo\n\n\n\n\n\n\n\nNote\n\n\n\n\nThe live-polling feature requires connection to database and cannot be demonstrated in the template preview. Therefore, a screenshot of bar chart resulted by live-polling is shown here instead.\nTo make this template work, you should firstly define your credentials by calling sd_db_config(), and then delete the ignore = TRUE argument in the sd_db_connect() function call. Once your survey is up and running, try to go through the survey several times. You’ll see the bar chart updating in real-time as new responses are submitted.\n\n\n\n\n\n\nIn the screenshot above, the survey page shows the choice of the current session, as well as a bar chart of all responses from the database. The bar chart updates in real-time as new responses are submitted. This feature is useful for live polling or feedback sessions where you want to see how opinions change over time.\n\n\n\n Back to top",
    "crumbs": [
      "Templates",
      "Reactivity",
      "Live Polling"
    ]
  },
  {
    "objectID": "templates/default.html",
    "href": "templates/default.html",
    "title": "Default Template",
    "section": "",
    "text": "To create this template, run this command in your R console:\n\nsurveydown::sd_create_survey(\n  #path = \"path/to/survey\"\n)\n\nThere is a template = \"default\" argument in the sd_create_survey() function, but it is set as default so no need to specify it.\nRefer to the Start with a template section for more details.\n\n Open in New Tab  GitHub Repo\n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Templates",
      "Basic",
      "Default Template"
    ]
  },
  {
    "objectID": "templates/custom_leaflet_map.html",
    "href": "templates/custom_leaflet_map.html",
    "title": "Custom Leaflet Map",
    "section": "",
    "text": "To create this template, run this command in your R console:\n\nsurveydown::sd_create_survey(\n  #path = \"path/to/survey\",\n  template = \"custom_leaflet_map\"\n)\n\nRefer to the Start with a template section for more details.\n\n Open in New Tab  GitHub Repo\n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Templates",
      "Custom",
      "Custom Leaflet Map"
    ]
  },
  {
    "objectID": "templates/conjoint_buttons.html",
    "href": "templates/conjoint_buttons.html",
    "title": "Choice-based-conjoint Survey with Buttons",
    "section": "",
    "text": "To create this template, run this command in your R console:\n\nsurveydown::sd_create_survey(\n  #path = \"path/to/survey\",\n  template = \"conjoint_buttons\"\n)\n\nRefer to the Start with a template section for more details.\n\n Open in New Tab  GitHub Repo\n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Templates",
      "Conjoint",
      "Conjoint Buttons"
    ]
  },
  {
    "objectID": "templates/conditional_skipping.html",
    "href": "templates/conditional_skipping.html",
    "title": "Conditional Skipping",
    "section": "",
    "text": "To create this template, run this command in your R console:\n\nsurveydown::sd_create_survey(\n  #path = \"path/to/survey\",\n  template = \"conditional_skipping\"\n)\n\nRefer to the Start with a template section for more details.\n\n Open in New Tab  GitHub Repo\n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Templates",
      "Conditions",
      "Conditional Skipping"
    ]
  },
  {
    "objectID": "templates.html",
    "href": "templates.html",
    "title": "Templates",
    "section": "",
    "text": "To help you get started with surveydown, we created some templates that cover many of the features of the package. Feel free to use any as a starting point for your own surveys or as a reference for specific features.\nCall sd_create_survey() with proper arguments to create your desired templates in your preferred directory. Refer to the Start with a template section for more details.\n\n View the templates repo\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDefault Template\n\n\n\nBasic\n\n\n\nA minimum template for starting from scratch.\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion Types\n\n\n\nBasic\n\n\n\nA template showcasing all built-in question types.\n\n\n\n\n\n\n\n\n\n\n\n\nQuestions Defined with YAML\n\n\n\nBasic\n\n\n\nA template showcasing questions defined using a YAML file.\n\n\n\n\n\n\n\n\n\n\n\n\nConditional Showing\n\n\n\nConditions\n\n\n\nA template for conditional showing.\n\n\n\n\n\n\n\n\n\n\n\n\nConditional Skipping\n\n\n\nConditions\n\n\n\nA template for conditional skipping.\n\n\n\n\n\n\n\n\n\n\n\n\nConditional Stopping\n\n\n\nConditions\n\n\n\nA template for conditional stopping.\n\n\n\n\n\n\n\n\n\n\n\n\nRandom Options\n\n\n\nRandomization\n\n\n\nA template for creating randomized survey options.\n\n\n\n\n\n\n\n\n\n\n\n\nPredefined Random Options\n\n\n\nRandomization\n\n\n\nA template for creating predefined randomized survey options.\n\n\n\n\n\n\n\n\n\n\n\n\nReactive Questions\n\n\n\nReactivity\n\n\n\nA template for creating reactive survey questions.\n\n\n\n\n\n\n\n\n\n\n\n\nReactive drilldown\n\n\n\nReactivity\n\n\n\nA reactive question template, with latter question options defined from former selection.\n\n\n\n\n\n\n\n\n\n\n\n\nExternal Redirect\n\n\n\nReactivity\n\n\n\nA reactive question template with redirectional links, accepting URL parameters.\n\n\n\n\n\n\n\n\n\n\n\n\nLive Polling\n\n\n\nReactivity\n\n\n\nA reactive question template of live-polling with responses shown as a bar chart.\n\n\n\n\n\n\n\n\n\n\n\n\nChoice-based-conjoint Survey with Buttons\n\n\n\nConjoint\n\n\n\nA conjoint survey template with options shown in buttons.\n\n\n\n\n\n\n\n\n\n\n\n\nChoice-based-conjoint Survey with Tables\n\n\n\nConjoint\n\n\n\nA conjoint survey template, with option contents shown in a table.\n\n\n\n\n\n\n\n\n\n\n\n\nCustom Leaflet Map\n\n\n\nCustom\n\n\n\nA template of custom leaflet map question using sd_question_custom().\n\n\n\n\n\n\n\n\n\n\n\n\nCustom Plotly Chart\n\n\n\nCustom\n\n\n\nA template of custom plotly chart question using sd_question_custom().\n\n\n\n\n\nNo matching items\n Back to top",
    "crumbs": [
      "Templates"
    ]
  },
  {
    "objectID": "faq.html",
    "href": "faq.html",
    "title": "Frequently Asked Questions",
    "section": "",
    "text": "Note\n\n\n\nHave a question but don’t see an answer here? Feel free to make a post on GitHub:\n\nPost a bug report or documentation issue on the GitHub repo issues page.\nAsk a question, make a feature request, start a discussion, or show off your project on the discussion board."
  },
  {
    "objectID": "faq.html#is-surveydown-right-for-me",
    "href": "faq.html#is-surveydown-right-for-me",
    "title": "Frequently Asked Questions",
    "section": "Is surveydown right for me?",
    "text": "Is surveydown right for me?\nsurveydown might be a good fit for you today if…\n\nyou are comfortable using Quarto for rendering markdown into html outputs and  for basic coding (you certainly don’t need to be an R “expert” to use surveydown!)\nyou are frustrated with alternative survey platforms that require expensive licenses or have limited features.\nyou want to collaborate on surveys with others using reproducible tools like Git.\nyou don’t mind using a project that is not fully polished or finished.\n\nsurveydown might not be a good fit for you today if…\n\nyou need stable, polished software that is mature and completely bug-free.\nyou need a product with a guaranteed security level, such as HIPAA compliance (see our security page for more details).\nyou prefer a platform that uses a graphic interface to define survey content."
  },
  {
    "objectID": "faq.html#why-is-my-survey-app-so-slow-when-starting",
    "href": "faq.html#why-is-my-survey-app-so-slow-when-starting",
    "title": "Frequently Asked Questions",
    "section": "Why is my survey app so slow when starting?",
    "text": "Why is my survey app so slow when starting?\nWhen a {surveydown} survey first runs, it checks for files in a **_survey** folder that contain the rendered content from your survey.qmd file. If any of those files are missing or if changes have been detected in your survey.qmd or app.R files, it will re-render your survey, which can take a bit longer. But this only happens once, and afterwards so long as no further changes have been made to your survey files the app will use the saved content in the **_survey** folder to launch, which should load almost instantly. So if your app launches slowly, just close it and launch it again and you should immediately load. If you still see a slow launch, consider posting an issue to let us know that something might be wrong.\nAlso, it is important that you run your survey locally at least once before deploying it live. This will render all your survey content into the **_survey** folder, which will also get uploaded when you deploy it."
  },
  {
    "objectID": "faq.html#how-do-i-customize-my-survey",
    "href": "faq.html#how-do-i-customize-my-survey",
    "title": "Frequently Asked Questions",
    "section": "How do I customize my survey?",
    "text": "How do I customize my survey?\nPlease see our Survey Settings page for a full walkthrough of all available customization options, including themes, colors, progress bar settings, and survey behaviors."
  },
  {
    "objectID": "docs/tips.html",
    "href": "docs/tips.html",
    "title": "Tips",
    "section": "",
    "text": "This page has some helpful suggestions for working with surveydown surveys.",
    "crumbs": [
      "Documentation",
      "Other",
      "Tips"
    ]
  },
  {
    "objectID": "docs/tips.html#programmatically-generate-survey-questions",
    "href": "docs/tips.html#programmatically-generate-survey-questions",
    "title": "Tips",
    "section": "Programmatically generate survey questions",
    "text": "Programmatically generate survey questions\nYou can use  code to programmatically generate survey questions in your survey.qmd file, which can be useful if you have a large number of questions that are similar to each other. One way to do this is to first create a data frame with the question parameters, and then use the sd_question() function to create the questions.\nHere’s an example using map() over the items data frame to generate a list of questions. Note that the list of questions is wrapped in shiny::tagList(), which is necessary for the survey to render properly since the map() function returns a list.\n\n\n\n\n\n\nNote\n\n\n\nThis approach inserts all the questions on the same page. We haven’t found a way to insert these questions on different pages, which would require more sophistication in the map() function.\n\n\n\n\nCode chunk\nOutput\n\n\n\n\n```{r}\n# Generate data frame of question parameters\nitems &lt;- tibble::tibble(\n  type = \"mc\",\n  id = as.character(1:3),\n  label = LETTERS[1:3],\n  option = list(c(\n    \"None\" = \"0\", \n    \"A Little\" = \"1\",\n    \"A lot\" = \"2\"\n  ))\n)\n\n# Generate questions\nshiny::tagList(\n  purrr::map(1:nrow(items), function(i) {\n    args &lt;- items[i, ]\n    sd_question(\n      id     = as.character(args$id),\n      type   = args$type,\n      label  = args$label,\n      option = unlist(args$option)\n    )\n  })\n)\n```\n\n\n\n\n\n\n\nA\n\n\n\n\nNone\n\n\n\n\nA Little\n\n\n\n\nA lot\n\n\n\n\n*\n\n\n\nB\n\n\n\n\nNone\n\n\n\n\nA Little\n\n\n\n\nA lot\n\n\n\n\n*\n\n\n\nC\n\n\n\n\nNone\n\n\n\n\nA Little\n\n\n\n\nA lot\n\n\n\n\n*",
    "crumbs": [
      "Documentation",
      "Other",
      "Tips"
    ]
  },
  {
    "objectID": "docs/survey-settings.html",
    "href": "docs/survey-settings.html",
    "title": "Survey Settings",
    "section": "",
    "text": "surveydown provides 2 ways of configuring survey settings:\nWe chose to use YAML header keys in our templates, and we intentionally made them verbose to demonstrate all available options. If you prefer using sd_server(), you can call ?sd_server() to see all available options.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "Survey Settings"
    ]
  },
  {
    "objectID": "docs/survey-settings.html#option-1-yaml-in-survey.qmd-recommended",
    "href": "docs/survey-settings.html#option-1-yaml-in-survey.qmd-recommended",
    "title": "Survey Settings",
    "section": "Option 1: YAML in survey.qmd (Recommended)",
    "text": "Option 1: YAML in survey.qmd (Recommended)\nThis is a comprehensive list of all survey configuration settings that can be defined in the YAML header of the survey.qmd file.\n# General Settings - Must Have\nformat: html\necho: false\nwarning: false\n\n# Theme Settings\ntheme: default\nbarcolor: \"#768692\"\nbarposition: top\nfooter: Footer Text\nfooter-left: Footer Left Test\nfooter-center: Footer Center Test\nfooter-right: Footer Right Test\n\n# Survey Settings - Compatible with sd_server() arguments\nuse-cookies: true\nauto-scroll: false\nrate-survey: false\nsystem-language: en\nhighlight-unanswered: true\nhighlight-color: gray\ncapture-metadata: true\nstart-page: page_1\nall-questions-required: false\nrequired-questions:\n  - question_1\n  - question_2\nThe General Settings are standard Quarto options. Our format is set to html, indicating a web-based survey. The echo and warning options are set to false to suppress code and warning messages in the survey output.\nThe Theme Settings control the visual appearance of the survey. You can customize the theme, position of the progress bar, and footer text. Notice that footer is equivalent to footer-center.\nThe Survey Settings section includes various options to customize the survey behavior, such as enabling cookies, auto-scrolling, survey rating, system language, highlighting unanswered questions, capturing metadata, and specifying required questions.\n\n\n\n\n\n\nNote\n\n\n\nBoth Theme Settings and Survey Settings YAML keys can be written with underscores (_) or hyphens (-), so that use-cookies and use_cookies are interchangeable.\nIn YAML keys, you have 2 ways to represent boolean values: true/false or yes/no. Both are acceptable. For true/false, you can also use capitalized versions: True/False.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "Survey Settings"
    ]
  },
  {
    "objectID": "docs/survey-settings.html#option-2-sd_server-in-app.r",
    "href": "docs/survey-settings.html#option-2-sd_server-in-app.r",
    "title": "Survey Settings",
    "section": "Option 2: sd_server() in app.R",
    "text": "Option 2: sd_server() in app.R\nAlternatively, you can configure survey settings using the sd_server() function in the app.R file, under the server function definition. The server() function is a standard Shiny server function that takes input, output, and session as arguments.\nDefine your sd_server() like this:\n\nserver &lt;- function(input, output, session) {\n  sd_server(\n    db = db, # Left out from YAML\n    use_cookies = TRUE,\n    auto_scroll = FALSE,\n    rate_survey = FALSE,\n    language = \"en\",\n    highlight_unanswered = TRUE,\n    highlight_color = \"gray\",\n    capture_metadata = TRUE,\n    start_page = \"page_1\",\n    all_questions_required = FALSE,\n    required_questions = c(\"question_1\", \"question_2\")\n  )\n}\n\nAbove are the equivalent settings to those defined in the YAML header example. Note that the db argument is not available in the YAML header and must be specified in sd_server() if you are using a database connection.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "Survey Settings"
    ]
  },
  {
    "objectID": "docs/survey-settings.html#setting-explanations",
    "href": "docs/survey-settings.html#setting-explanations",
    "title": "Survey Settings",
    "section": "Setting explanations",
    "text": "Setting explanations\nAppearance settings\nBecause the survey.qmd is a Quarto document, you can use any of the Quarto formatting options to change the appearance of your survey.\nFor example, you can change the overall survey theme using the theme key:\n---\ntheme: united # Any bootswatch theme \n---\nThere are 25 bootswatch themes to choose from. You can also provide a custom.scss file to further modify the theme, or even combine the two, e.g.:\n---\ntheme: [united, custom.scss]\n---\nProgress bar\nYou can modify the survey progress bar with the barcolor and barposition keys, e.g.:\n---\nbarcolor: \"#768692\"\nbarposition: top \n---\nThe barcolor key defines the color of the progress bar. It defaults to the primary theme color, but you can change it to any hex code you wish here to overwrite the theme color.\nThe barposition key defines the position of the progress bar. It defaults to top, but can also be changed to bottom or none (to remove the bar). The progress bar updates on every question the user clicks on, not pages.\nFooter\nYou can customize the footer text using the footer, footer-left, footer-center, and footer-right keys.\nIf you only want to set a centered footer text, use the footer key, like this:\n---\nfooter: This is your centered footer text.\n---\nOr, you can customize the left, center, and right footer texts separately using the footer-left, footer-center, and footer-right keys, like this:\n---\nfooter-left: Footer Left Test\nfooter-center: Footer Center Test\nfooter-right: Footer Right Test\n---\nCookies\nCookies are used to store user sessions, including their session ID, survey data storage (backend), and their survey progress (frontend).\nDefine your cookies like this in YAML:\n---\nuse-cookies: true\n---\nBy default, the cookies are enabled. You can disable the cookies by changing the YAML key to false.\nAuto scroll\nThe auto scroll feature allows the page to automatically scroll according to the user’s working progress.\nDefine auto scroll like this in YAML:\n---\nauto-scroll: true\n---\nBy default, auto scroll is disabled.\nSurvey rating\nYou may want to add a survey rating question by the end of the survey to collect user reflections. Simply set rate-survey to true (Default to false) in YAML:\n---\nrate-survey: true\n---\nBy default, survey rating is disabled.\nSurvey rating is triggered by the “Exit Survey” button by the end of the survey. If you want to implement the survey rating, make sure you define the Exit Button by the end of the survey using the sd_close() function.\nBelow are the true and false cases for rate-survey:\n\n\nTRUE\nFALSE\n\n\n\nIf rate-survey is true, a survey rating question will pop up:\n\n\n\n\n\nIf rate-survey is false, a confirm exit dialog box will pop up:\n\n\n\n\n\n\nSystem language\nTo systematically display the preset system messages and button text elements in a different language, change the system language using a different country code.\nBy default, the system language is set to English (en):\n---\nsystem-language: en\n---\nSix languages are internally supported by surveydown:\n\nEnglish (en)\nGerman (de)\nSpanish (es)\nFrench (fr)\nItalian (it)\nChinese (zh-CN)\n\nBelow is an example of the system language set to Spanish (es):\n\n\n\n\nYou can also customize the system language. See the System Translations page for more details.\nHighlight unanswered questions\nYou can highlight unanswered questions to help respondents identify which questions they have not answered yet:\n---\nhighlight-unanswered: true\nhighlight-color: gray\n---\nBy default, highlighting unanswered questions is enabled. You can disable this feature by setting highlight-unanswered to false.\nBy default, the highlight color is set to gray (equivalent to grey). We also provide 4 other colors: blue, orange, green, and purple.\nBelow is an example of unanswered questions being highlighted in gray:\n\n\n\nChanged to blue:\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nWe auto-trigger red highlighting for required questions that are not answered, if the respondent attempts to click on the “Next” button without answering them, regardless of the highlight-unanswered setting.\n\n\nCapture metadata\nsurveydown supports metadata capturing. If enabled, the data sheet will show columns of browser and ip_address, in which browser contains information of the respondent’s browser name, version, and operating system, and ip_address shows the respondent’s IP address. To enable metadata capturing, set capture-metadata to true in YAML:\n---\ncapture-metadata: true\n---\nBy default, metadata capturing is enabled.\nStart page\nWhen editing your survey, it can be helpful to start the survey at a specific page. You can define the start page in YAML like this:\n---\nstart-page: page_1\n---\nBy default, the survey starts at the first page.\nRequired questions\nBy default, no questions are required. We provide 2 YAML keys to define required questions:\nFirstly, set all-questions-required to true to make all questions required:\n---\nall-questions-required: true\n---\nBy default, all-questions-required is set to false.\nSecondly, use required-questions to provide a list of question IDs to make specific questions required:\n---\nrequired-questions:\n  - question_1\n  - question_2\n---\nThe questions set to required will make the respondent unable to proceed until they have answered all of them on the current page. It will also place a red asterisk (*) next to the question label to indicate that the question is required.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "Survey Settings"
    ]
  },
  {
    "objectID": "docs/security.html",
    "href": "docs/security.html",
    "title": "Security",
    "section": "",
    "text": "There are three main security considerations when working with a surveydown survey:\nWhile we have worked to make our application code secure, it is ultimately up to you to choose appropriate host and data storage environments that are also secure for your needs.",
    "crumbs": [
      "Documentation",
      "Deployment & Operations",
      "Security"
    ]
  },
  {
    "objectID": "docs/security.html#the-surveydown-application-code",
    "href": "docs/security.html#the-surveydown-application-code",
    "title": "Security",
    "section": "The surveydown application code",
    "text": "The surveydown application code\nThe application code refers to the resulting Shiny app generated from a surveydown survey. Since surveydown users will be collecting potentially sensitive data from survey respondents, we have tried to develop the platform with data security in mind. We have taken care to follow many best practices, such as using SQL injection prevention strategies in how we store the survey response data, and ensuring that users store their database credentials as a .env file that is also added to a .gitignore file. We also adopted an architecture where all content on any page in the survey is served entirely from the shiny server, meaning that respondents taking the survey cannot see the underlying html source code for any of the content being displayed in the survey. This is important so respondents cannot see content on other pages (e.g., completion codes) before getting there from the survey navigation buttons.\nDespite our efforts, however, we do not (yet) have any form of security compliance certificate that we can provide. This means we cannot guarantee the application code is compliant with common security protocols, such as SOC2 Type 2 or HIPPA. This is an eventual goal, but for now this is a limitation for using this package for some domains that require certain certifications.",
    "crumbs": [
      "Documentation",
      "Deployment & Operations",
      "Security"
    ]
  },
  {
    "objectID": "docs/security.html#the-hosting-environment",
    "href": "docs/security.html#the-hosting-environment",
    "title": "Security",
    "section": "The hosting environment",
    "text": "The hosting environment\n\nShinyapps.io\nThe free service we use for hosting a surveydown survey is shinyapps.io, which is not HIPPA compliant. According to the Posit Documentation on Security and Compliance for shinyapps.io:\n\nshinyapps.io is currently hosted on Amazon’s Web Services (AWS) infrastructure in the us-east-1 region. The infrastructure used is not the HIPAA-compliant stack, so if you need to be in a HIPAA-compliant environment, we recommend deploying and operating your own Posit Connect or Shiny Server Open Source instance.\n\nThis means that if you require a HIPPA compliant hosting service, we recommend that follow Posit’s guidelines and deploy your own instance of Posit Connect.\n\n\nOther Hosting Services\nYou can deploy shiny apps to other hosting services. Here are some guides for several other alternatives:\n\nPosit Connect Cloud\nHugging Face\nHeroku\n\nYou can also install Posit Connect on your own server, which is the recommended approach for remaining compliant with any security protocols your organization requires.\nWhatever hosting service you choose, please read carefully about the security implications of the environment you choose.",
    "crumbs": [
      "Documentation",
      "Deployment & Operations",
      "Security"
    ]
  },
  {
    "objectID": "docs/security.html#the-data-storage-environment",
    "href": "docs/security.html#the-data-storage-environment",
    "title": "Security",
    "section": "The data storage environment",
    "text": "The data storage environment\nWe designed surveydown to be able to store data on any PostgreSQL database. This gives you flexibility on where you choose to store your data, and it is up to you to find a suitable host.\nFortunately, the default service we recommend using (Supabase) is actually SOC2 Type 2 and HIPPA compliant 🎉\nAs with the hosting service, please choose a data storage environment carefully and read about the security implications of the environment you choose.",
    "crumbs": [
      "Documentation",
      "Deployment & Operations",
      "Security"
    ]
  },
  {
    "objectID": "docs/randomization.html",
    "href": "docs/randomization.html",
    "title": "Randomization",
    "section": "",
    "text": "This page explains how to show a question with randomized labels (unique labels for each respondent). While this is not the only use case for randomization, it illustrates in general how to implement something where each respondent sees something unique to their survey.\nThe key is to define anything random in the server (app.R file), not the survey (survey.qmd file). If you define a value or question in the survey.qmd file, it will be the same for every respondent.\nBefore reading this, we suggest you first read the reactivity manual to get a general understanding of how reactivity works in surveydown.",
    "crumbs": [
      "Documentation",
      "Interactivity",
      "Randomization"
    ]
  },
  {
    "objectID": "docs/randomization.html#live-randomization",
    "href": "docs/randomization.html#live-randomization",
    "title": "Randomization",
    "section": "Live randomization",
    "text": "Live randomization\nOne approach is to generate the random labels in the server function “live”, meaning that the labels will be generated when the survey is first loaded. For example, let’s say in my server function I generate three random numbers between 1 and 100 and use them to create the option labels for a multiple choice question:\n\n# Create a vector of options\nq1_options &lt;- c('option 1', 'option 2', 'option 3')\n\n# Randomly sample 3 labels from 1 to 100\nq1_labels &lt;- sample(seq(100), 3) \n\n# Assign the labels to the options\nnames(q1_options) &lt;- q1_labels \n\nq1_options\n\n#&gt;         49         65         25 \n#&gt; \"option 1\" \"option 2\" \"option 3\"\n\n\nRemember that the names of the vector are the labels, so the respondents will see the numbers in the names of the above vector, and the values ('option1', etc.) will be stored in the resulting survey data.\nTo then use these options in a multiple choice question, you would use the sd_question() function also in the server function (not in the survey.qmd file) like this:\n\nsd_question(\n  id = \"q1\",\n  type = \"mc\",  \n  label = \"Which of these numbers is the largest?\",\n  option = q1_options\n)\n\nBy defining this question inside the server function, the question will be created as a reactive question that can then be displayed in the survey.qmd file using the sd_output() function, like this:\n\n```{r}\nsd_output(id = \"q1\", type = \"question\")\n```\n\nOne important caveat to this approach is that the random numbers that are generated are not automatically stored in the survey data (because they are generated live). If you needed to store the random numbers, you can use the sd_store_value() function, like this:\n\nsd_store_value(q1_labels, id = \"q1_labels\")\n\nThis would store the numbers in the q1_labels column of the survey data, which would be concatenated into the single string: 49, 65, 25.\nYou could alternatively use the sd_store_value() function to store each of the random numbers in separate columns, like this:\n\nsd_store_value(q1_labels[1], id = \"q1_label_1\")\nsd_store_value(q1_labels[2], id = \"q1_label_2\")\nsd_store_value(q1_labels[3], id = \"q1_label_3\")",
    "crumbs": [
      "Documentation",
      "Interactivity",
      "Randomization"
    ]
  },
  {
    "objectID": "docs/randomization.html#predefined-randomization",
    "href": "docs/randomization.html#predefined-randomization",
    "title": "Randomization",
    "section": "Predefined randomization",
    "text": "Predefined randomization\nAn alternative approach is to predefine the randomized labels and store them in a separate design file, and then randomly select a set of labels for each respondent from the design file.\nFor example, let’s generate 10 sets of 3 random numbers between 1 and 100 and store them in a data frame:\n\ndesign &lt;- data.frame(\n  id = rep(1:10, each = 3),\n  numbers = unlist(lapply(1:10, function(x) sample(seq(100), 3)))\n)\n\nhead(design)\n\n#&gt;   id numbers\n#&gt; 1  1      74\n#&gt; 2  1      18\n#&gt; 3  1      49\n#&gt; 4  2      47\n#&gt; 5  2      24\n#&gt; 6  2      71\n\n\nNow we can write this design to a csv file:\n\nreadr::write_csv(design, \"design.csv\")\n\nThen in your server function in the app.R file, you could read in the design file and use it to randomize the labels for each question. Here the only thing you would need to keep track of the randomly chosen row id:\n\n# Read in the design file\ndesign &lt;- readr::read_csv(\"design.csv\")\n\n# Randomly choose a row id\nq1_id &lt;- sample(design$id, 1)\n\n# Store the chosen row id in the survey data (here q1_id will be the column name)\nsd_store_value(q1_id) \n\n# Filter the design to get the chosen row\nnumbers &lt;- design |&gt; \n  filter(id == q1_id) |&gt; \n  pull(numbers)\n\n# Create the options\nq1_options &lt;- c('option 1', 'option 2', 'option 3')\nnames(q1_options) &lt;- numbers\n\n# Create the reactive question\nsd_question(\n  id = \"q1\",\n  type = \"mc\",  \n  label = \"Which of these numbers is the largest?\",\n  option = q1_options\n)\n\nOnce again, you would be able to then display this question in the survey.qmd file using the sd_output() function:\n\n```{r}\nsd_output(id = \"q1\", type = \"question\")\n```",
    "crumbs": [
      "Documentation",
      "Interactivity",
      "Randomization"
    ]
  },
  {
    "objectID": "docs/question-formatting.html",
    "href": "docs/question-formatting.html",
    "title": "Question Formatting",
    "section": "",
    "text": "The sd_question() function has many optional arguments for modifying the appearance and behavior of questions. This page demonstrates some of the formatting options.",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Formatting"
    ]
  },
  {
    "objectID": "docs/question-formatting.html#markdown-formatting",
    "href": "docs/question-formatting.html#markdown-formatting",
    "title": "Question Formatting",
    "section": "Markdown formatting",
    "text": "Markdown formatting\nMarkdown is supported for question labels and option labels.\nQuestion labels\nThe label argument for any question type can accept markdown formatting. For example, the question below uses the * symbol to make some words bold, italic, and bold italic.\n\n\nCode chunk\nOutput\n\n\n\n\n```{r}\nsd_question(\n  type   = 'mc',\n  id     = 'markdown_label',\n  label  = \"**This** is a question *label* supporting ***markdown***:\",\n  option = c(\n    \"Option A\" = \"option_a\",\n    \"Option B\" = \"option_b\",\n    \"Option C\" = \"option_c\"\n  )\n)\n```\n\n\n\n\n\n\n\nThis is a question label supporting markdown:\n\n\n\n\nOption A\n\n\n\n\nOption B\n\n\n\n\nOption C\n\n\n\n\n*\n\n\n\n\n\n\nOption labels\nMarkdown formatting is also supported for the option labels in question types that have options, such as mc, mc_multiple, mc_buttons, and mc_multiple_buttons. For example:\n\n\nCode chunk\nOutput\n\n\n\n\n```{r}\nsd_question(\n  type   = 'mc_buttons',\n  id     = 'markdown_buttons',\n  label  = \"The 3 options below support markdown:\",\n  option = c(\n    \"*Option A*\"     = \"option_a\",\n    \"**Option B**\"   = \"option_b\",\n    \"***Option C***\" = \"option_c\"\n  )\n)\n```\n\n\n\n\n\n\n\nThe 3 options below support markdown:\n\n\n\nOption A\nOption B\nOption C\n\n\n\n\n*",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Formatting"
    ]
  },
  {
    "objectID": "docs/question-formatting.html#html-formatting",
    "href": "docs/question-formatting.html#html-formatting",
    "title": "Question Formatting",
    "section": "HTML formatting",
    "text": "HTML formatting\nHTML formatting is supported for the option labels in question types that have options, such as mc_buttons and mc_multiple_buttons. This allows you to insert mixed content to achieve more complex labels, including plain text, markdown, and HTML code.\nFor example, here is a question with some complex labels for a choice question that include markdown and HTML code to embed images.\n\n\nCode chunk\nOutput\n\n\n\n\n```{r}\n# Define the option vector\nhtml_button_options &lt;- c(\"option_1\", \"option_2\", \"option_3\")\n\n# Define option labels that include markdown and HTML code to embed images\nnames(html_button_options) &lt;- c(\n\n  \"**Option 1**&lt;br&gt;\n   &lt;img src='https://github.com/surveydown-dev/demos/blob/main/conjoint-buttons/images/fuji.jpg?raw=true' width=100&gt;&lt;br&gt;\n   **Type**: Fuji&lt;br&gt;\n   **Price**: $ 2 / lb&lt;br&gt;\n   **Freshness**: Average\",\n\n  \"**Option 2**&lt;br&gt;\n   &lt;img src='https://github.com/surveydown-dev/demos/blob/main/conjoint-buttons/images/pinkLady.jpg?raw=true' width=100&gt;&lt;br&gt;\n    **Type**: Pink Lady&lt;br&gt;\n    **Price**: $ 1.5 / lb&lt;br&gt;\n    **Freshness**: Excellent\",\n\n  \"**Option 3**&lt;br&gt;\n    &lt;img src='https://github.com/surveydown-dev/demos/blob/main/conjoint-buttons/images/honeycrisp.jpg?raw=true' width=100&gt;&lt;br&gt;\n    **Type**: Honeycrisp&lt;br&gt;\n    **Price**: $ 2 / lb&lt;br&gt;\n    **Freshness**: Poor\"\n)\n\nsd_question(\n  type   = 'mc_buttons',\n  id     = 'html_buttons',\n  label  = \"A sample survey question using `mc_buttons`\",\n  option = html_button_options\n)\n```\n\n\n\n\n\n\n\nA sample survey question using mc_buttons\n\n\n\nOption 1Type: FujiPrice: $ 2 / lbFreshness: Average\nOption 2Type: Pink LadyPrice: $ 1.5 / lbFreshness: Excellent\nOption 3Type: HoneycrispPrice: $ 2 / lbFreshness: Poor\n\n\n\n\n*",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Formatting"
    ]
  },
  {
    "objectID": "docs/question-formatting.html#size-formatting",
    "href": "docs/question-formatting.html#size-formatting",
    "title": "Question Formatting",
    "section": "Size formatting",
    "text": "Size formatting\nUse the width, height arguments to change the size of the question.\nFor example, the question below uses the width and height arguments to change the size of a text area question.\n\n\nCode chunk\nOutput\n\n\n\n\n```{r}\nsd_question(\n  type  = \"textarea\",\n  id    = \"change_width\",\n  label = \"This text area has width set as 40% and height set as 100px:\",\n  width = \"40%\", \n  height = \"100px\"\n)\n```\n\n\n\n\n\n\n\nThis text area has width set as 40% and height set as 100px:\n\n\n\n*",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Formatting"
    ]
  },
  {
    "objectID": "docs/page-navigation.html",
    "href": "docs/page-navigation.html",
    "title": "Page Navigation",
    "section": "",
    "text": "This page discusses how to create pages and navigate between them in a surveydown survey.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "Page Navigation"
    ]
  },
  {
    "objectID": "docs/page-navigation.html#defining-pages",
    "href": "docs/page-navigation.html#defining-pages",
    "title": "Page Navigation",
    "section": "Defining pages",
    "text": "Defining pages\nIn surveydown, pages are defined using fences (:::), like this:\n\n::: {.sd_page id=page1}\n\nPage 1 content here\n\n:::\n\n::: {.sd_page id=page2}\n\nPage 2 content here\n\n:::\n\nWe use three colon symbols :::, called a “fence”, to mark the start and end of pages. This notation is commonly used in Quarto for a variety of use cases, like defining subfigures in images.\nIn the starting fence, you need to define the class as .sd_page and provide a page id (e.g. welcome and page2 in the example above). Then anything you put between the page fences will appear on that page.\nIf you are using RStudio, you can also make use of the page gadget to create pages under the “Addins” dropdown menu. You can easily link the gadget with a keyboard shortcut from the “Tools” menu. Check out this blog post for a detailed walkthrough.\nHere is what the Survey Page Gadget looks like in RStudio:",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "Page Navigation"
    ]
  },
  {
    "objectID": "docs/page-navigation.html#adding-navigation-buttons",
    "href": "docs/page-navigation.html#adding-navigation-buttons",
    "title": "Page Navigation",
    "section": "Adding navigation buttons",
    "text": "Adding navigation buttons\nTo navigate to the next page, you need to insert a sd_next() function call inside a code chunk, like this:\n\n```{r}\nsd_next()\n```\n\nThe above code chunk will create a “Next” button that goes on to the immediate next page. The button will look like this:\n\n\n\nNext\n\n\n\nYou can also provide an alternative label on the next page button using the label argument, like this:\n\n```{r}\nsd_next(label = \"Go to the next page\")\n```\n\n\n\n\nGo to the next page",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "Page Navigation"
    ]
  },
  {
    "objectID": "docs/page-navigation.html#skipping-forward",
    "href": "docs/page-navigation.html#skipping-forward",
    "title": "Page Navigation",
    "section": "Skipping Forward",
    "text": "Skipping Forward\nDirect Forward Skipping\nYou can send the survey respondent to other forward pages by changing the value assigned to the next_page argument in the sd_next() function. For example, to send the user to a page with the id page3, you can use:\n\n```{r}\nsd_next(next_page = 'page3')\n```\n\nConditional Forward Skipping\nWhile basic page navigation is handled using sd_next(), you can override this static navigation in your server function with the sd_skip_if() function to send the respondent to a forward page based on some condition.\nA common example is the need to screen out people based on their response(s) to a question. Let’s say you need to screen out people who do not own a vehicle. To do this, you would first define a question in your survey.qmd file about their vehicle ownership, e.g.:\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'vehicle_ownership',\n  label = \"Do you own your vehicle?\",\n  option = c(\n    'Yes' = 'yes',\n    'No'  = 'no'\n  )\n)\n```\n\nYou would also need to define a screenout page to send respondents to, like this:\n\n::: {.sd_page id=screenout}\n\nSorry, but you are not qualified to take our survey.\n\n:::\n\nThen in the server function in the app.R file, you can use the sd_skip_if() function to define the condition under which the respondent will be sent to the target screenout page, like this:\n\n\n\n\n\n\nNote\n\n\n\nThe input object is a Shiny object that stores each question id defined by sd_question() in your survey.qmd file, so whenever referring to a question in a condition, you must use the format input$question_id.\n\n\n\nserver &lt;- function(input, output, session) {\n\n  sd_skip_if(\n    input$vehicle_ownership == \"no\" ~ \"screenout\"\n  )\n\n  # ...other server code...\n\n}\n\nYou can provide multiple conditions to the sd_skip_if() function, each separated by a comma. The structure for each condition is always:\n\n&lt;condition&gt; ~ \"target_page_id\"\n\nIn the example above, input$vehicle_ownership == \"no\" is the condition, and \"screenout\" is the target page that the respondent will be sent to if the condition is met.\nTake a look at the Common Conditions section for examples of other types of supported conditions you can use to conditionally control the survey flow.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "Page Navigation"
    ]
  },
  {
    "objectID": "docs/getting-started.html",
    "href": "docs/getting-started.html",
    "title": "Getting Started",
    "section": "",
    "text": "This page covers everything you need to get started making a survey with surveydown.",
    "crumbs": [
      "Documentation",
      "Survey Basics",
      "Getting Started"
    ]
  },
  {
    "objectID": "docs/getting-started.html#overview",
    "href": "docs/getting-started.html#overview",
    "title": "Getting Started",
    "section": "Overview",
    "text": "Overview\nEvery surveydown survey is composed of a survey and an app, defined in two separate files:\n\n\nsurvey.qmd: A Quarto document that contains the survey content (pages, questions, etc), which renders to an HTML file.\n\napp.R: An R script defining a Shiny app that contains the global settings (libraries, database configuration, etc.) and server configuration options (e.g., conditional page skipping / question display, etc.).\n\nThese files must be named survey.qmd and app.R.\nThe surveydown R package provides a set of functions for defining the survey content and configuration options. Each function starts with sd_ to make them easy to identify.\nThe platform is based on some basic principles:\n\nAdd content to your survey.qmd file using markdown text (or in RStudio use the visual editor).\nDefine survey questions in R code chunks with the sd_question() function.\nDefine pages using fences (:::), with navigation buttons handled using the sd_next() function.\nAdd rich functionality to your survey using a variety of Survey Settings in the server() function in the app.R file.\nApply Conditional Logic to question display with sd_show_if() or page navigation with sd_skip_forward().\nStore your respondent data in a database (see Storing Data).\n\nThis approach ensures a flexible survey platform that is fully reproducible and easy to customize.\nThe remaining steps on this page will guide you through the process of creating a surveydown survey.",
    "crumbs": [
      "Documentation",
      "Survey Basics",
      "Getting Started"
    ]
  },
  {
    "objectID": "docs/getting-started.html#install",
    "href": "docs/getting-started.html#install",
    "title": "Getting Started",
    "section": "1. Install",
    "text": "1. Install\nInstall R & Quarto\nYou need both:\n\nInstall \n\nInstall Quarto\n\n\nWe also recommend working with an IDE that has good support for R, Quarto, and Shiny.\nRStudio is great, and we also like VSCode and Positron.\nInstall the {surveydown} R package\nYou can install {surveydown} from CRAN in your R console:\n\ninstall.packages(\"surveydown\")\n\nor you can install the development version from GitHub:\n\n# install.packages(\"pak\")\npak::pak(\"surveydown-dev/surveydown\")\n\nLoad the package with:\n\nlibrary(surveydown)\n\nYou can also check which version you have installed:\n\nsurveydown::sd_version()",
    "crumbs": [
      "Documentation",
      "Survey Basics",
      "Getting Started"
    ]
  },
  {
    "objectID": "docs/getting-started.html#start-with-a-template",
    "href": "docs/getting-started.html#start-with-a-template",
    "title": "Getting Started",
    "section": "2. Start with a template",
    "text": "2. Start with a template\n\n\n\n\n\n\nNote\n\n\n\nEvery survey created with surveydown should be in its own separate project folder.\n\n\nWe recommend starting with a template to build your first surveydown survey. In the R console, run the following to to setup a generic template survey:\n\nsurveydown::sd_create_survey()\n\nYou can also specify where you want the template survey to be created using the path argument, and you can also specify which template to use with the template argument, like this:\n\nsurveydown::sd_create_survey(\n  path     = \"path/to/folder\",\n  template = \"question_types\"\n)\n\nThe default is template = \"default\", but you can specify other templates. See the Templates page for an overview of all currently available templates.",
    "crumbs": [
      "Documentation",
      "Survey Basics",
      "Getting Started"
    ]
  },
  {
    "objectID": "docs/getting-started.html#add-survey-content",
    "href": "docs/getting-started.html#add-survey-content",
    "title": "Getting Started",
    "section": "3. Add survey content",
    "text": "3. Add survey content\nSurvey content is edited in the survey.qmd file. See the Basic Components page for more details on how to add more content to a surveydown survey. At a minimum, you can add pages and questions like this:\n\n\nAdd pages with fences, like this:\n\n::: {.sd_page id=page1}\n\nPage 1 content here\n\n:::\n\n\n\nAdd questions with the sd_question() function in code chunks (see the Question Types page for more on the types of questions supported). For example, here’s a multiple choice question:\n\n\nCode chunk\nOutput\n\n\n\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'penguins',\n  label = \"Which is your favorite type of penguin?\",\n  option = c(\n    'Adélie'    = 'adelie',\n    'Chinstrap' = 'chinstrap',\n    'Gentoo'    = 'gentoo'\n  )\n)\n```\n\n\n\n\n\n\n\nWhich is your favorite type of penguin?\n\n\n\n\nAdélie\n\n\n\n\nChinstrap\n\n\n\n\nGentoo\n\n\n\n\n*",
    "crumbs": [
      "Documentation",
      "Survey Basics",
      "Getting Started"
    ]
  },
  {
    "objectID": "docs/getting-started.html#add-control-options",
    "href": "docs/getting-started.html#add-control-options",
    "title": "Getting Started",
    "section": "4. Add control options",
    "text": "4. Add control options\nIn the server() function in the app.R file, add rich functionality to your survey using a variety of Survey Settings or Conditional Logic.",
    "crumbs": [
      "Documentation",
      "Survey Basics",
      "Getting Started"
    ]
  },
  {
    "objectID": "docs/getting-started.html#setup-your-database-connection",
    "href": "docs/getting-started.html#setup-your-database-connection",
    "title": "Getting Started",
    "section": "5. Setup your database connection",
    "text": "5. Setup your database connection\nSetup your database connection using the sd_db_config() function. Once your configuration credentials are created (they get saved in a .env file), make a connection to your database using the sd_db_connect() function in the global settings at the top of the app.R file. You can also use sd_db_connect(ignore = TRUE) to run the survey without storing data. See the Storing Data page for more details.",
    "crumbs": [
      "Documentation",
      "Survey Basics",
      "Getting Started"
    ]
  },
  {
    "objectID": "docs/getting-started.html#locally-preview",
    "href": "docs/getting-started.html#locally-preview",
    "title": "Getting Started",
    "section": "6. Locally preview",
    "text": "6. Locally preview\nPreview your survey by clicking the “Run App” button in RStudio or in your R console running the runApp() command.",
    "crumbs": [
      "Documentation",
      "Survey Basics",
      "Getting Started"
    ]
  },
  {
    "objectID": "docs/getting-started.html#deploy",
    "href": "docs/getting-started.html#deploy",
    "title": "Getting Started",
    "section": "7. Deploy",
    "text": "7. Deploy\nDeploy your survey by hosting it on your favorite server, like shinyapps.io, HuggingFace, Posit Connect Cloud, Heroku, etc. See the Deployment page for more details.",
    "crumbs": [
      "Documentation",
      "Survey Basics",
      "Getting Started"
    ]
  },
  {
    "objectID": "docs/features-roadmap.html",
    "href": "docs/features-roadmap.html",
    "title": "Features & Roadmap",
    "section": "",
    "text": "Feature\nDocs\nVersion\nDiscussion\n\n\n\nWide variety of question types\nQuestion Types\nv0.0.1\n\n105, 109\n\n\n\nConditionally show questions\nConditional Display\nv0.0.1\n\n\n\nMarkdown formatting for options and buttons\nMarkdown Formatting\nv0.0.1\n\n\n\nRequire specific questions or all questions be answered\nRequired Questions\nv0.0.2\n\n\n\nSupport for bootstrap themes\nThemes\nv0.0.4\n\n\n\nCustomizable scss theme file\nThemes\nv0.0.4\n\n\n\nAbility to Ignore the database connection\nSupabase Ignore\nv0.0.8\n\n\n\nTime stamps recorded for each question and page interaction\n\nv0.0.9\n\n\n\nProgress bar that updates on each question interaction\nProgress Bar\nv0.0.9\n\n\n\nCustomizable progress bar color and position on page\nProgress Bar\nv0.0.9\n\n\n\nAbility to use latest survey results in the survey itself\nFetching Data\nv0.1.1\n\n\n\nPass parameters through the url e.g. to track user IDs\nReactive Redirect\nv0.2.2\n92\n\n\nRedirect users to an external url\nExternal Redirect\nv0.2.2\n\n\n\nStart the survey from a specific page (helpful when editing survey)\nStarting Page\nv0.3.0\n\n\n\nCreate a random numeric completion code\nCompletion Code\nv0.3.2\n\n\n\nAuto scroll according to the answering progress\nAuto Scroll\nv0.3.3\n104\n\n\nCustom languages / messages for system messages\nSystem Translations\nv0.4.2\n134\n\n\nStore session ID in browser cookies to store user progress if they refresh the page\nCookies\nv0.6.0\n\n\n\nCustom question type to enable custom html widgets\nCustom Questions\nv0.7.2\n111\n\n\nDashboard page with password login to preview / download data / pause survey, etc.\nDashboard\nv0.8.0\n\n\n\nFooter on every survey page\n\nv0.8.0\n\n\n\nConditionally skip to a forward page with skip_forward()\n\nConditional Logic\nv0.9.0\nIssue 169\n\n\nDefine questions using an external yml file\nDefining Questions\nv0.11.0\n132\n\n\nConditionally show pages\nConditional Display\nv0.11.1\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n      \n\n\nFeature\nDocs\nVersion\nDiscussion\n\n\n\nForm validation (limit input based on question type, limit value range for numeric type)\n\n\n125\n\n\nQuestion type - Best worst\n\n\n127\n\n\nQuestion type - Single checkbox with on and off toggle switches\nshinyWidgets - Single Checkbox\n\n\n\n\nQuestion type - Tree inputs\nshinyWidgets - Tree\n\n\n\n\nQuestion type of select menu - Dropdown select type with multiple selections\nshinyWidgets - Select Menu\n\n\n\n\n\nsd_store_data() function - store any values generated after survey launches in the db\n\n\n\n178\n\n\nTrigger print to pdf mode, e.g., sd_server(print_mode = TRUE)\n\n\n\nLook at {renderthis}\n\n\nClipboard problem - quarto-html-after-body div in quarto\n\n\n\n\n\nEnter key JS bug - not working if a conditional problem is shown\n\n\n\n\n\nAbility to skip backwards (debated if needed)\n\n\nIssue 169\n\n\nBug - cannot make matrix questions required\n\n\nIssue 170\n\n\nMake the gssencmode argument optional in sd_db_connect()\n\n\n\nIssue 174",
    "crumbs": [
      "Documentation",
      "Features & Roadmap"
    ]
  },
  {
    "objectID": "docs/features-roadmap.html#surveydown-package",
    "href": "docs/features-roadmap.html#surveydown-package",
    "title": "Features & Roadmap",
    "section": "",
    "text": "Feature\nDocs\nVersion\nDiscussion\n\n\n\nWide variety of question types\nQuestion Types\nv0.0.1\n\n105, 109\n\n\n\nConditionally show questions\nConditional Display\nv0.0.1\n\n\n\nMarkdown formatting for options and buttons\nMarkdown Formatting\nv0.0.1\n\n\n\nRequire specific questions or all questions be answered\nRequired Questions\nv0.0.2\n\n\n\nSupport for bootstrap themes\nThemes\nv0.0.4\n\n\n\nCustomizable scss theme file\nThemes\nv0.0.4\n\n\n\nAbility to Ignore the database connection\nSupabase Ignore\nv0.0.8\n\n\n\nTime stamps recorded for each question and page interaction\n\nv0.0.9\n\n\n\nProgress bar that updates on each question interaction\nProgress Bar\nv0.0.9\n\n\n\nCustomizable progress bar color and position on page\nProgress Bar\nv0.0.9\n\n\n\nAbility to use latest survey results in the survey itself\nFetching Data\nv0.1.1\n\n\n\nPass parameters through the url e.g. to track user IDs\nReactive Redirect\nv0.2.2\n92\n\n\nRedirect users to an external url\nExternal Redirect\nv0.2.2\n\n\n\nStart the survey from a specific page (helpful when editing survey)\nStarting Page\nv0.3.0\n\n\n\nCreate a random numeric completion code\nCompletion Code\nv0.3.2\n\n\n\nAuto scroll according to the answering progress\nAuto Scroll\nv0.3.3\n104\n\n\nCustom languages / messages for system messages\nSystem Translations\nv0.4.2\n134\n\n\nStore session ID in browser cookies to store user progress if they refresh the page\nCookies\nv0.6.0\n\n\n\nCustom question type to enable custom html widgets\nCustom Questions\nv0.7.2\n111\n\n\nDashboard page with password login to preview / download data / pause survey, etc.\nDashboard\nv0.8.0\n\n\n\nFooter on every survey page\n\nv0.8.0\n\n\n\nConditionally skip to a forward page with skip_forward()\n\nConditional Logic\nv0.9.0\nIssue 169\n\n\nDefine questions using an external yml file\nDefining Questions\nv0.11.0\n132\n\n\nConditionally show pages\nConditional Display\nv0.11.1\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n      \n\n\nFeature\nDocs\nVersion\nDiscussion\n\n\n\nForm validation (limit input based on question type, limit value range for numeric type)\n\n\n125\n\n\nQuestion type - Best worst\n\n\n127\n\n\nQuestion type - Single checkbox with on and off toggle switches\nshinyWidgets - Single Checkbox\n\n\n\n\nQuestion type - Tree inputs\nshinyWidgets - Tree\n\n\n\n\nQuestion type of select menu - Dropdown select type with multiple selections\nshinyWidgets - Select Menu\n\n\n\n\n\nsd_store_data() function - store any values generated after survey launches in the db\n\n\n\n178\n\n\nTrigger print to pdf mode, e.g., sd_server(print_mode = TRUE)\n\n\n\nLook at {renderthis}\n\n\nClipboard problem - quarto-html-after-body div in quarto\n\n\n\n\n\nEnter key JS bug - not working if a conditional problem is shown\n\n\n\n\n\nAbility to skip backwards (debated if needed)\n\n\nIssue 169\n\n\nBug - cannot make matrix questions required\n\n\nIssue 170\n\n\nMake the gssencmode argument optional in sd_db_connect()\n\n\n\nIssue 174",
    "crumbs": [
      "Documentation",
      "Features & Roadmap"
    ]
  },
  {
    "objectID": "docs/features-roadmap.html#sdstudio-package",
    "href": "docs/features-roadmap.html#sdstudio-package",
    "title": "Features & Roadmap",
    "section": "\nsdstudio package",
    "text": "sdstudio package\nFeatures\n\n\n\n\n    \n\n      \n\n\nFeature\nDocs\nVersion\nDiscussion\n\n\n\nGUI support for survey construction with pre-defined templates\n\nv0.0.1\n\n\n\nDrag-n-drop for pages and contents\n\nv0.0.1\n\n\n\nDeleting and modifying for existing elements\n\nv0.0.1\n\n\n\nLive-preview of the working survey\n\nv0.0.1\n\n\n\nPackage renamed to sdstudio (used to be sdApps).\n\nv0.1.0\n\n\n\nLaunch the studio with sdstudio::launch().\n\nv0.1.0\n\n\n\n3 tabs: Build, Preview, and Responses.\n\nv0.1.0\n\n\n\nAll tabs support local and DB modes.\n\nv0.1.0\n\n\n\n\n\n\n\n\nTo Do\n\n\n\n\n    \n\n      \n\n\nFeature\nDocs\nVersion\nDiscussion\n\n\n\nSupport for martix type\n\n\n\n\n\nSupport for reactive questions\n\n\n\n\n\nSupport for conditional skipping and showing",
    "crumbs": [
      "Documentation",
      "Features & Roadmap"
    ]
  },
  {
    "objectID": "docs/external-redirect.html",
    "href": "docs/external-redirect.html",
    "title": "External Redirect",
    "section": "",
    "text": "Like other operations, there are also two types of redirection: static and reactive. A static redirect provides a hard-coded URL, like google.com, apple.com, etc. A reactive redirect grabs parameters from your survey URL and allows you to use them to construct a new redirect URL.\nWe recommend you try out our demo survey that showcases both static and reactive redirects so that you can have a full understanding of how this works:",
    "crumbs": [
      "Documentation",
      "Interactivity",
      "External Redirect"
    ]
  },
  {
    "objectID": "docs/external-redirect.html#static-redirect",
    "href": "docs/external-redirect.html#static-redirect",
    "title": "External Redirect",
    "section": "Static Redirect",
    "text": "Static Redirect\nIn your survey body, use the sd_redirect() function and define your parameters. Below is an example of a redirect button that goes to google.com.\n\n\nCode chunk\nOutput\n\n\n\n\n# Static redirect\nsd_redirect(\n  id     = \"redirect\",\n  url    = \"https://www.google.com\",\n  label  = \"Redirect to Google\",\n  button = TRUE,\n  newtab = TRUE\n)\n\n\n\n\n\n\n\nRedirect to Google",
    "crumbs": [
      "Documentation",
      "Interactivity",
      "External Redirect"
    ]
  },
  {
    "objectID": "docs/external-redirect.html#reactive-redirect",
    "href": "docs/external-redirect.html#reactive-redirect",
    "title": "External Redirect",
    "section": "Reactive Redirect",
    "text": "Reactive Redirect\nReactive redirect is essentially useful if you deploy your survey on survey panels like Prolific or Dynata. These survey panels usually use different IDs to identify survey respondents.\nTo make reactive redirect work, you need to edit both in your server chunk, and your survey body. We’ll use an example to explain the process. This is the same example in our demo survey.\nFirstly, in your server chunk, define url_normal. It is an reactive expression in Shiny apps. You’ll use the sd_get_url_pars() function to retrieve all the parameters in your survey URL, and concatenate with customized texts including id names, status values, etc. In this example, we defined 3 IDs: id_a, id_b, and id_c, which should be grabbed from your survey link.\n\n# Reactive expression that generates a url for a normal ending\nurl_normal &lt;- reactive({\n  params &lt;- sd_get_url_pars()\n  id_a &lt;- params[\"id_a\"]\n  id_b &lt;- params[\"id_b\"]\n  id_c &lt;- params[\"id_c\"]\n  return(paste0(\n    \"https://www.google.com?id_a=\", id_a,\n    \"&id_b=\", id_b,\n    \"&id_c=\", id_c,\n    \"&status=0\" # status of 0 indicates normal ending\n})\n\nSecondly, also in your server chunk, create the redirect button using sd_redirect(). Note that we passed url_normal() value, with a pair of parentheses, to the url parameter.\n\n# Create the redirect button for normal ending\nsd_redirect(\n  id = \"redirect_normal\",\n  url = url_normal(),\n  button = TRUE,\n  label = \"Redirect with Normal Status\"\n)\n\n\n\n\n\n\n\nTip\n\n\n\nYou may have noticed that we created url_normal, and then passed url_normal() to sd_redirect(). This is how Shiny app deals with reactivity. Here url_normal is created by reactive() and is called “reactive expression”. url_normal() is a string value containing the concatenated URL. In other words, the url_normal() value is the result of the url_normal expression.\n\n\nFinally, in your survey body, output this redirect_normal URL using the sd_output() function:\n\n# Put this in the desired place of your survey body\nsd_output(\"redirect_normal\")\n\nAfter all these are done, your sd_output() function will generate a button that redirects you to this link:\n\nhttps://www.google.com/?id_a=a123id_b=b234id_c=c345&status=0\n\n\n\n\n\n\n\nTip\n\n\n\nCount-down delay (only applies for static redirect):\n\n# count-down of 10 seconds\nsd_redirect(\n  # previous parameters...\n  delay  = 10\n)\n\nOpen at a new tab (applies for both static and reactive):\n\nsd_redirect(\n  # previous parameters...\n  newtab  = TRUE\n)\n\nIf newtab is used together with delay, the new tab opened after count-down might be blocked by the browser. We’ve tested it with Safari and Edge. It worked fine on Safari, but Edge blocks it with a pop-up notice.",
    "crumbs": [
      "Documentation",
      "Interactivity",
      "External Redirect"
    ]
  },
  {
    "objectID": "docs/defining-questions.html",
    "href": "docs/defining-questions.html",
    "title": "Defining Questions",
    "section": "",
    "text": "There are three different ways to define questions in a surveydown survey:\nThe sections below describes each approach in greater detail.",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Defining Questions"
    ]
  },
  {
    "objectID": "docs/defining-questions.html#using-sd_question",
    "href": "docs/defining-questions.html#using-sd_question",
    "title": "Defining Questions",
    "section": "Using sd_question()\n",
    "text": "Using sd_question()\n\nThe most typical approach to define survey questions is to use the sd_question() function inside code chunks in your survey.qmd file.\nThe question type is defined by the type argument, and each question requires a unique id and a label.\nHere’s a simple example of a multiple-choice question:\n\n\nCode\nOutput\n\n\n\n\nsd_question(\n  id    = \"favorite_penguin\",\n  type  = \"mc\",\n  label = \"Which type of penguin do you like the best?\",\n  option = c(\n    \"Adélie\"    = \"adelie\",\n    \"Chinstrap\" = \"chinstrap\",\n    \"Gentoo\"    = \"gentoo\"\n  )\n)\n\n\n\n\n\n\n\nWhich is your favorite type of penguin?\n\n\n\n\nAdélie\n\n\n\n\nChinstrap\n\n\n\n\nGentoo\n\n\n\n\n*\n\n\n\n\n\n\nDifferent question types require different arguments. For example, a text input question is much simpler:\n\n\nCode\nOutput\n\n\n\n\nsd_question(\n  id    = \"phone_brand\",\n  type  = \"text\",\n  label = \"What is the brand of your phone?\"\n)\n\n\n\n\n\n\n\nWhat is the brand of your phone?\n\n\n\n*\n\n\n\n\n\n\nYou can find more question types and their specific parameters in the Question Types documentation.",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Defining Questions"
    ]
  },
  {
    "objectID": "docs/defining-questions.html#using-a-yaml-file",
    "href": "docs/defining-questions.html#using-a-yaml-file",
    "title": "Defining Questions",
    "section": "Using a YAML File",
    "text": "Using a YAML File\nYou can provide all of the question meta data (id, type, label, and option) inside a questions.yml to define your survey questions.\nThe purpose of using YAML files for question definition is to make it easier to re-use questions across surveys. When a surveydown survey is run, it renders all the survey content into a _survey folder. Inside that folder you will find a questions.yml file with all of the questions in the survey. This file will always get generated. You can then copy this file over to another survey to more easily re-use the questions.\nUsing Default questions.yml\n\n\nCreate a file named questions.yml in your project root directory (or copy it from another survey’s _survey folder).\nDefine any other questions you want using the YAML format.\nInsert questions in your survey.qmd file using sd_question(\"id\") function, matching the \"id\" to each question you want to insert from the questions.yml file.\n\nHere’s a simple example of how a question is defined in questions.yml:\n\nfavorite_penguin:\n  type: mc\n  label: Which type of penguin do you like the best?\n  options:\n    Adélie: adelie\n    Chinstrap: chinstrap\n    Gentoo: gentoo\n\nThe first name is the id for the question. In your survey.qmd file, you can insert the question using sd_question() with this id, like this:\n\nsd_question(\"favorite_penguin\")\n\nThis approach can make your survey.qmd file more streamlined in appearance as each question will be defined by one line of code calling sd_question(\"id\")\nUsing Custom YAML Files\nYou can also specify a different YAML file using the yml parameter:\n\nsd_question(\n  id = \"age\",\n  yml = \"questions/demographics.yml\"\n)\n\nIn the above example, you can see the \"age\" question is grabbed from the demographics.yml file in the questions/ directory.\nThis flexibility allows you to organize questions into multiple files or directories for more complex surveys.",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Defining Questions"
    ]
  },
  {
    "objectID": "docs/defining-questions.html#using-a-gui-in-rstudio",
    "href": "docs/defining-questions.html#using-a-gui-in-rstudio",
    "title": "Defining Questions",
    "section": "Using a GUI in RStudio",
    "text": "Using a GUI in RStudio\n\n\n\n\n\n\nNote\n\n\n\nWe made a blog post explaining the GUI features in full detail here.\n\n\nThe surveydown package includes two gadgets inside the RStudio IDE to provide a user-friendly interface to define survey questions. You can access this feature by clicking the “Add Question” button in the RStudio toolbar when editing your survey.qmd file. There’s another gadget for defining pages.\nUsing the Question Gadget\nThe Survey Question Gadget provides a simple form to create a new question:\n\nUse the Addins menu to select “Add Question”\nFill in the following:\n\n\nQuestion Type: Select from the dropdown (default is “Multiple Choice”)\n\nQuestion ID: Enter a unique identifier (no spaces)\n\nQuestion Label: Enter the actual question text\n\n\nSelect whether you need the R chunk option\nClick “Create Question” or press Enter\n\nThe gadget will insert the properly formatted question code at your cursor position, which you can then customize further as needed.\n\n\n\n\nSetting Up Keyboard Shortcuts\nYou can make it easier to trigger the gadget by binding it to a keyboard shortcut.\n\nGo to Tools → Addins → Browse Addins…\n\n\n\n\n\n\nIn the Addins popup window, click on the “Keyboard shortcuts…” button on the bottom left corner.\n\n\n\n\n\n\nInput “survey” in the search box.\n\n\n\n\n\n\nAssign whatever shortcuts you want, e.g.:\n\n\nCtrl+Shift+P for the Survey Page Gadget\n\nCtrl+Shift+Q for the Survey Question Gadget",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Defining Questions"
    ]
  },
  {
    "objectID": "docs/conditional-logic.html",
    "href": "docs/conditional-logic.html",
    "title": "Conditional Logic",
    "section": "",
    "text": "In surveydown, there are 3 conditional logic functions you can use to control the content and flow of your survey:",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "Conditional Logic"
    ]
  },
  {
    "objectID": "docs/conditional-logic.html#conditional-showing",
    "href": "docs/conditional-logic.html#conditional-showing",
    "title": "Conditional Logic",
    "section": "Conditional Showing",
    "text": "Conditional Showing\nShowing Questions\nIt is often useful to show a question based on some condition, such as the respondent choosing a particular value in a multiple choice question. This can be achieved by the sd_show_if() function.\nFor example, let’s say we have a choice question about people’s favorite penguin type, and the last option is “other”. If the respondent chose it, you may want a second question to display that allows them to specify the “other” penguin type, like this:\n\n\n\n\nTo implement this, you first need to define both the conditional question and the target question in the survey.qmd file, like this:\n\n```{r}\n# Conditional question\nsd_question(\n  type  = \"mc\",\n  id    = \"penguins\",\n  label = \"Which is your favorite type of penguin?\",\n  option = c(\n    \"Adélie\"    = \"adelie\",\n    \"Chinstrap\" = \"chinstrap\",\n    \"Gentoo\"    = \"gentoo\",\n    \"Other\"     = \"other\"\n  )\n)\n\n# Target question\nsd_question(\n  type  = \"text\",\n  id    = \"penguins_other\", \n  label = \"Please specify the other penguin type:\"\n)\n```\n\nThen in the server function in the app.R file, you can use the sd_show_if() function to define that the \"penguins_other\" question would only be shown if the respondent chose the \"other\" option in the \"penguins\" question, like this:\n\n\n\n\n\n\nNote\n\n\n\nThe input object is a Shiny object that stores each question id defined by sd_question() in your survey.qmd file, so whenever referring to a question in a condition, you must use the format input$question_id.\n\n\n\nserver &lt;- function(input, output, session) {\n\n  sd_show_if(\n    input$penguins == \"other\" ~ \"penguins_other\" \n  )\n\n  sd_server(db = db)\n\n}\n\nThe structure of the sd_show_if() function for question display is:\n\n&lt;condition&gt; ~ \"target_question_id\"\n\nYou can provide multiple conditions to the sd_show_if() function, each separated by a comma.\nIn the example above, input$penguins == \"other\" is the condition, and \"penguins_other\" is the target question that will be shown if the condition is met. The ~ symbol is used to separate the condition from the target question.\nTake a look at the Common Conditions section for examples of other types of supported conditions you can use to conditionally display questions.\nShowing Pages\nYou can use sd_show_if() to also conditionally show a page in a similar pattern. The structure of the sd_show_if() function for page display is:\n\nsd_show_if(\n  &lt;condition_1&gt; ~ \"target_page_id_a\",\n  &lt;condition_2&gt; ~ \"target_page_id_b\"\n)\n\nNote that there are 2 condition checks and 2 target page branches in the example above. It means the navigation flow will choose from either page A or page B to show based on which condition is TRUE.\nOne use case for this is a design where you want to randomly show respondents one of a set of pages. For example, let’s say you have versions A and B of page 2 in your survey, and you want to randomly show one to each respondent. Here’s a visual explanation of this setup:\n\n\n\n\nTo implement this, you first need to define each of the pages in your survey.qmd file, like this (on page 1 I’m using sd_output to display the randomly chosen value, A or B, which we’ll define in the server function below):\n\n::: {.sd_page id=page1}\n\nThis is page 1\n\nThe next page will be page 2 `r sd_output(\"rand_val\", type = \"value\")` \n\n```{r}\nsd_next()\n```\n\n:::\n\n::: {.sd_page id=page2a}\n\nThis is page 2A\n\n```{r}\nsd_next()\n```\n\n:::\n\n::: {.sd_page id=page2b}\n\nThis is page 2B\n\n```{r}\nsd_next()\n```\n\n:::\n\n::: {.sd_page id=page3}\n\nThis is page 3\n\n```{r}\nsd_close()\n```\n\n:::\n\nThen in the server function in the app.R file, you can randomly generate a value to determine which of the page 2 version you’ll use (A or B), then condition on that value to display page2a or page2b using the sd_show_if() function, like this:\n\nserver &lt;- function(input, output, session) {\n\n  # Generate random condition\n  rand_val &lt;- sample(c('A', 'B'), 1)\n\n  # Store the condition value\n  sd_store_value(rand_val)\n\n  # Use sd_show_if to show target pages\n  sd_show_if(\n    rand_val == 'A' ~ 'page2a',\n    rand_val == 'B' ~ 'page2b'\n  )\n\n  sd_server()\n\n}\n\nThis approach will hide both page2a and page2b by default and only show the page if the condition on the left hand side is TRUE.\nNote that we’re also using sd_store_value() here to store the random value, A or B, in the response data so that we can know later which page was shown for each respondent.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "Conditional Logic"
    ]
  },
  {
    "objectID": "docs/conditional-logic.html#conditional-skipping",
    "href": "docs/conditional-logic.html#conditional-skipping",
    "title": "Conditional Logic",
    "section": "Conditional Skipping",
    "text": "Conditional Skipping\nWhile basic page navigation is handled using sd_next(), you can override this static navigation in your server function with the sd_skip_if() function to send the respondent to a forward page based on some condition.\nA common example is the need to screen out people based on their response(s) to a question. Let’s say you need to screen out people who do not own a vehicle. To do this, you would first define a question in your survey.qmd file about their vehicle ownership, e.g.:\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'vehicle_ownership',\n  label = \"Do you own your vehicle?\",\n  option = c(\n    'Yes' = 'yes',\n    'No'  = 'no'\n  )\n)\n```\n\nYou would also need to define a screenout page to send respondents to, like this:\n\n::: {.sd_page id=screenout}\n\nSorry, but you are not qualified to take our survey.\n\n:::\n\nThen in the server function in the app.R file, you can use the sd_skip_if() function to define the condition under which the respondent will be sent to the target screenout page, like this:\n\n\n\n\n\n\nNote\n\n\n\nThe input object is a Shiny object that stores each question id defined by sd_question() in your survey.qmd file, so whenever referring to a question in a condition, you must use the format input$question_id.\n\n\n\nserver &lt;- function(input, output, session) {\n\n  sd_skip_if(\n    input$vehicle_ownership == \"no\" ~ \"screenout\"\n  )\n\n  # ...other server code...\n\n}\n\nYou can provide multiple conditions to the sd_skip_if() function, each separated by a comma. The structure for each condition is always:\n\n&lt;condition&gt; ~ \"target_page_id\"\n\nIn the example above, input$vehicle_ownership == \"no\" is the condition, and \"screenout\" is the target page that the respondent will be sent to if the condition is met.\nTake a look at the Common Conditions section for examples of other types of supported conditions you can use to conditionally control the survey flow.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "Conditional Logic"
    ]
  },
  {
    "objectID": "docs/conditional-logic.html#conditional-stopping",
    "href": "docs/conditional-logic.html#conditional-stopping",
    "title": "Conditional Logic",
    "section": "Conditional Stopping",
    "text": "Conditional Stopping\nSometimes you may want to stop the survey navigation based on some condition. For example, say you want to collect respondents’ ZIP code. In the U.S., ZIP codes are 5-digit numbers, so if a respondent enters a ZIP code that is not 5 digits long, you may want to stop the navigation and prevent them from proceeding further in the survey.\nHere is how you can implement this. Firstly, in the survey.qmd file, you would define a question to collect the ZIP code, like this:\n\n```{r}\nsd_question(\n  type  = \"numeric\",\n  id    = \"zip\",\n  label = \"What's your zip code?\"\n)\n```\n\nThen, in the app.R file, you can use the sd_stop_if() function to define the condition that will stop the navigation if the ZIP code is not 5 digits long, like this:\n\nserver &lt;- function(input, output, session) {\n\n  sd_stop_if(\n    # The zip question only accepts a 5-digit response\n    nchar(input$zip) != 5 ~ \"Zip code must be 5 digits.\"\n  )\n\n  sd_server(db = db)\n}\n\nThe structure of the sd_stop_if() function is:\n\nsd_stop_if(\n  &lt;condition&gt; ~ \"error_message\"\n)\n\nIt means: if the &lt;condition&gt; is TRUE, display the \"error_message\" to the respondent while they attempt to trigger the navigation.\nLikewise, sd_stop_if() supports multiple conditions, each separated by a comma. If there are more than one conditions on the same page, the error messages will be concatenated and displayed together.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "Conditional Logic"
    ]
  },
  {
    "objectID": "docs/conditional-logic.html#common-conditions",
    "href": "docs/conditional-logic.html#common-conditions",
    "title": "Conditional Logic",
    "section": "Common Conditions",
    "text": "Common Conditions\nThis section highlights some of the most common types of conditions you might need.\n\n\n\n\n\n\nNote\n\n\n\nWhile we use the sd_show_if() function in most of these examples, similar logic applies to sd_skip_if() and sd_stop_if().\n\n\nQuestion responses\nOne of the most common situations is conditioning on the response of a single question or multiple questions, like this:\n\nsd_show_if(\n\n # Simple condition based on single question choice\n input$penguins1 == \"other\" ~ \"penguins1_other\",\n\n # Multiple condition based on multiple question choices\n input$penguins2 == \"other\" & input$show_other == \"show\" ~ \"penguins2_other\"\n\n)\n\nIn the first condition, the penguins1 question is checked to see if the respondent chose the \"other\" option. If they did, the penguins1_other question will be shown.\nIn the second condition, the penguins2 question is checked to see if the respondent chose the \"other\" option, and the show_other question is checked to see if the respondent chose the \"show\" option. With this condition, the penguins2_other question will only be shown if both conditions are TRUE.\nNumeric values\nAnother common condition is checking the value of a numeric question. To do so, you need to wrap the input$question_id in the as.numeric() function because all question values are stored as strings, like this:\n\nsd_show_if(\n as.numeric(input$car_number) &gt; 1 ~ \"car_ownership\"\n)\n\nIn the condition above, the car_number question is checked to see if the respondent chose a number greater than 1. If they did, the car_ownership question will be shown.\nMultiple response questions\nFor multiple response question types (e.g. mc_multiple), the question returns a vector storing all the chosen values. You can use this vector to check for different conditions, such as whether the chosen values are in some set of values using the %in% operator, or whether the respondent chose a number of options using the length() function, like this:\n\nsd_show_if(\n\n # Check if the respondent chose \"apple\", \"banana\", or both\n all(input$fav_fruits %in% c(\"apple\", \"banana\")) ~ \"apple_or_banana\",\n\n # Check if the respondent chose more than 3 fruits\n length(input$fav_fruits) &gt; 3 ~ \"fruit_number\"\n\n)\n\nIn the first example, the fav_fruits question is checked to see if the respondent chose \"apple\", \"banana\", or both; if so, the apple_or_banana question will be shown.\nIn the second example, the fav_fruits question is checked to see if the respondent chose more than 3 fruits; if so, the fruit_number question will be shown.\nAnswering status\nYou may want to show a target question if a question is answered at all or not. To do this, we created the sd_is_answered() function that returns TRUE if a question is answered and FALSE otherwise.\nFor example, let’s say you had a multiple choice question fav_fruit that asked you to choose your favorite fruit from a list of options, and a target question num_fruit that asked how many fruit you eat per day. If we wanted to show the num_fruit question so long as the fav_fruit question is answered, we can use sd_is_answered(\"fav_fruit\") in the sd_show_if() function, like this:\n\nsd_show_if(\n  sd_is_answered(\"fav_fruit\") ~ \"num_fruit\" \n)\n\nThis way, as long as the fav_fruit question is answered, no matter which option the user picks the num_fruit question will appear.\nFor \"matrix\" type questions, sd_is_answered() will only be TRUE if all sub-questions (matrix rows) in it are answered.\nCustom functions\nFor situations where the conditional logic is more complex, we recommend defining a custom function that will return a logical value (TRUE or FALSE). You can then pass this function to sd_show_if(), sd_skip_if(), or sd_stop_if() as a condition.\nFor example, let’s say we had a mc type question where we asked how many cars the respondent owned, and we included numeric options 1 through 5 as well as a final option \"6 or more\". If we wanted to set a condition that would return TRUE if the user had more than one car, using as.numeric(input$question_id) &gt; 1 as the condition would be problematic, because this would return NA if the respondent chose the \"6 or more\" option.\nTo address this, we could create a custom function to handle this special condition:\n\nserver &lt;- function(input, output, session) {\n\n  more_than_one_car &lt;- function(input) {\n    if (is.null(input$car_number)) {\n      return(FALSE)\n    }\n    num_cars &lt;- as.numeric(input$car_number)\n    return(num_cars &gt; 1)\n  }\n\n  sd_show_if(\n    more_than_one_car(input) ~ \"car_ownership\"\n  )\n\n  sd_server(db = db)\n\n}\n\nIn the more_than_one_car() function, we first return FALSE if the question is not yet answered (that’s the if (is.null(input$car_number)) part). Then we obtain the numeric value of the car_number question using as.numeric(input$car_number). Then we return the simple condition num_cars &gt; 1, which will return TRUE if the respondent chose a number greater than 1, or FALSE otherwise (including if they chose \"6 or more\").\nCustom values\nSometimes you’ll want to condition on values that aren’t directly related to question responses. For example, you might want to randomly assign respondents to different survey versions or experimental conditions.\nA common example is the same situation as the Showing Pages section above where you have two versions of a page, page2a and page2b, and you want half of your respondents to see page 2a and the other half to see page 2b. You can accomplish this by:\n\nGenerating a random condition value, A or B\nStoring that value for later use\nUsing sd_show_if() to conditionally show the correct page version\n\nHere’s how to implement this:\n\nserver &lt;- function(input, output, session) {\n\n  # Generate random condition\n  rand_val &lt;- sample(c('A', 'B'), 1)\n\n  # Store the condition value\n  sd_store_value(rand_val)\n\n  # Use sd_show_if to show target pages\n  sd_show_if(\n    rand_val == 'A' ~ 'page2a',\n    rand_val == 'B' ~ 'page2b'\n  )\n\n  sd_server()\n\n}\n\nIn this example, sample(c('A', 'B'), 1) randomly selects either 'A' or 'B'. The sd_store_value() function saves this value to the database, making it available for later analysis. Then, sd_show_if() uses this value to determine which page version the respondent should see.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "Conditional Logic"
    ]
  },
  {
    "objectID": "docs.html",
    "href": "docs.html",
    "title": "surveydown.org",
    "section": "",
    "text": "Welcome to your first surveydown survey!\nWe recommend reading the Getting Started page to get a sense of how to use surveydown and perform your basic setups. The rest of the documentation covers more details on how to use surveydown.\nThe  package deployment site can be accessed here.\n\nClick here to get started!\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Documentation"
    ]
  },
  {
    "objectID": "blog/2025-06-29-sdstudio/index.html",
    "href": "blog/2025-06-29-sdstudio/index.html",
    "title": "Introducing sdstudio: A companion GUI for surveydown",
    "section": "",
    "text": "As a companion package to the surveydown platform, sdstudio serves as a comprehensive GUI for working with surveydown surveys. It allows you to build and preview surveys as well as manage response data all without requiring programming knowledge.\nBelow is a brief walkthrough video of the sdstudio package:"
  },
  {
    "objectID": "blog/2025-06-29-sdstudio/index.html#getting-started",
    "href": "blog/2025-06-29-sdstudio/index.html#getting-started",
    "title": "Introducing sdstudio: A companion GUI for surveydown",
    "section": "1 Getting Started",
    "text": "1 Getting Started\n\n1.1 Installation\nThe sdstudio package is currently in development and can be installed directly from GitHub:\n# Development version\npak::pak(\"surveydown-dev/sdstudio\", ask = FALSE)\nSince sdstudio is a companion package of surveydown, make sure to install surveydown as well:\n# Development version\npak::pak(\"surveydown-dev/surveydown\", ask = FALSE)\n\n# CRAN version\ninstall.packages(\"surveydown\")\n\n\n1.2 Launch!\nLaunch the studio in your browser using this function:\nsdstudio::launch()\nThe sdstudio interface is organized into three main tabs that follow the natural survey workflow:\n\n🏗️ Build: Visual survey creation with side-by-side structure and scripts\n👁️ Preview: Real-time survey testing\n📊 Responses: Data collection, analytics, and export capabilities"
  },
  {
    "objectID": "blog/2025-06-29-sdstudio/index.html#the-build-tab",
    "href": "blog/2025-06-29-sdstudio/index.html#the-build-tab",
    "title": "Introducing sdstudio: A companion GUI for surveydown",
    "section": "2 The “Build” Tab",
    "text": "2 The “Build” Tab\n\n2.1 Start from a Template\nThe “Build” tab is your workspace of survey construction. You can either start from a prepared template or continue with your own survey files. The “Directory” will show your current working directory, but you can change it to any directory where your survey files are stored.\n\n\n\n\n\n\nNote\n\n\n\nWe currently have 15 templates to choose from. The default template contains a minimum basic structure for a clean start. You might also try the question_type template for a showcase of all question types, or try some advanced features with conditional_display, conditional_navigation, etc. For a full list of templates, see the templates repo on GitHub.\n\n\n\n\n\n\nStart from a Template in the Build Tab\n\n\n\n\n\n2.2 Build Your Survey\nAfter you’ve selected your template, or if you already have an existing survey, you’ll see the dual panel of survey constructions on the “Build” tab. The “Structure” section on the left shows the page-content structure of your survey. The “Code” section on the right displays the survey scripts in a code editor.\n\n\n\n\nDual Panel of the Build Tab\n\n\n\n\n2.2.1 The Structure Section\nThe “Structure” section on the left gives you 2 hierarchies: page and content. The pages can be toggled on to show the content, or toggled off. There are two types of content: questions and texts, with labels of “Q” and “T”, respectively.\nThere are buttons on each page and content which self-explain their capabilities. The “Add A New Page” button at the bottom allows you to create a new page.\nThe question content shows question ID, question type, and question label. You can review the full question details with the edit button, or view the full question definition code on the code section. The text content shows the first 5 words of the full piece of text.\n\n\n\n\nClick on the +T/+Q button to add a text/question\n\n\n\nAll elements support drag-n-drop operations. After each operation, the structure will refresh and update the code editor on the right. If you move two test elements together, they will merge in to one text element.\n\n\n\n\nDragging two texts together will merge them\n\n\n\n\n\n2.2.2 The Code Section\n\n\n\n\n\n\nNote\n\n\n\nFor now the surveydown Studio has powerful support to survey.qmd because it is meant to be the main file for survey construction. However, even though app.R is directly editable, we still recommend that you edit it using your IDE or other text editors. All our templates have the app.R file ready to run, which can be a good starting point.\n\n\nThe “Code” section on the right is an integrated code editor that allows you to edit the survey scripts directly, with the survey.qmd file opened by default. It also reflects any operation you’ve done on the “Structure” section. The other file, app.R, is available for direct editing as well."
  },
  {
    "objectID": "blog/2025-06-29-sdstudio/index.html#the-preview-tab",
    "href": "blog/2025-06-29-sdstudio/index.html#the-preview-tab",
    "title": "Introducing sdstudio: A companion GUI for surveydown",
    "section": "3 The “Preview” Tab",
    "text": "3 The “Preview” Tab\nThe “Preview” tab is where your survey comes to life. It provides a real-time, interactive preview of your survey as you build it, allowing you to see exactly how respondents will experience your survey.\n\n3.1 Live Rendering\nEvery time you make changes in the Build tab, the survey is live-rendered and revealed in the Preview tab. It takes a couple of seconds to render, so if you switch to the Preview tab too early, you’ll see message of survey being rendered. After rendering is done, the survey will be available.\n\n\n\n\nThe survey preview is live and interactive\n\n\n\n\n\n3.2 Desktop and Mobile Views\nYou can toggle between “Desktop View” and “Mobile View” using the pair of buttons at the top right corner:\n\n\n\n\nToggling between desktop and mobile views\n\n\n\n\n\n3.3 New Sessions\nYou might have noticed there is a green refresh button on the top right as well. This is for you to manually refresh the preview if you want to restart a session:\n\n\n\n\nRestart a new session using the refresh button"
  },
  {
    "objectID": "blog/2025-06-29-sdstudio/index.html#the-responses-tab",
    "href": "blog/2025-06-29-sdstudio/index.html#the-responses-tab",
    "title": "Introducing sdstudio: A companion GUI for surveydown",
    "section": "4 The “Responses” Tab",
    "text": "4 The “Responses” Tab\nWe built sdstudio for two purposes: for designing surveys and for managing survey response data. You can use the studio for either or both purposes.\nThe “Responses” tab is used to view two forms of survey response data:\n\nLocal Mode: This mode allows you to view “preview data” while locally previewing your survey without having a database connection. The preview data are stored in a local “preview_data.csv” file and are purely available for the purposes of previewing what your data will look like once you have a database connection.\nDB Mode: After creating and testing your survey, you can add a database connection to start collecting survey responses in your live database.\n\nLets go through each of these use cases in details.\n\n4.1 Local Mode\nAll our templates have Local Mode enabled by default, because we recommend you to start from local testing. To start with your local testing, you can simply go through all 3 tabs in order: Build, Preview, and then Responses.\nBelow is a brief walkthrough of the process:\n\n\n\n\nBuild, Preview, and Responses in Sequence\n\n\n\n\n\n4.2 DB Mode\n\n\n\n\n\n\nNote\n\n\n\nFor instructions on how to obtain your database credentials, see the Storing Data documentation page.\n\n\nTo get started with viewing your database response data, you need to firstly switch to DB Mode by clicking the “DB Mode” button on the top right corner. This is available in all 3 tabs. Then, in your “Responses” tab, you’ll see a “Database Connection” section on the top. Toggle on the “Settings” button and fill in your database credentials. You can test the connection by clicking the “Test Connection” button. If you have already set up your database credentials using sd_db_config() to create a local .env, then your credentials should show here.\nIn order to have a clean start, we recommend you to name a new table in the “Table” field of “Database Connection”. Upon clicking “Test Connection”, this table will only be a placeholder, and the database will create such table once you start your first survey run.\n\n\n\n\nInput your credentials and create a new table\n\n\n\nIf the connection is successful, you will see a “Connected” status message in green. The “Choose a table to view” section will show the new table you just created, but all fields will be empty. They will be filled in once you run your survey in the Preview tab.\nAfter you’ve taken care of the database connection, you can go back to the Build tab and proceed with your survey construction, following the exact same steps. The only difference is that now, when you run the survey in the Preview tab, your responses will be stored in the database table you just created instead of the local “preview_data.csv” file.\n\n\n4.3 Viewing other tables\nIt is important to note that you can use the “Responses” tab to view all tables stored in your database. For example, if you have multiple surveys you are working on (each in a separate folder) that share the same database, you can select other tables to view from the “Responses” tab.\n\n\n\n\nInput your database credentials\n\n\n\nIf the connection is successful, you will see a “Connected” status message in green. You can choose your desired response table from the dropdown menu, review its progress and details, and download the csv file if needed:\n\n\n\n\nFill in your database credentials and click on the “Test Connection” button"
  },
  {
    "objectID": "blog/2025-06-29-sdstudio/index.html#data-security",
    "href": "blog/2025-06-29-sdstudio/index.html#data-security",
    "title": "Introducing sdstudio: A companion GUI for surveydown",
    "section": "5 Data Security",
    "text": "5 Data Security\n\n5.1 The .env File\nWhen you input your database credentials in the “Responses” tab, it creates a local .env file in your current working directory, which is a hidden file. This file is used to store environment variables securely. Along with this file, there will be a .gitignore file created with .env added to prevent it from being accidentally pushed to your git repository. This is a good practice to keep your credentials safe.\nIn this .env file, you will find the following variables:\n# Database connection settings for surveydown\nSD_HOST=\"your-database-host\"\nSD_PORT=\"your-database-port\"\nSD_DBNAME=\"your-database-name\"\nSD_USER=\"your-database-username\"\nSD_PASSWORD=\"your-database-password\"\nSD_TABLE=\"your-database-table\"\nThe editing of this file is bi-directional, so you can either edit on this file, or use the sdstudio interface.\n\n\n5.2 GSSAPI Encryption\nThe sdstudio::launch() function allows the gssencmode argument. It controls the encryption mode for database connections. This is crucial for ensuring secure communication with your database, especially when handling sensitive survey data.\nBy default, we set gssencmode = \"auto\", which attempts to use GSSAPI encryption if available, falling back to a plain connection if not. This is the recommended mode for most users. The connection status will show a green “Connected (GSSAPI enabled)” message if GSSAPI is successfully enabled, or a yellow “Connected (GSSAPI disabled)” message if it falls back to plain connection:\n# Auto mode (recommended) - tries GSSAPI first, falls back if needed\nsdstudio::launch()\nHowever, if you want to explicitly control the encryption mode, you can set gssencmode to one of the following values:\n# Prefer mode - only use GSSAPI\nsdstudio::launch(gssencmode = \"prefer\")\n\n# Disable mode - forces plain connection (useful for VPN environments)\nsdstudio::launch(gssencmode = \"disable\")"
  },
  {
    "objectID": "blog/2025-06-29-sdstudio/index.html#conclusion",
    "href": "blog/2025-06-29-sdstudio/index.html#conclusion",
    "title": "Introducing sdstudio: A companion GUI for surveydown",
    "section": "6 Conclusion",
    "text": "6 Conclusion\nAs a companion GUI for the surveydown platform, sdstudio significantly simplifies the survey creation process. It allows users to build, preview, and manage surveys through an intuitive interface, without requiring extensive programming skills. The three-tab workflow - Build, Preview, and Responses - provides a comprehensive solution that covers the entire survey lifecycle.\nIf you have any questions or feedback you’d like to share, please drop us a line using GitHub Discussions.\n\nFor more information, visit the sdstudio documentation or explore the surveydown platform."
  },
  {
    "objectID": "blog/2024-12-20-surveydown-on-cran/index.html",
    "href": "blog/2024-12-20-surveydown-on-cran/index.html",
    "title": "surveydown is on CRAN 🎉!",
    "section": "",
    "text": "We have some exciting news to share - surveydown is on CRAN 🎉!\nYou can now install surveydown from CRAN using the usual install.packages() function:\ninstall.packages(\"surveydown\")\nActually, surveydown has been on CRAN since v0.4.0, but we’ve been making so many updates that we’re now already on v0.7.2 before we could even make a post about being on CRAN!\nSo it seems about time we highlight some of the improvements and new features we’ve added recently."
  },
  {
    "objectID": "blog/2024-12-20-surveydown-on-cran/index.html#new-functions-features",
    "href": "blog/2024-12-20-surveydown-on-cran/index.html#new-functions-features",
    "title": "surveydown is on CRAN 🎉!",
    "section": "New functions / features",
    "text": "New functions / features\nWe added a whole bunch of new functions and features since v0.3.0, which was a major architectural change to the package. But the changes we made in v0.3.0 made it lot easier to support more features. There have been a lot, so I’m probably missing some, but here are some quick highlights that are worth calling out:\n\nIn sd_question(), we added a new type = \"matrix\" to support matrix type questions.\nWe added a new sd_is_answered() function to check if a question is answered or not. This is useful for conditional reactive questions defined in the server.\nWe added a new sd_completion_code() function that generates a random completion code for your survey.\nWe added a new sd_close() function to make a button that closes the survey.\n\nStefan Munnes added a translation feature that allows you to customize the system messages in the app to any language you want.\nWe modified how data handling is done so that each respondent’s state in the survey can be restored via cookies if they refresh the browser window or close and re-open the window. Before, respondents would be sent back to the start of the survey and a new entry in the database would be created, so this features allows respondents to pause and come back to the survey without that happening.\nWe added two new helper functions, sd_add_question() and sd_add_page(), that make it easier to quickly create template questions and pages. They work like this:"
  },
  {
    "objectID": "blog/2024-12-20-surveydown-on-cran/index.html#performance-improvements",
    "href": "blog/2024-12-20-surveydown-on-cran/index.html#performance-improvements",
    "title": "surveydown is on CRAN 🎉!",
    "section": "Performance improvements",
    "text": "Performance improvements\nOne major improvement we’ve made is to streamline how the survey.qmd file is updating. Before you needed to render the survey.qmd file yourself before running the app.R file, but now you actually never need to render it. All rendering is handled when you run the shiny app via the app.R file.\nAnd this rendering is “smart” too - it renders the survey.qmd file into an html file, then it parses that file for all of the content needed for the survey and stores each piece in a _survey folder. This folder is then what the shiny app uses to load the survey. If no changes are detected in the survey.qmd file or any of the components in the _survey folder, then the app will always load content from the pre-rendered content in the _survey folder, which will load nearly instantaneously! Only if you make a change to your survey will it be re-rendered, and again once that rendering is done once it won’t run again until another change is detected. This results in a much more efficient app that loads nearly instantaneously.\nWe also improved the database updating to be much more efficient. It used to run a write operation to the database on every single question ineraction, but that slowed down the app significantly. Now that we have cookies enabled, we do the immediate record keeping in the cookies and only write to the database when the respondent closes the survey or turns the page. This is a more reasonable compromise that makes the app feel snappy while still ensuring that the data is saved even if the respondent accidentally closes the window."
  },
  {
    "objectID": "blog/2024-12-20-surveydown-on-cran/index.html#our-first-community-contributions",
    "href": "blog/2024-12-20-surveydown-on-cran/index.html#our-first-community-contributions",
    "title": "surveydown is on CRAN 🎉!",
    "section": "Our first community contributions!",
    "text": "Our first community contributions!\nOver the past few months, we’ve been getting a lot of contributions from the community! We’ve been able to merge a few pull requests that add some new features and fix some bugs. Here are some of the highlights:\n\n\nStefan Munnes added a new translation feature that allows you to customize the system messages in the app to any language you want. He also helped us update sd_output() to be able to output the chosen question values, chosen question option label(s), and the question label itself. This addresses feature request #128.\n\nZain Hoda contributed a new auto_scroll parameter to the sd_server() function that allows you to turn off auto scrolling. This is useful if you have a lot of questions and want to make sure the respondent can see the entire question.\n\nWe’re excited to see what the community will build with surveydown! If you build something with surveydown, please let us know on the GitHub Discussions so we can highlight your work!"
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "",
    "text": "Important\n\n\n\nThis post was updated on 2025-09-14 to match the latest package version\nBecause surveydown surveys run as a shiny app, you can include custom logic in the background by writing some  code in your server. In this post, I’m going to show you one approach for using surveydown to create a particular type of complex survey: a choice-based conjoint survey.\nThe key component of a choice-based conjoint survey is asking repsondents to make choices from randomized sets of choice questions. So the hard part is figuring out a way to show each respondent a different set of randomized questions. This post shows how you can achieve this in surveydown.\nThroughout this post, I will use a demo survey about people’s preferences for apples with three attributes: type, price, and freshness.1 I will focus on one structure for the conjoint survey that uses the mc_buttons question type for the main choice questions. You can view a live demo of that survey and the template used to create it here. An alternative structure is to display choice options in a table - that template can be found here."
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#introduction",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#introduction",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Introduction",
    "text": "Introduction\nIf you’ve never used surveydown before, take a look at the Getting Started page to get a quick introduction to the package and how to use it to make a survey.\nThe basic concept is this:\n\nDesign your survey as a Quarto document using markdown and R code.\nConvert your survey into a Shiny app that can be hosted online and sent to respondents.\nStore your survey responses in a Supabase database."
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#getting-started",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#getting-started",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Getting started",
    "text": "Getting started\nFor this post, we recommend starting from the demo survey available here. It provides an already working survey that you can modify to the needs of your conjoint survey.\nThe demo repo has a lot of files in it, but the main files defining the survey itself are:\n\n\nsurvey.qmd: The main body of the survey.\n\napp.R: The app file containing the server logic implemented in the survey, including randomizing questions, connecting to a database, etc.\n\n\n\n\n\n\n\nNote\n\n\n\nWe recommend opening the survey.Rproj if you’re working in RStudio to make sure RStudio opens to the correct project folder."
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#content-in-the-survey-body",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#content-in-the-survey-body",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Content in the survey body",
    "text": "Content in the survey body\nAfter the setup code chunk where we load the surveydown package, we have a series of pages (defined with ::: fences) that include markdown-formatted text and survey questions (defined with sd_question()). You can modify any of this content as you wish to suit the needs of your survey.\nIn this demo, we have a few other examples included, like a conditionally displayed question (the fav_fruit question will not display if you choose “No” on the first question about liking fruit) as well as a question that skips people to the end (if you choose “blue” and not “red” on the screening page). The logic controlling the conditional display and skipping is defined with the sd_skip_if() function in the app.R file.\nNone of this is absolutely necessary for a conjoint survey, but often times these are features that you may want to include, such as screening people out of the survey if they don’t qualify to take it, so we include it for demonstration purposes."
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#defining-the-choice-questions",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#defining-the-choice-questions",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Defining the choice questions",
    "text": "Defining the choice questions\nThe central component of every conjoint survey is the set of randomized choice questions. To implement these in surveydown, we pre-define our choice questions in a design file that we later use in the survey to select randomized sets of choice questions to display each respondent.\nWe use the cbcTools package to create the pre-defined design file. The code to create the choice questions for this demo survey is in the 1_make_choice_questions.R file in the demo repo. This code generates a data frame of randomized choice questions that we then save in the project directory as choice_questions.csv."
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#implementing-the-choice-questions",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#implementing-the-choice-questions",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Implementing the choice questions",
    "text": "Implementing the choice questions\nThe choice questions are implemented at the top of the server() function in the app.R file in the demo repo. This code does the following steps:\n1. Read in the design file\nPretty straightforward - this is one line to read in the choice_questions.csv design file that we saved in the project folder.\n\ndesign &lt;- readr::read_csv(\"choice_questions.csv\")\n\n2. Sample and store a random respondent ID\nSince we want each respondent to see a different set of choice questions, we randomly sample a respondent ID from the set of all respondent IDs in the design file. We also need to keep track of this and store it in our response data so that later we can know what each respondent was actually shown.\nSince this is a value that we generated in the server (and not a value from a survey question to a respondent), we have to manually add it to the survey response data using sd_store_value(). Here we modified the name so that in the resulting survey data the column name will be \"respID\".\n\n# Sample a random respondentID\nrespondentID &lt;- sample(design$respID, 1)\n\n# Store the respondentID\nsd_store_value(respondentID, \"respID\")\n\n3. Filter the design for the respondentID\nWe create a subset dataframe called df that stores only the rows for the randomly chosen respondent ID. We also append the \"images/\" string onto the values in the image column as this will create the relative path to the images in our survey, e.g. \"images/fuji.jpg\" (all the images we show are in the \"images\" folder in the repo).\n\n# Filter for the rows for the chosen respondentID\ndf &lt;- design %&gt;%\n  filter(respID == respondentID) %&gt;%\n  mutate(image = paste0(\"images/\", image))\n\n4. Define a function to create question options\nThis is the most complex component in the server logic. Here we created a function that takes a dataframe and returns a named vector defining the options to show in each choice question. In this case, we only have 3 options per choice question, so each time we call this function we will use a small dataframe that has just 3 rows defining the 3 choice alternatives in a single choice question.\nThe function does several things. First, it extracts three single-row data frames that store the values of each of the 3 alternatives (alt1, alt2, and alt3). It then creates an options vector that has just 3 values: \"option_1\", \"option_2\", and \"option_3\". Then we have to define the names of each of those options. Remember that the values in the options vector are what gets stored in our resulting survey data based on what the respondent chooses, but the names are what respondents see. So in the context of a choice survey like this, we need to embed all of the attributes and their levels in the names of the options vector.\nWe use the glue() function to easily inject the values stored in alt1, alt2, and alt3 into our labels. The glue() function is similar to paste() in that is just concatenates object values into a string, but it has an easier syntax to work with. Anything inside {} brackets is evaluated, and the resulting value is inserted into the string. So for example, the line glue(\"1 plus 1 equals {1+1}\") would produce the string \"1 plus 1 equals 2\".\nIn our case, we’re including some html code to insert an image of the apple type (&lt;img src='{alt1$image}' width=100&gt;), the apply type itself (**Type**: {alt1$type}), and the apple price (**Price**: $ {alt1$price} / lb).\nNotice also that we’re mixing markdown (e.g. **Option 1**) and html (e.g. &lt;br&gt;), which will all get rendered into proper html in the resulting shiny app. The full function looks like this:\n\n# Function to create the labels for a choice question\n# based on the values in df\n\nmake_cbc_options &lt;- function(df) {\n  alt1 &lt;- df |&gt; filter(altID == 1)\n  alt2 &lt;- df |&gt; filter(altID == 2)\n  alt3 &lt;- df |&gt; filter(altID == 3)\n\n  options &lt;- c(\"option_1\", \"option_2\", \"option_3\")\n\n  names(options) &lt;- c(\n    glue(\n      \"\n    **Option 1**&lt;br&gt;\n    &lt;img src='{alt1$image}' width=100&gt;&lt;br&gt;\n    **Type**: {alt1$type}&lt;br&gt;\n    **Price**: $ {alt1$price} / lb&lt;br&gt;\n    **Freshness**: {alt1$freshness}\n  \"\n    ),\n    glue(\n      \"\n    **Option 2**&lt;br&gt;\n    &lt;img src='{alt2$image}' width=100&gt;&lt;br&gt;\n    **Type**: {alt2$type}&lt;br&gt;\n    **Price**: $ {alt2$price} / lb&lt;br&gt;\n    **Freshness**: {alt2$freshness}\n  \"\n    ),\n    glue(\n      \"\n    **Option 3**&lt;br&gt;\n    &lt;img src='{alt3$image}' width=100&gt;&lt;br&gt;\n    **Type**: {alt3$type}&lt;br&gt;\n    **Price**: $ {alt3$price} / lb&lt;br&gt;\n    **Freshness**: {alt3$freshness}\n  \"\n    )\n  )\n  return(options)\n}\n\n5. Create the options for each choice question\nOne of the benefits of making the function the way we did in the previous step is that we can now easily call it to generate the option vector for each of the 6 choice questions in df:\n\n# Create the options for each choice question\n\ncbc1_options &lt;- make_cbc_options(df |&gt; filter(qID == 1))\ncbc2_options &lt;- make_cbc_options(df |&gt; filter(qID == 2))\ncbc3_options &lt;- make_cbc_options(df |&gt; filter(qID == 3))\ncbc4_options &lt;- make_cbc_options(df |&gt; filter(qID == 4))\ncbc5_options &lt;- make_cbc_options(df |&gt; filter(qID == 5))\ncbc6_options &lt;- make_cbc_options(df |&gt; filter(qID == 6))\n\n6. Create each choice question (6 in total)\nFinally, we now have everything we need to generate each choice question. Here we’re using the mc_buttons question type so that the labels we generated will be displayed on a large button, which looks good both on a computer and phone. We give the question a unique id (e.g. cbc_q1), and a label, and then set the option to the corresponding option vector we defined above.\n\nsd_question(\n  type   = 'mc_buttons',\n  id     = 'cbc_q1',\n  label  = \"(1 of 6) If these were your only options, which would you choose?\",\n  option = cbc1_options\n)\n\n# ...and 5 more questions like this\n\nRemember that since the labels in the options are being dynamically generated on each new session (each respondent), they have to be created in the server, not in the main survey body. As a result, the sd_question() function must also be created in the server code (if you put this code in the main body, only one random set of choice options will be generated, and they’ll be the same for everyone).\nTo display each question in the survey body, we use sd_output(\"id\", type = \"question\"), changing id to each corresponding choice question we created. In the demo survey.qmd file, you’ll see that there are 6 choice questions displayed in the main survey body (each on their own page), and each of those 6 questions are defined in the server() function in the app.R file.\nWhen rendered, a choice question will look like this, with the values matching whatever alternative was chosen in the design file:\n\n\n\n\n(1 of 6) If these were your only options, which would you choose?\n\n\n\nOption 1Type: HoneycrispPrice: $ 1 / lbFreshness: Average\nOption 2Type: FujiPrice: $ 3 / lbFreshness: Excellent\nOption 3Type: Red DeliciousPrice: $ 2.5 / lbFreshness: Average\n\n\n\n\n*\n\n\n\n\nAnd that’s it! You now have 6 randomized choice questions!"
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#buttons-versus-tables",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#buttons-versus-tables",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Buttons versus tables",
    "text": "Buttons versus tables\nIn the example above, the conjoint choice questions are displayed as “buttons” where all the information for each alternative is shown as a button. This works particularly well for mobile phone applications where the user may need to scroll vertically to see each option.\nAn alternative is to use a table layout where each column represents an alternative and the row names explain the attribute. This takes a little manipulation to get it right, but the key concept is to use kable() to display the transpose of the df data frame (the subset of rows for a particular respondent). We also use the wonderful kableExtra package to modify some of the table stying. We don’t explain this code in detail in this blog post, but the gist of what we’re doing here is creating a dataframe with our alternatives and displaying it as a table with kable().\nThe main function doing this work in the conjoint table template is the make_cbc_table() function, which looks like this:\n\nlibrary(dplyr)\nlibrary(kableExtra)\n\n# Function to create the options table for a given choice question\nmake_cbc_table &lt;- function(df) {\n  alts &lt;- df |&gt;\n    mutate(\n      price = paste(scales::dollar(price), \"/ lb\"),\n      image = paste0('&lt;img src=\"', image, '\" width=100&gt;')\n    ) |&gt;\n    # Make nicer attribute labels\n    select(\n      `Option:` = altID,\n      ` ` = image,\n      `Price:` = price,\n      `Type:` = type,\n      `Freshness:` = freshness\n    )\n  row.names(alts) &lt;- NULL # Drop row names\n\n  table &lt;- kbl(t(alts), escape = FALSE) |&gt;\n    kable_styling(\n      bootstrap_options = c(\"striped\", \"hover\", \"condensed\"),\n      full_width = FALSE,\n      position = \"center\"\n    )\n  function() {\n    table\n  }\n}\n\nIt is important to note that the table just shows the options, but it doesn’t allow respondents to indicate their choice. So we still need to create a basic choice question like this:\n\ncbc1_options &lt;- c(\"option_1\", \"option_2\", \"option_3\")\nnames(cbc1_options) &lt;- c(\"Option 1\", \"Option 2\", \"Option 3\")\n\nsd_question(\n  type   = 'mc_buttons',\n  id     = 'cbc_q1',\n  label  = \"(1 of 6) If the above options were your only options, which would you choose?\",\n  option = cbc1_options\n)\n\n\n\n(1 of 6) If the above options were your only options, which would you choose?\n\n\n\nOption 1\nOption 2\nOption 3\n\n\n\n\n*\n\n\n\nThe final result is a set of choice questions that each look something like this:"
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#preview-and-check",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#preview-and-check",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Preview and check",
    "text": "Preview and check\nThe rest of the server() function in the app.R file has the remaining components we need, like any conditional display or skip logic. This is all standard features of any surveydown survey, so we won’t cover them in detail here and instead direct you to the documentation for details.\nBut before you go live, it’s a good idea to do some quick testing. You can test your survey even without having it connected to a database by setting ignore = TRUE in the sd_db_connect() function. Of course, you probably should also test it after connecting it to a database to ensure that responses are being properly stored.\nWhen testing, you might get an error - don’t panic! Read the terminal output carefully and debug. There’s a good chance you may have missed a bug somewhere in your server code. Look in your app.R file to see if you can spot the error."
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#getting-the-data",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#getting-the-data",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Getting the data",
    "text": "Getting the data\nOnce your survey is live and you start collecting responses, you can easily access your data with the sd_get_data() function. This is typically done in a separate R file (e.g., see here), which might look something like this:\n\nlibrary(surveydown)\n\n# Connect to database\ndb &lt;- sd_db_connect()\n\n# Pull in the data\ndf &lt;- sd_get_data(db)\n\nFor this to work, you will first have to make sure you’ve set up your database connection using sd_db_config (see here for more).\nAnd that’s it! We hope this post was helpful, and do go check out the conjoint buttons and conjoint table templates to try out the demos yourself!"
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#footnotes",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#footnotes",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Footnotes",
    "text": "Footnotes\n\nYes, people have actually done conjoint surveys on fruit before.↩︎"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "surveydown.org",
    "section": "",
    "text": "surveydown is a flexible, open-source platform for making programmable, markdown-based surveys with , Quarto, Shiny, and PostgreSQL.\nThe  package deployment site can be accessed here.\nHere’s how it works:\n\nDesign your survey as a Quarto document using markdown and R code.\nRender your survey into a Shiny app that can be hosted online and sent to respondents.\nStore survey response data in a PostgreSQL database. We recommend Supabase as a free, secure, and easy to use option.\n\nThe surveydown  package provides functions to bring this all together.\n\nWe recommend reading the Getting Started page to get a sense of how to use surveydown and perform your basic setups. The rest of the documentation covers more details on how to use surveydown.\nThe  package deployment site can be accessed here.\n\nClick here to get started!"
  },
  {
    "objectID": "about.html#what-is-surveydown",
    "href": "about.html#what-is-surveydown",
    "title": "surveydown.org",
    "section": "",
    "text": "surveydown is a flexible, open-source platform for making programmable, markdown-based surveys with , Quarto, Shiny, and PostgreSQL.\nThe  package deployment site can be accessed here.\nHere’s how it works:\n\nDesign your survey as a Quarto document using markdown and R code.\nRender your survey into a Shiny app that can be hosted online and sent to respondents.\nStore survey response data in a PostgreSQL database. We recommend Supabase as a free, secure, and easy to use option.\n\nThe surveydown  package provides functions to bring this all together.\n\nWe recommend reading the Getting Started page to get a sense of how to use surveydown and perform your basic setups. The rest of the documentation covers more details on how to use surveydown.\nThe  package deployment site can be accessed here.\n\nClick here to get started!"
  },
  {
    "objectID": "about.html#why-surveydown",
    "href": "about.html#why-surveydown",
    "title": "surveydown.org",
    "section": "Why surveydown?",
    "text": "Why surveydown?\nMost survey platforms use graphic interfaces or spreadsheets to define survey content, making version control, collaboration, and reproducibility difficult or impossible. Surveydown was designed to address these problems. As an open-source, markdown-based platform, all survey content is defined using plain text (markdown and R code) in two files:\n\n\nsurvey.qmd: A Quarto document that contains the survey content (pages, questions, etc).\n\napp.R: An R script defining a shiny app that contains global settings (libraries, database configuration, etc.) and server configuration options (e.g., conditional page skipping / conditional display, etc.).\n\nThis approach makes it easy to reproduce, share, and version control your surveys with common tools like Git. And since all survey data is stored in a PostgreSQL database, you have total control over where your survey data lives. We recommend Supabase as a free, secure, and easy to use option.\nIn case you’re interested in the background behind the project, this blog post provides something of an origin story. Note that the design discussed in the post is now quite outdated with what ultimately became surveydown."
  },
  {
    "objectID": "about.html#authors",
    "href": "about.html#authors",
    "title": "surveydown.org",
    "section": "Authors",
    "text": "Authors\nThe surveydown project is led by professor John Paul Helveston at George Washington University and was originally developed in collaboration with his students Pingfan Hu and Bogdan Bunea.\nAs an open-source package, surveydown now has many more contributors who have added features and improved the project over time. See the Contributors’ Page for details.\n\n\n\n\n\n\nJohn Paul Helveston, Ph.D.\nJohn Paul Helveston is an Associate Professor in the Department of Engineering Management and Systems Engineering at George Washington University. Professor Helveston is the core designer and developer, and maintainer of both the surveydown project and this documentation website.\n\n\n\n\n\n\n\nPingfan Hu\nPingfan Hu is a Ph.D. student in Systems Engineering at George Washington University, supervised by professor Helveston. Pingfan is mainly responsible for UI design, user interactions, and website maintenance.\n\n\n\n\n\n\n\nBogdan Bunea\nBogdan Bunea is an undergraduate student majoring in Systems Engineering and minoring in Computer Science at George Washington University. Bogdan is mainly responsible for database connection and data management."
  },
  {
    "objectID": "about.html#license",
    "href": "about.html#license",
    "title": "surveydown.org",
    "section": "License",
    "text": "License\nSee the License page on the source code repository."
  },
  {
    "objectID": "about.html#publication",
    "href": "about.html#publication",
    "title": "surveydown.org",
    "section": "Publication",
    "text": "Publication\nAn associated paper in PLOS One about surveydown is available at https://doi.org/10.1371/journal.pone.0331002"
  },
  {
    "objectID": "about.html#citation",
    "href": "about.html#citation",
    "title": "surveydown.org",
    "section": "Citation",
    "text": "Citation\nIf you use this package in a publication, please cite the PLOS One article associated with it! You can get the citation information by typing citation(\"surveydown\") into R, or copying below.\n\n\n\n\n\n\nNoteSuggested citation\n\n\n\nHu P, Bunea B, Helveston J (2025). “surveydown: An open-source, markdown-based platform for programmable and reproducible surveys.” PLOS One, 20(8). doi:10.1371/journal.pone.0331002\n\n\nA BibTeX entry for LaTeX users is\n@Article{,\n    title = {surveydown: An open-source, markdown-based platform for programmable and reproducible surveys},\n    author = {Pingfan Hu and Bogdan Bunea and John Paul Helveston},\n    journal = {PLOS One},\n    year = {2025},\n    volume = {20},\n    number = {8},\n    doi = {10.1371/journal.pone.0331002},\n}"
  },
  {
    "objectID": "about.html#funding",
    "href": "about.html#funding",
    "title": "surveydown.org",
    "section": "Funding",
    "text": "Funding\nThis project was partially supported by a grant from the Alfred P. Sloan Foundation, Grant Number G-2023-20976 awarded to PI John Paul Helveston."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html",
    "href": "blog/2024-08-21-introducing-surveydown/index.html",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "",
    "text": "This post introduces the {surveydown} R package, a new way to design surveys using markdown, R, Quarto, and shiny. The idea for this platform has been brewing for a while (see this blog post for more on the motivation for this project), but now the package is finally here!\nIn this post, I’m going to show you a quick overview of the {surveydown} R package for making markdown-based surveys as well as a little about why we built surveydown."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#open-source",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#open-source",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Open source",
    "text": "Open source\nsurveydown is built entirely with open-source technologies, making it transparent and customizable. Best of all, no expensive licenses! Just install and use it!"
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#own-your-data",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#own-your-data",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Own your data",
    "text": "Own your data\nWith surveydown, you retain full ownership and control of your survey data. The responses are stored in your own Supabase database, ensuring that you have complete access to the data. This is particularly important for researchers dealing with sensitive information or those who need to comply with specific data protection regulations. We’re still working on enabling you to use your own hosted database, which will provide even more flexibility."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#ease-of-editing",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#ease-of-editing",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Ease of editing",
    "text": "Ease of editing\nDesigning a survey in surveydown is a pretty straightforward process. The markdown-based approach allows for quick modifications and easy navigation through your survey. And since it’s built on Quarto, you can use all of the features of Quarto to make your survey look great, like changing the theme, adding custom CSS, etc. You can also easily preview your survey as you edit it, and even run your survey locally to test it out before you deploy it, either with a button click in RStudio or with a quarto serve command in the terminal."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#did-i-mention-you-can-run-r-code-in-your-survey",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#did-i-mention-you-can-run-r-code-in-your-survey",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Did I mention you can run R code in your survey?",
    "text": "Did I mention you can run R code in your survey?\nEvery surveydown survey uses R code chunks for questions. But you can also insert R code for all sorts of other things. For example, if you wanted to randomize the values shown in a question, you could write some R code for that. Want to insert a plot of something? Write a little ggplot code. You can also add interactive components to your surveys, such as showing a respondent how their responses compare to others in real time."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#easy-version-control-and-collaboration",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#easy-version-control-and-collaboration",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Easy version control and collaboration",
    "text": "Easy version control and collaboration\nBecause the entire survey is defined in a single plain text file, surveydown naturally integrates with version control systems like Git. This allows you to track changes over time, collaborate with team members, and maintain a clear history of your survey’s development."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#reproducible",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#reproducible",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Reproducible",
    "text": "Reproducible\nSurveydown promotes reproducible research by allowing you to define your entire survey in a single, self-contained plain text document. This has a ton of benefits:\n\nWant someone else to be able to reproduce your experiment? Just give them the .qmd file and any other files they need (e.g., images, data, etc.), and they can reproduce your survey on their own computer.\nWant to print out your survey for an appendix? Render the survey with all pages visible then print it to pdf.\nWant others to see your survey live? Just set the database into pause mode and your survey will function without recording any responses.\n\nReproducibility is something we had in mind from the start with this project, and we’ve tried to make it as easy as possible for your surveydown surveys to be fully reproducible."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#getting-started",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#getting-started",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Getting started",
    "text": "Getting started\nAfter getting everything installed, we recommend starting with a template survey project. To do so, run the following in the R console:\n\nsurveydown::sd_create_survey(\"path/to/folder\")\n\nThis will create a folder with the following files:\n\n\nexample.qmd: a template survey you should edit.\n\nexample.Rproj: An RStudio project file (helpful if you’re working in RStudio)\n\n_extensions: A folder with the surveydown Quarto extension needed to make everything work (don’t modify this).\n\nIf you have the example open in RStudio, you can click the “Run document” button, or in your terminal run quarto serve example.qmd. Either approach should render the example survey into a shiny app that you can preview in a browser. Don’t worry just yet about setting up your database or making the survey live - for now, we’re going to focus on designing the survey and running it locally to preview it. The example survey should look like this:"
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#adding-pages",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#adding-pages",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Adding pages",
    "text": "Adding pages\nIn surveydown, pages are delineated using “fences”, like this:\n\n::: {#welcome .sd-page}\n\nPage 1 content here\n\n:::\n\n::: {#page2 .sd-page}\n\nPage 2 content here\n\n:::\n\nAs you can see, we use three colon symbols :::, called a “fence”, to mark the start and end of pages. This notation is commonly used in Quarto for a variety of use cases, like defining subfigures in images.\nIn the starting fence, you need to define a page name (e.g. welcome and page2 in the example above) and you need to define the class as .sd-page. Then anything you put between the page fences will appear on that page.\nTo navigate to the next page, you need to insert a sd_next() function call inside a code chunk, like this:\n\n```{r}\nsd_next(next_page = 'page2')\n```\n\nThe above code chunk will create a “Next” button that goes on to page 2 that looks like this:\n\n\n\nNext\n\n\n\nYou would need to place the code chunk in between the ::: fences of the welcome page in order to have a “Next” button that goes on to page 2. You can also send the user to other pages by just changing the next_page argument. Finally, you can also change the label of the button by changing the label argument, like this:\n\n```{r}\nsd_next(next_page = 'page2', label = 'Next page')\n```\n\n\n\n\nNext page"
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#adding-questions",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#adding-questions",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Adding questions",
    "text": "Adding questions\nEvery survey question is created using the sd_question() function inside a code chunk. The question type is defined by the type argument. For example, to add a multiple choice question, you could insert the following code chunk:\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'penguins',\n  label = \"Which is your favorite type of penguin?\",\n  option = c(\n    'Adélie'    = 'adelie',\n    'Chinstrap' = 'chinstrap',\n    'Gentoo'    = 'gentoo'\n  )\n)\n```\n\nThe above code chunk will create a multiple choice question that looks like this:\n\n\n\n\nWhich is your favorite type of penguin?\n\n\n\n\nAdélie\n\n\n\n\nChinstrap\n\n\n\n\nGentoo\n\n\n\n\n*\n\n\n\n\nThe sd_question() function can be used to create a variety of question types, like text input, select drop down choices, and more by changing the type argument.\nThe function has many other arguments for customizing the look and feel of the question (e.g., height and width, etc.)."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#the-server-chunk",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#the-server-chunk",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "The server chunk",
    "text": "The server chunk\nAt the very bottom of the .qmd file is a special “server” code chunk (that’s the #| context: server bit) that defines the app server. This is where you can customize and control the survey flow logic as well as where you define the database that will store the survey response data. It looks like this:\n\n```{r}\n#| context: server\n\n# Define the database settings\ndb &lt;- sd_database()\n\n# Define the configuration settings\nconfig &lt;- sd_config()\n\n# The sd_server() function initiates your survey - don't change this\nsd_server(\n  input   = input,\n  session = session,\n  config  = config,\n  db      = db\n)\n```\n\nThe sd_database() function is where you set up your database. The sd_server() function makes everything run, which you can safely ignore - just don’t change it and all will be good!\nThe middle part (the sd_config() function) is where you can define custom control logic for the survey, such as conditional display (conditionally displaying a question based on responses to questions), or conditional skip (conditionally sending the respondent to a page based on responses to questions)."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#going-live",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#going-live",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Going live!",
    "text": "Going live!\nOnce you are happy with your survey, you can deploy it live to any server of your choice. Since it’s a shiny app, you can deploy it to shinyapps.io for free!"
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#conditional-display",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#conditional-display",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Conditional display",
    "text": "Conditional display\nLet’s say we had a fourth option for “other” in our multiple choice question about penguins. If the respondent chose it, you may want a second question to popup that allows them to specify the other penguin type. To implement this, you would need to define both questions, e.g.:\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'penguins',\n  label = \"Which is your favorite type of penguin?\",\n  option = c(\n    'Adélie'    = 'adelie',\n    'Chinstrap' = 'chinstrap',\n    'Gentoo'    = 'gentoo',\n    'Other'     = 'other'\n  )\n)\n\nsd_question(\n  type  = \"text\",\n  id    = \"penguins_other\",\n  label = \"Please specify the other penguin type:\"\n)\n```\n\nThen in the server code chunk, you could use the show_if argument to define that the penguins_other question would only be shown if the respondent chose the other option in the penguins question, like this:\n\nconfig &lt;- sd_config(\n  show_if = tibble::tribble(\n    ~question_id,  ~question_value, ~target,\n    \"penguins\",    \"other\",         \"penguins_other\"\n  )\n)\n\nThis will make the penguins_other question only appear if the respondent chose the other option in the penguins question, like this:\n\n\n\n\nHere we’re using the tibble::tribble() function to define a data frame with three columns:\n\n\nquestion_id: The id of the triggering question.\n\nquestion_value: The triggering value.\n\ntarget: The id of the target question to display.\n\nYou don’t have to use tibble::tribble(), and in fact if you have a lot of show_if conditions, then you could create a csv file with all of your conditions in it and read it in to set the show_if conditions (just make sure the header has the same three column names), e.g.:\n\nconfig &lt;- sd_config(\n  show_if = readr::read_csv('path/to/show_if_conditions.csv')\n  )\n)"
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#conditional-skip",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#conditional-skip",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Conditional skip",
    "text": "Conditional skip\nOften times you’ll want to screen people out of a survey based on responses to questions. For example, let’s say you only wanted to only include people who own a vehicle. On your first page (e.g., with page name welcome), you could screen out people who do not own a vehicle.\nFirst, define a question about their vehicle ownership, e.g.:\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'vehicle_ownership',\n  label = \"Do you own your vehicle?\",\n  option = c(\n    'Yes' = 'yes',\n    'No'  = 'no'\n  )\n)\n```\n\nThen in the server code chunk, you could use the skip_if argument in sd_config() to define the behavior of the next button on the welcome page, like this:\n\nconfig &lt;- sd_config(\n  skip_if = tibble::tribble(\n    ~question_id,        ~question_value, ~target,\n    \"vehicle_ownership\", \"no\",            \"screenout\"\n  )\n)\n\nThis sets up a condition where if the respondent chooses no on the vehicle_ownership question, they will be sent to a page named screenout. You could put such a page at the end of the survey, something like this:\n\n::: {#screenout .sd-page}\n\nSorry, but you are not qualified to take our survey.\n\n:::\n\nNotice that I don’t have a sd_next() on this screenout page. That is how you define an end point for the survey taker. If there’s no “Next” button, then they cannot navigate anywhere else, so the survey is over."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#required-responses",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#required-responses",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Required responses",
    "text": "Required responses\nBy default, no questions are required. However, you can make questions required by adding the question id to the required argument in sd_config(), like this:\n\nconfig &lt;- sd_config(\n  required_questions = c(\"vehicle_ownership\", \"penguins_other\")\n)\n\nThis will make the respondent unable to proceed until they have answered the required questions. It will also place a red asterisk (*) next to the question label to indicate that the question is required.\nYou can also make all questions required by setting all_questions_required = TRUE like this:\n\nconfig &lt;- sd_config(\n  all_questions_required = TRUE\n)"
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#reactivity",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#reactivity",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Reactivity",
    "text": "Reactivity\nOne other feature that is particularly powerful is the ability to use R code in your survey via Shiny’s reactive programming. This allows you to make your survey more interactive and to use the full power of R to create custom functionality.\nDemo 1: Displaying content based on previous responses\nLet’s say you wanted to create a survey that asked the respondent’s name, and then displayed a personalized message based on their name. You could do this by first asking their name:\n\nsd_question(\n  type  = \"text\",\n  id    = \"name\",\n  label = \"What is your name?\"\n)\n\nThen you can use the sd_display_value(\"name\") function to display the value of the name question in other parts of your survey. For example:\n\nWelcome, `r sd_display_value(\"name\")`!\n\nWhich would render as something like “Welcome, Dave!” (assuming the respondent entered “Dave” in the name question). This works because the sd_display_value() function is reactive, meaning it will update the display based on the respondent’s responses.\nDemo 2: Displaying randomized question labels\nLet’s say you wanted to show a series of questions, but you wanted to randomize the labels shown for each question. You could do this by first defining a list of labels, and then using the sd_question_reactive() function to create a question that will display a random label from the list.\nFor example, let’s ask the respondent to rate different car brands from a random set of brands. You could first pre-define the randomized sets of brands for each respondent and store it as a csv file, like this:\n\nbrands &lt;- c(\"Toyota\", \"Ford\", \"Chevrolet\", \"Honda\", \"Nissan\", \"Tesla\")\ndesign &lt;- data.frame(\n  respondent_id = rep(1:10, each = 3),\n  brand = unlist(lapply(1:10, function(x) sample(brands, 3, replace = FALSE)))\n)\nwrite_csv(design, \"design.csv\")\n\nThis would make a design file that looks like this:\n\n\n#&gt;   respondent_id     brand\n#&gt; 1             1    Nissan\n#&gt; 2             1      Ford\n#&gt; 3             1     Honda\n#&gt; 4             2     Honda\n#&gt; 5             2     Tesla\n#&gt; 6             2 Chevrolet\n\n\nNote that this would not be done in your survey.qmd file - it’s just a one-time thing to create the design (probably stored in an R file).\nThen in your server code chunk, you could read in the design file and use it to randomize the labels for each question based on a randomly chosen respondent:\n\ndesign &lt;- read_csv(\"design.csv\")\nresp_id &lt;- sample(design$respondent_id, 1)\ndf_resp &lt;- design %&gt;% filter(respondent_id == resp_id)\n\noptions &lt;- c(1, 2, 3)\nnames(options) &lt;- df_resp$brand\n\nsd_question_reactive(\n  type  = \"mc\",\n  id    = \"brands\",\n  label = \"Which of these brands do you like best?\",\n  option = options\n)\n\nHere the sd_question_reactive() function is used because the labels depend on the randomly chosen respondent. This means the labels will be different for each respondent.\nSince this is a reactive question, this code must be placed inside the server code chunk, not where you want it to appear in the survey. To define where in the survey the question should appear, you use the sd_display_question() function with the id set to the same value as the id in the sd_question_reactive() function, like this:\n\nsd_display_question(id = \"brands\")\n\nNow the brands question will be displayed in the survey where you put this code chunk.\nNote that all question responses are automatically saved to the database, but if you wanted to store some other value (e.g. the randomly chosen respondent_id), you could do that with the sd_store_value() function, like this:\n\nsd_store_value(resp_id)"
  },
  {
    "objectID": "blog/2024-09-18-new-app-design/index.html",
    "href": "blog/2024-09-18-new-app-design/index.html",
    "title": "New architecture in v0.3.0 (and loads of breaking changes)!",
    "section": "",
    "text": "The surveydown package is only a couple months old, and thanks to many early users we learned about some design flaws that needed to be fixed. As a result, with the release of {surveydown} 0.3.0, the package has undergone a major overhaul to improve security, modularity, and extensibility.\nWe introduced several major breaking changes in this release, so we felt we should make a blog post to both explain why we felt these changes were needed as well as introduce the new architecture we have adopted."
  },
  {
    "objectID": "blog/2024-09-18-new-app-design/index.html#motivation",
    "href": "blog/2024-09-18-new-app-design/index.html#motivation",
    "title": "New architecture in v0.3.0 (and loads of breaking changes)!",
    "section": "Motivation",
    "text": "Motivation\nIn the original conception of surveydown, the entire survey was defined in a single Quarto shiny document that would render into a shiny app. While this was a rather parsimonious design, it also had some flaws that weren’t immediately apparent.\nPerhaps the largest issue was page security (see this issue). With Quarto shiny documents, the qmd file is first rendered into a static html page that is then used to define the elements of the user interface in the resulting shiny app. This meant that for us to introduce pages, we relied on a combination of JS and CSS to hide and show the page divs based on users clicking on next buttons. While this resulted in a nice user experience, under the hood the entire app was still just one big html page with all of the content available.\nThis design meant that anyone could still see the source code to any component of the survey they wanted. A user could simply right-click and open “Inspect” then manually change the CSS of a page div from style=\"display: none;\" to style=\"display: show;\" and boom - the “page” would appear!\nThis was obviously a major security issue as pages with things like completion codes or redirect buttons at the end could be easily shown without going through the whole survey. The only solution was an architectural overhaul that would only show the content on one page at a time."
  },
  {
    "objectID": "blog/2024-09-18-new-app-design/index.html#new-architecture",
    "href": "blog/2024-09-18-new-app-design/index.html#new-architecture",
    "title": "New architecture in v0.3.0 (and loads of breaking changes)!",
    "section": "New architecture",
    "text": "New architecture\nThe new architecture employs a two-file design composed of a survey and an app that renders to a traditional Shiny app:\n\n\nsurvey.qmd: A Quarto document that contains the survey content (pages, questions, etc), which renders to an HTML file.\n\napp.R: An R script defining a Shiny app that contains the global settings (libraries, database configuration, etc.) and server configuration options (e.g., conditional skipping / display, etc.).\n\nThese files must be named survey.qmd and app.R.\nThey typically look something like this:\n\n\nsurvey.qmd file\napp.R file\n\n\n\n---\nformat: html\necho: false\nwarning: false\n---\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(surveydown)\n```\n:::\n\n\n::: {#welcome .sd-page}\n\n# Welcome to our survey!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsd_question(\n  type  = 'mc',\n  id    = 'penguins',\n  label = \"Which type of penguin do you like the best?\",\n  option = c(\n    'Adélie'    = 'adelie',\n    'Chinstrap' = 'chinstrap',\n    'Gentoo'    = 'gentoo'\n  )\n)\n\nsd_next(next_page = 'end')\n```\n:::\n\n\n:::\n\n::: {#end .sd-page}\n\nThis it the last page in the survey\n\n:::\n\n\n\nlibrary(surveydown)\n\ndb &lt;- sd_database(\n  host   = \"\",\n  dbname = \"\",\n  port   = \"\",\n  user   = \"\",\n  table  = \"\",\n  ignore = TRUE\n)\n\nserver &lt;- function(input, output, session) {\n\n  # Define conditional skip logic here (skip to page if a condition is true)\n  sd_skip_if()\n\n  # Define  conditional display logic here (show a question if a condition is true)\n  sd_show_if()\n\n  # Main server to control the app\n  sd_server()\n}\n\nshiny::shinyApp(ui = sd_ui(), server = server)\n\n\n\n\nThis approach allows us to separate the survey content (in the survey.qmd file) from the survey logic (in the app.R file), which comes with a few benefits:\n\n\nSecurity: Since the rendered survey content is no longer directly embedded in the app as a single html page, it makes it much harder for users to tamper with the content. Only the content on one page at a time will be rendered by the server.\n\nClarity: With two files, it is now clearer where the survey content versus control logic should be defined. Before, all of the server logic was in a single server code chunk at the end of the survey.qmd file, which required the user to scroll up and down to edit the server logic versus the survey content. Now a user can have both files open in two tabs in an IDE and more easily edit the survey content and server content.\n\nSimplicity: The new design eliminates the need for a Quarto extension to render the survey. This allows us to ship all of the core functionality of surveydown as a single R package, which is installed globally on your system.\n\nThe updated documentation of the Survey Components page reflects this new design."
  },
  {
    "objectID": "blog/2024-09-18-new-app-design/index.html#new-page-architecture",
    "href": "blog/2024-09-18-new-app-design/index.html#new-page-architecture",
    "title": "New architecture in v0.3.0 (and loads of breaking changes)!",
    "section": "New page architecture",
    "text": "New page architecture\nThe motivation to secure the page content led to a totally new approach to designing the survey pages. Our new approach actually renders the survey.qmd into a static html page and then parses it into a list of page objects. Each page object is itself a list of elements, including the page ID, question IDs, etc., as well as the rendered html content for that page.\nThe sd_server() function then uses this list of page objects to display one page at a time via a shiny::renderUI() function into a single “main” output. This approach allowed us to control what content is being served, eliminating the ability of survey respondents to see anything other than the content on the current page.\nThis approach also gave us the opportunity to overhaul how pagination works in general. Previously, users had to add a sd_next(next_page = \"page_id\") button at the end of each page, making sure to specify the next page to go to. This was a bit annoying as most of the time you just want to go to the next page, so specifying it felt redundant. Now users can simply add sd_next() at the bottom of each page and the server will go to the next page by default. If you want to direct the respondent to a different page, then you specify the target page using sd_next(next_page = \"page_id\")."
  },
  {
    "objectID": "blog/2024-09-18-new-app-design/index.html#improved-conditional-show-and-skip-logic",
    "href": "blog/2024-09-18-new-app-design/index.html#improved-conditional-show-and-skip-logic",
    "title": "New architecture in v0.3.0 (and loads of breaking changes)!",
    "section": "Improved conditional show and skip logic",
    "text": "Improved conditional show and skip logic\nConditionally displaying questions or skipping to pages is a core logic that many surveys need. Our original approach was relatively clunky, so since we were already introducing many breaking designs, we figured we should overhaul the logic for conditional skipping and displaying.\nThe new approach uses just two functions: sd_skip_if() and sd_show_if(). These functions can be provided in the main server() function in the app.R file to define the conditions and targets for either conditional displaying a question or conditionally skipping to a page. The structure for each condition in these new functions is always as follows:\n\n&lt;condition&gt; ~ \"target_question_id\"\n\nAs an example, let’s say we want to show a question called \"penguins_other\" if the respondent chose the \"other\" option in a question called \"penguins\". We could do this with the following code in the app.R file:\n\nserver &lt;- function(input, output, session) {\n\n  sd_show_if(\n    input$penguins == \"other\" ~ \"penguins_other\"\n  )\n\n  sd_server(db = db)\n\n}\n\nYou can provide multiple conditions to the sd_show_if() function, each separated by a comma. The sd_skip_if() function works the same way, but it will skip to a target page instead of showing a target question. See the revised Conditional Control page for more details on the new changes."
  },
  {
    "objectID": "blog/2024-09-18-new-app-design/index.html#no-more-sd_config-function",
    "href": "blog/2024-09-18-new-app-design/index.html#no-more-sd_config-function",
    "title": "New architecture in v0.3.0 (and loads of breaking changes)!",
    "section": "No more sd_config() function",
    "text": "No more sd_config() function\nOne more small change we made is that the sd_config() function is no longer needed. Since we moved the conditional skip and show logic into their own functions, we took the remaining arguments that used to be provided to sd_config() and added them to the sd_server() function as options. You can now simply pass these arguments to the sd_server() function in the app.R file."
  },
  {
    "objectID": "blog/2024-09-18-new-app-design/index.html#our-apologies",
    "href": "blog/2024-09-18-new-app-design/index.html#our-apologies",
    "title": "New architecture in v0.3.0 (and loads of breaking changes)!",
    "section": "Our apologies",
    "text": "Our apologies\nThat’s about it for the changes with v0.3.0. We want to send our deepest apologies for anyone who has already begun a study using the orginal design. The most recent version prior to v0.3.0 was v0.2.4, so this is the version you should install if you want to stick with the old design.\nThat said, all development will now continue on this new design, so we strongly recommend updating to the new version and converting any existing surveys to the new design. The biggest change you’ll need to make is to move your server logic out of the survey.qmd file and into the app.R file. We’ve also updated all our demos to the new design, so you can refer to these for examples on how to convert your existing surveys."
  },
  {
    "objectID": "blog/2025-04-08-surveydown-gadgets/index.html",
    "href": "blog/2025-04-08-surveydown-gadgets/index.html",
    "title": "surveydown Gadgets for Page and Question Creation",
    "section": "",
    "text": "Note\n\n\n\nAs of version 0.10.0, surveydown now has shiny gadgets to make it easier to insert pages and questions into your survey.qmd file. This post highlights how to use them in your survey building workflow.\nTo view a full-course survey building workflow, proceed to the Basic Components page."
  },
  {
    "objectID": "blog/2025-04-08-surveydown-gadgets/index.html#introduction",
    "href": "blog/2025-04-08-surveydown-gadgets/index.html#introduction",
    "title": "surveydown Gadgets for Page and Question Creation",
    "section": "1 Introduction",
    "text": "1 Introduction\nWhile surveydown works with various IDEs, the gadget features perform best in RStudio. These gadgets provide a user-friendly interface for creating survey elements without having to remember the exact syntax or function parameters.\nTwo primary gadgets are offered by surveydown:\n\nSurvey Page Gadget - Creates a new survey page\nSurvey Question Gadget - Creates a new survey question\n\nHere is a showcase of the Survey Page Gadget in RStudio:\n\n\n\n\n\nThe Survey Question Gadget:\n\n\n\n\n\nAs you can see, these gadgets simplify the process of adding survey components. This blog walks you through how to access and use these gadgets."
  },
  {
    "objectID": "blog/2025-04-08-surveydown-gadgets/index.html#accessing-the-gadgets",
    "href": "blog/2025-04-08-surveydown-gadgets/index.html#accessing-the-gadgets",
    "title": "surveydown Gadgets for Page and Question Creation",
    "section": "2 Accessing the Gadgets",
    "text": "2 Accessing the Gadgets\nThe gadgets are powered by the sd_page_gadget() and sd_question_gadget() functions, but you don’t need to call these functions directly.\nYou can access these gadgets in RStudio in two ways:\n\n2.1 Using the Addins Menu\n\nClick on the “Addins” dropdown menu in the RStudio toolbar\nType “surveydown” in the search box\nSelect either “Add Survey Page” or “Add Survey Question”\n\nBelow is a screenshot of the Addins menu with surveydown gadgets:\n\n\n\n\n\n\n\n2.2 Keyboard Shortcuts (Recommended)\nFor more efficient workflow, set up keyboard shortcuts:\n\nGo to Tools → Addins → Browse Addins…\n\n\n\n\n\n\n\nIn the Addins popup window, click on the “Keyboard shortcuts…” button on the bottom left corner.\n\n\n\n\n\n\n\nInput “survey” in the search box.\n\n\n\n\n\n\n\nAssign the following shortcuts:\n\nCtrl+Shift+P for the Survey Page Gadget\nCtrl+Shift+Q for the Survey Question Gadget\n\nOr if you have other preferences, feel free to customize them."
  },
  {
    "objectID": "blog/2025-04-08-surveydown-gadgets/index.html#using-the-gadgets",
    "href": "blog/2025-04-08-surveydown-gadgets/index.html#using-the-gadgets",
    "title": "surveydown Gadgets for Page and Question Creation",
    "section": "3 Using the Gadgets",
    "text": "3 Using the Gadgets\n\n3.1 Survey Page Gadget\n\n\n\n\n\nThe page gadget is straightforward:\n\nPress Ctrl+Shift+P (or use the Addins menu)\nEnter a Page ID (no spaces allowed)\nClick “Create Page” or press Enter\n\nThis will insert a properly formatted page block at your cursor position, including an R code chunk ready for adding questions.\n\n\n3.2 Survey Question Gadget\n\n\n\n\n\nThe question gadget offers more options:\n\nPress Ctrl+Shift+Q (or use the Addins menu)\nFill in the following:\n\nQuestion Type: Select from the dropdown (default is “Multiple Choice”)\nQuestion ID: Enter a unique identifier (no spaces)\nQuestion Label: Enter the actual question text\n\nR Chunk Option: Check this box if you need the question to be inserted within an R code chunk\nClick “Create Question” or press Enter\n\nNote that if you created the question inside an existing page’s R chunk, you don’t need to check the “R Chunk Option”. If you’re adding a question elsewhere and need it to be in an R chunk, check that box."
  },
  {
    "objectID": "blog/2025-04-08-surveydown-gadgets/index.html#example-workflow",
    "href": "blog/2025-04-08-surveydown-gadgets/index.html#example-workflow",
    "title": "surveydown Gadgets for Page and Question Creation",
    "section": "4 Example Workflow",
    "text": "4 Example Workflow\nHere’s how a typical workflow might look:\n\nCreate a new page:\n\nPress Ctrl+Shift+P\nKey in your Page ID\nPress Enter\n\nAdd a question:\n\nPress Ctrl+Shift+Q\nSelect your desired question type\nKey in your Question ID\nKey in your Question Label\nPress Enter\nModify your Question Options as needed\n\nAdd more questions as needed by repeating step 2.\n\nBy following these steps and using the gadgets, you’ll create well-structured surveys much faster than coding everything manually."
  },
  {
    "objectID": "blog/index.html",
    "href": "blog/index.html",
    "title": "Blog",
    "section": "",
    "text": "Introducing sdstudio: A companion GUI for surveydown\n\n\n\n\n\nA brief walkthrough of the sdstudio R Package, a companion GUI for surveydown. \n\n\n\n\n\n2025-06-29\n\n\nJohn Paul Helveston, Pingfan Hu\n\n\n\n\n\n\n\n\n\n\n\n\nsurveydown Gadgets for Page and Question Creation\n\n\n\n\n\nA brief walkthrough of surveydown gadgets for creating pages and questions using RStudio.\n\n\n\n\n\n2025-04-08\n\n\nJohn Paul Helveston, Pingfan Hu\n\n\n\n\n\n\n\n\n\n\n\n\nsurveydown is on CRAN 🎉!\n\n\n\n\n\nIt’s actually been on CRAN since v0.4.0, but we’ve been making so many updates that we’re now already on v0.7.2!\n\n\n\n\n\n2024-12-20\n\n\nJohn Paul Helveston\n\n\n\n\n\n\n\n\n\n\n\n\nNew architecture in v0.3.0 (and loads of breaking changes)!\n\n\n\n\n\nWe’re releasing v0.3.0, and with it multiple breaking changes.\n\n\n\n\n\n2024-09-18\n\n\nJohn Paul Helveston\n\n\n\n\n\n\n\n\n\n\n\n\nChoice-based conjoint surveys in R with surveydown\n\n\n\n\n\nA how-to guide for using R to design and implement choice-based conjoint surveys using the surveydown R package\n\n\n\n\n\n2024-08-28\n\n\nJohn Paul Helveston\n\n\n\n\n\n\n\n\n\n\n\n\nIntroducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny\n\n\n\n\n\nA quick overview of the {surveydown} R package for making markdown-based surveys with open-source technologies: Quarto, shiny, and supabase.\n\n\n\n\n\n2024-08-21\n\n\nJohn Paul Helveston\n\n\n\n\n\nNo matching items\n Back to top"
  },
  {
    "objectID": "docs/basic-components.html",
    "href": "docs/basic-components.html",
    "title": "Basic Components",
    "section": "",
    "text": "Every surveydown survey is composed of a survey and an app, defined in two separate files:\n\n\nsurvey.qmd: This file is where you define all of the main survey content, such as pages, questions, and navigation buttons. It is a standard Quarto document, so you can use any text editor or IDE to insert text, images, etc. just like you would in any Quarto document. See the survey.qmd section for details.\n\napp.R: This file is where you define the global settings (libraries, database configuration, etc.) and server logic (e.g., conditional page skipping / question display, etc.) for your survey. It defines a Shiny app, so if you are familiar with Shiny you should feel right at home. See the app.R section for details.\n\n\n\n\n\n\n\nNote\n\n\n\nYou do NOT need to render the survey.qmd file, and in fact we do not recommend doing so as the rendered output will not necessarily look like your final survey. Instead, to preview your survey you should locally run your survey by running the app.R file.\n\n\nHere is an example set of files for a basic survey:\n\n\nsurvey.qmd\napp.R\n\n\n\n\n---\nformat: html\necho: false\nwarning: false\n---\n\n```{r}\nlibrary(surveydown)\n```\n\n::: {.sd_page id=welcome}\n\n# Welcome to our survey!\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'penguins',\n  label = \"Which type of penguin do you like the best?\",\n  option = c(\n    'Adélie'    = 'adelie',\n    'Chinstrap' = 'chinstrap',\n    'Gentoo'    = 'gentoo'\n  )\n)\n\nsd_next()\n```\n\n:::\n\n::: {.sd_page id=end}\n\nThis is the last page of the survey.\n\n```{r}\nsd_close()\n```\n\n:::\n\n\n\n\nlibrary(surveydown)\n\n# Connects to database\ndb &lt;- sd_db_connect()\n\n# Main UI\nui &lt;- sd_ui()\n\nserver &lt;- function(input, output, session) {\n  # Main server\n  sd_server(db)\n}\n\nshiny::shinyApp(ui = ui, server = server)",
    "crumbs": [
      "Documentation",
      "Survey Basics",
      "Basic Components"
    ]
  },
  {
    "objectID": "docs/basic-components.html#overview",
    "href": "docs/basic-components.html#overview",
    "title": "Basic Components",
    "section": "",
    "text": "Every surveydown survey is composed of a survey and an app, defined in two separate files:\n\n\nsurvey.qmd: This file is where you define all of the main survey content, such as pages, questions, and navigation buttons. It is a standard Quarto document, so you can use any text editor or IDE to insert text, images, etc. just like you would in any Quarto document. See the survey.qmd section for details.\n\napp.R: This file is where you define the global settings (libraries, database configuration, etc.) and server logic (e.g., conditional page skipping / question display, etc.) for your survey. It defines a Shiny app, so if you are familiar with Shiny you should feel right at home. See the app.R section for details.\n\n\n\n\n\n\n\nNote\n\n\n\nYou do NOT need to render the survey.qmd file, and in fact we do not recommend doing so as the rendered output will not necessarily look like your final survey. Instead, to preview your survey you should locally run your survey by running the app.R file.\n\n\nHere is an example set of files for a basic survey:\n\n\nsurvey.qmd\napp.R\n\n\n\n\n---\nformat: html\necho: false\nwarning: false\n---\n\n```{r}\nlibrary(surveydown)\n```\n\n::: {.sd_page id=welcome}\n\n# Welcome to our survey!\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'penguins',\n  label = \"Which type of penguin do you like the best?\",\n  option = c(\n    'Adélie'    = 'adelie',\n    'Chinstrap' = 'chinstrap',\n    'Gentoo'    = 'gentoo'\n  )\n)\n\nsd_next()\n```\n\n:::\n\n::: {.sd_page id=end}\n\nThis is the last page of the survey.\n\n```{r}\nsd_close()\n```\n\n:::\n\n\n\n\nlibrary(surveydown)\n\n# Connects to database\ndb &lt;- sd_db_connect()\n\n# Main UI\nui &lt;- sd_ui()\n\nserver &lt;- function(input, output, session) {\n  # Main server\n  sd_server(db)\n}\n\nshiny::shinyApp(ui = ui, server = server)",
    "crumbs": [
      "Documentation",
      "Survey Basics",
      "Basic Components"
    ]
  },
  {
    "objectID": "docs/basic-components.html#survey.qmd-1",
    "href": "docs/basic-components.html#survey.qmd-1",
    "title": "Basic Components",
    "section": "survey.qmd",
    "text": "survey.qmd\nThe survey.qmd file is where you will define all of the main survey content, such as pages, questions, and navigation buttons.\nYAML header\nThe YAML header is at the top of the survey.qmd file. It contains some basic settings, like this:\n---\nformat: html\necho: false\nwarning: false\n---\nThe format: html setting is optional since by default a Quarto doc is formatted as HTML. We put it here to explicitly state that this document should be rendered as an HTML document. The other settings, echo: false and warning: false, are recommended for a clean user experience, so that the survey does not display any code scripts or warnings to the participants.\nThe YAML header can also contain other survey settings, such as theme settings and survey behavior settings. See the Survey Settings page for details.\nThe rest of the content in the survey.qmd file is the content you want in your survey, including pages, navigation buttons, and questions.\nDefining pages\nIn surveydown, pages are defined using fences (:::), like this:\n\n::: {.sd_page id=page1}\n\nPage 1 content here\n\n:::\n\n::: {.sd_page id=page2}\n\nPage 2 content here\n\n:::\n\nWe use three colon symbols :::, called a “fence”, to mark the start and end of pages. In the starting fence, you need to define the class as .sd_page and provide a page id (e.g. welcome and page2 in the example above). If you are using RStudio, you can also make use of the page gadget to create pages under the “Addins” dropdown menu. Here is what the Survey Page Gadget looks like in RStudio:\n\n\n\n\nAdding navigation buttons\nTo navigate to the next page, you need to insert a sd_next() function call inside a code chunk, like this:\n\n```{r}\nsd_next()\n```\n\nThe above code chunk will create a “Next” button that goes on to the immediate next page. The button will look like this:\n\n\n\nNext\n\n\n\nYou can also provide an alternative label on the next page button using the label argument, and you can send the user to other pages by just changing the value assigned to the next_page argument. For example, to send the user to a page with the id page3, you can use:\n\n```{r}\nsd_next(label = \"Go to page 3\", next_page = 'page3')\n```\n\n\n\n\nGo to page 3\n\n\n\nYou can conditionally override these controls using the sd_skip_forward() function in your server function. See the Conditional Survey Flow page or Page Navigation page for more details.\nAdding questions\nEvery survey question is created using the sd_question() function inside a code chunk. The question type is defined by the type argument. For example, to add a multiple choice question, you could insert the following code chunk:\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'penguins',\n  label = \"Which is your favorite type of penguin?\",\n  option = c(\n    'Adélie'    = 'adelie',\n    'Chinstrap' = 'chinstrap',\n    'Gentoo'    = 'gentoo'\n  )\n)\n```\n\nThe above code chunk will create a multiple choice question that looks like this:\n\n\n\n\nWhich is your favorite type of penguin?\n\n\n\n\nAdélie\n\n\n\n\nChinstrap\n\n\n\n\nGentoo\n\n\n\n\n*\n\n\n\nThe sd_question() function can be used to create a variety of question types, like text input, select drop down choices, and more by changing the type argument (see the Questions Types page).\nThe function has many other arguments for customizing the look and feel of the question, such as the height and width (see the Question Formatting page).\nBy default all questions are optional, but you can make questions required in the survey settings (see the Survey Settings page for details).\nSimilar to page creation, you can also make use of the question gadget to create questions under the “Addins” dropdown menu following similar operations. Below is a showcase of the Survey Question Gadget in RStudio:\n\n\n\n\nEnding the survey\nThe simplest way to end a survey is to create a page with no sd_next() button on it. This will effectively serve as a ending page, because the respondent will not be able to navigate anywhere else once reaching a page with no next button.\nFor example, you may want to have a screen-out page that respondents are sent to if they answer a certain way on a question (e.g., see Conditional Survey Flow). You can do this by creating a page with no sd_next() button on it, like this:\n\n::: {.sd_page id=screenout}\n\nSorry, you are not eligible for this survey.\n\nYou can close this window now.\n\n:::\n\nWhen a respondent reaches this page, they will not be able to navigate anywhere else, so the survey is over.\nYou can also add a button to end the survey programmatically using the sd_close() function inside a code chunk, like this:\n\n```{r}\nsd_close()\n```\n\nThis will create a button with the label “Exit Survey” that the respondent can click on to close the survey window. If you want to customize the label, use the label argument, like this:\n\n```{r}\nsd_close(label = 'Close Window')\n```\n\nThis button can be added anywhere in the survey, not necessarily on the last page - all it does is close the browser window.\nFinally, you can also add a button to end the survey and redirect the respondent to another page. You can do this using the sd_redirect() function, like this:\n\n\nCode chunk\nOutput\n\n\n\n\nsd_redirect(\n  id     = \"redirect\",\n  url    = \"https://www.google.com\",\n  label  = \"Redirect to Google\",\n  button = TRUE,\n  newtab = TRUE\n)\n\n\n\n\n\n\n\nRedirect to Google\n\n\n\n\n\n\n\nThis will create a button with the label “Redirect to Google” that the respondent can click on to be redirected to Google. You can also customize the url to include url parameters. See the External Redirect page for more details.",
    "crumbs": [
      "Documentation",
      "Survey Basics",
      "Basic Components"
    ]
  },
  {
    "objectID": "docs/basic-components.html#app.r-1",
    "href": "docs/basic-components.html#app.r-1",
    "title": "Basic Components",
    "section": "app.R",
    "text": "app.R\nThe main components of the app.R file are:\n\n\nGlobal settings: where you load the surveydown package and define the database connection.\n\nServer: where you define the logic of the survey (conditional question display / conditional survey flow, etc.)\n\nGlobal settings\nThe global settings are at the top of the app.R file. At a minimum, you need to load the surveydown package and define the database connection. You can also load other packages / global objects here if you need to. It typically looks like this:\n\nlibrary(surveydown)\n\n# sd_db_config()\ndb &lt;- sd_db_connect()\n\nThe db object is used to store survey data - see the Storing Data page for details on how to set up the database connection.\nServer\nThe server() function is a standard Shiny server function that takes input, output, and session as arguments. It is where you can set custom control logic and other configuration options, such as conditional question display logic with the sd_show_if() function, or conditional survey flow logic with the sd_skip_forward() function.\nIf you create a new survey using a template, the server() function looks like this:\n\nserver &lt;- function(input, output, session) {\n\n  # Define conditional skip logic (skip forward to page if a condition is TRUE)\n  sd_skip_forward()\n\n  # Define conditional display logic (show a question if a condition is TRUE)\n  sd_show_if()\n\n  # Main server to control the app\n  sd_server(db = db)\n\n}\n\nThe sd_server() function at the bottom makes everything run. It also includes some optional arguments that you can use to customize the survey.\nSee the Survey Settings page for details on the different options you can use to customize the server.\n\n\n\n\n\n\nNote\n\n\n\nThe db = db argument in sd_server() is required if you are using a database connection, which should be defined using the sd_database() function as mentioned above in the Global Settings section. See the Store Data page for more details.\n\n\nLaunch app\nAt the very bottom of the app.R file, you will see the following code:\n\nshiny::shinyApp(ui = sd_ui(), server = server)\n\nThis code defines the Shiny app and should always be at the bottom of the app.R file.\n\n\n\n\n\n\nNote\n\n\n\nWhat’s with the sd_ui() thing?\nIn a typical Shiny app, you have to define the UI and server functions separately. In a surveydown survey, the UI is a fixed structure that is defined by the sd_ui() function, so simply provide it to the ui argument in shiny::shinyApp() to run the survey.\n\n\nLocal run\nTo preview your survey, you can run the Shiny app locally by clicking the “Run App” button in RStudio or in your R console run the code shiny::runApp('app.R'). Typically, RStudio will launch the app in a new window, but you can also choose to have the app launch in a dedicated viewer pane, or in your external web browser. Make your selection by clicking the icon next to Run App:",
    "crumbs": [
      "Documentation",
      "Survey Basics",
      "Basic Components"
    ]
  },
  {
    "objectID": "docs/basic-components.html#architecture",
    "href": "docs/basic-components.html#architecture",
    "title": "Basic Components",
    "section": "Architecture",
    "text": "Architecture\nIf you are interested in what is happening under the hood, here is a flow diagram that illustrates the overall architecture of a typical surveydown survey application:\n\n\n\n\nFollowing this flow diagram, survey designers only need to edit survey.qmd and app.R. Since the survey is launched by app.R, which holds the core control logic of the survey, we’ve placed it at top left as starting point of the logic flows.\nIn app.R, we have three logic flows:\n\n\nsd_db_connect(), as colored in green, creates database connection.\n\nsd_ui(), in orange, serves two purposes: 1) it renders the survey.qmd file into survey content in the “_survey” folder, and re-renders if changes detected; 2) it initializes the user interface container for the survey app.\n\nsd_server(), in blue, also serves two purposes: 1) it grabs the generated “_survey” folder and serves processed page content to the survey app; 2) it updates database with responses.\n\nOn the right most part of the flow diagram, we reach to the ending point of the logic flow. The survey app is what is presented to the survey participants, and the data in PostgreSQL is a collection of survey results for survey analysts to study for. As this flow diagram illustrates, the surveydown platform is the one product that streamlines the experience of survey designers, survey participants, and survey analysts.",
    "crumbs": [
      "Documentation",
      "Survey Basics",
      "Basic Components"
    ]
  },
  {
    "objectID": "docs/custom-questions.html",
    "href": "docs/custom-questions.html",
    "title": "Custom Questions",
    "section": "",
    "text": "If you have an html widget that isn’t yet directly supported by surveydown, you can still use it by defining it in the server and using the sd_question_custom() function to store the value in the resulting survey data.",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Custom Questions"
    ]
  },
  {
    "objectID": "docs/custom-questions.html#basic-syntax",
    "href": "docs/custom-questions.html#basic-syntax",
    "title": "Custom Questions",
    "section": "Basic Syntax",
    "text": "Basic Syntax\nUse the sd_question_custom() function to create custom questions. The function requires the following arguments:\n\n\nid: A unique identifier for the question, which will be used as the variable name in the resulting survey data (just like the id in sd_question()).\n\nlabel: The label that will be displayed on the question in the survey.\n\noutput: The output widget. This needs to be an output function designed for shiny, e.g. leafletOutput(), plotOutput(), etc.\n\nvalue: The value to be returned by the question. This must be a reactive value that updates based on user interaction with the output widget (e.g. selecting a state on a leaflet map).\n\nheight (optional): The height of the widget in pixels, defaults to 400.\n\nBelow is the basic syntax for creating a custom question:\nsd_question_custom(\n  id     = \"some_id\",\n  label  = \"Some Label\",\n  output = \"some_output_widget\",\n  value  = \"some_reactive_value\"\n)\nTo make sd_question_custom() work, you need to define the UI and functionality you want in the server() function in the app.R file. We have two examples that show how to set this up: an interactive map using leaflet, and an interactive plot using plotly.",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Custom Questions"
    ]
  },
  {
    "objectID": "docs/custom-questions.html#leaflet-map-example",
    "href": "docs/custom-questions.html#leaflet-map-example",
    "title": "Custom Questions",
    "section": "Leaflet Map Example",
    "text": "Leaflet Map Example\nTo reproduce this example, proceed to the Custom Leaflet Map template. This template has a leaflet map that looks like the map below. When a user clicks on the map, it turns orange and stores the selected state in the resulting survey response data:\n\nWhich state do you live in?",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Custom Questions"
    ]
  },
  {
    "objectID": "docs/custom-questions.html#plotly-chart-example",
    "href": "docs/custom-questions.html#plotly-chart-example",
    "title": "Custom Questions",
    "section": "Plotly Chart Example",
    "text": "Plotly Chart Example\nTo reproduce this example, proceed to the Custom Plotly Chart template. This template has a plotly scatterplot map that looks like the chart below. When a user clicks on one of the points, it displays the point value and stores the point in the resulting survey response data:\n\nClick on a point to select it:",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Custom Questions"
    ]
  },
  {
    "objectID": "docs/deployment.html",
    "href": "docs/deployment.html",
    "title": "Deploying Your Survey",
    "section": "",
    "text": "Before deploying your survey, make sure everything is working locally. You should have done the following:\n\nYou have locally previewed your app.R file by clicking the “Run App” button in RStudio or in your R console running the code shiny::runApp('app.R').\nYou have set up a database connection to store survey responses (e.g. using Supabase) and have already stored the database credentials using the sd_db_config() function (see the Storing Data page for details).\n\nWith these steps completed, you are ready to deploy your survey online.",
    "crumbs": [
      "Documentation",
      "Deployment & Operations",
      "Deployment"
    ]
  },
  {
    "objectID": "docs/deployment.html#preparing-to-deploy",
    "href": "docs/deployment.html#preparing-to-deploy",
    "title": "Deploying Your Survey",
    "section": "",
    "text": "Before deploying your survey, make sure everything is working locally. You should have done the following:\n\nYou have locally previewed your app.R file by clicking the “Run App” button in RStudio or in your R console running the code shiny::runApp('app.R').\nYou have set up a database connection to store survey responses (e.g. using Supabase) and have already stored the database credentials using the sd_db_config() function (see the Storing Data page for details).\n\nWith these steps completed, you are ready to deploy your survey online.",
    "crumbs": [
      "Documentation",
      "Deployment & Operations",
      "Deployment"
    ]
  },
  {
    "objectID": "docs/deployment.html#deploying-to-shinyapps.io",
    "href": "docs/deployment.html#deploying-to-shinyapps.io",
    "title": "Deploying Your Survey",
    "section": "Deploying to shinyapps.io",
    "text": "Deploying to shinyapps.io\nDeploying your survey is pretty much the same as deploying any other Shiny app. We recommend using shinyapps.io to host your survey as it is designed to work with Shiny Apps, but you can also use other hosting services.\n\n\n\n\n\n\nNote\n\n\n\nYou may have deployed other Quarto documents on Quarto Pub before, but this site is only for static websites, so you SHOULD NOT use Quarto Pub for your survey deployment.\n\n\nTo start using shinyapps.io, you’ll need to create an account and follow the basic instructions to set up your sub-domain and authorize your IDE. See more information here.\nOnce you have your account and sub-domain ready, make sure you have the rsconnect package installed. You should have done this while authorizing your IDE, but in case you didn’t, you can install it with:\n\ninstall.packages('rsconnect')\n\nThen to deploy your survey, run:\n\n# Define your app name with the appName parameter\nrsconnect::deployApp(appName = \"my_survey\")\n\nThat’s it! Now you should have your survey site deployed on shinyapps.io. Congratulations! 🎉",
    "crumbs": [
      "Documentation",
      "Deployment & Operations",
      "Deployment"
    ]
  },
  {
    "objectID": "docs/deployment.html#deploying-to-other-hosting-services",
    "href": "docs/deployment.html#deploying-to-other-hosting-services",
    "title": "Deploying Your Survey",
    "section": "Deploying to Other Hosting Services",
    "text": "Deploying to Other Hosting Services\nYou can deploy shiny apps to other hosting services. Here are some guides for several other alternatives:\n\nPosit Connect Cloud\nHugging Face\nHeroku\n\nYou can also install Posit Connect on your own server, which is the recommended approach for remaining compliant with any security protocols your organization requires.",
    "crumbs": [
      "Documentation",
      "Deployment & Operations",
      "Deployment"
    ]
  },
  {
    "objectID": "docs/external-resources.html",
    "href": "docs/external-resources.html",
    "title": "External Resources",
    "section": "",
    "text": "Often times you will want to include external resources in your survey, things like images, videos, etc. While you can easily include these in your survey.qmd file by referencing their location in your survey project folder, these resources may not always be available in the shiny app defined in your app.R file.\nTo address this, you should always place external resources in a separate folder and then make sure that folder is added to Shiny’s resource path. You can do this in your app.R file by using the sd_include_folder() function at the beginning of the file after loading the surveydown package, like this:\nlibrary(surveydown)\n\nsd_include_folder(\"resources\")\nThis will make all files in a folder called resources available to Shiny.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "External Resources"
    ]
  },
  {
    "objectID": "docs/external-resources.html#default-folders",
    "href": "docs/external-resources.html#default-folders",
    "title": "External Resources",
    "section": "Default folders",
    "text": "Default folders\nThe surveydown package will automatically add the following folders to Shiny’s resource path:\n\nwww\nimages\ncss\njs\n\nIf any of these folders exist in your project, they will automatically be added to Shiny’s resource path. For this reason, we recommend that you always put images inside a images folder in your project directory, css files inside a css folder, and so on. This will make it easier to manage your resources and ensure that they are always available to Shiny.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "External Resources"
    ]
  },
  {
    "objectID": "docs/fetching-data.html",
    "href": "docs/fetching-data.html",
    "title": "Fetching Data",
    "section": "",
    "text": "Once you have your database properly set up and your survey is live, you can fetch the data using the sd_get_data() function.\nTo do so, you have to first create a database connection using the sd_db_connect() function:\n\ndb &lt;- sd_db_connect()\n\nOnce you have created a successful database connection, you need to use the connection to fetch the data, like this:\n\ndata &lt;- sd_get_data(db)\n\nHere the data object will be a data.frame with the data from your database table.",
    "crumbs": [
      "Documentation",
      "Data Management",
      "Fetching Data"
    ]
  },
  {
    "objectID": "docs/fetching-data.html#static-fetching",
    "href": "docs/fetching-data.html#static-fetching",
    "title": "Fetching Data",
    "section": "",
    "text": "Once you have your database properly set up and your survey is live, you can fetch the data using the sd_get_data() function.\nTo do so, you have to first create a database connection using the sd_db_connect() function:\n\ndb &lt;- sd_db_connect()\n\nOnce you have created a successful database connection, you need to use the connection to fetch the data, like this:\n\ndata &lt;- sd_get_data(db)\n\nHere the data object will be a data.frame with the data from your database table.",
    "crumbs": [
      "Documentation",
      "Data Management",
      "Fetching Data"
    ]
  },
  {
    "objectID": "docs/fetching-data.html#reactive-fetching",
    "href": "docs/fetching-data.html#reactive-fetching",
    "title": "Fetching Data",
    "section": "Reactive Fetching",
    "text": "Reactive Fetching\n\n\n\n\n\n\nTip\n\n\n\nRun the Demo survey of a reactive plot for an example of reactively fetching data.\n\n\nThe above example is intended for an analysis context, where all you want to do is fetch the latest data from your database. However, you may also want to fetch the data in a reactive context (i.e. in your survey). For example, perhaps you want to show respondents a bar chart of the most common responses to a question. The sd_get_data() function is compatible with reactive fetching as well - just call it inside the server() function in your app.R file:\n\nserver &lt;- function(input, output, session) {\n\n  data &lt;- sd_get_data(db)\n\n  sd_server()\n\n}\n\nNow the data object will be a reactive expression, not a data.frame. To use it, you have to call it with () to get the latest data as a data.frame. For example:\n\nserver &lt;- function(input, output, session) {\n\n  data &lt;- sd_get_data(db, refresh_interval = 5)\n\n  output$my_plot &lt;- renderPlot({  \n    my_data &lt;- data()\n    # insert code here to make a plot with my_data\n  })\n\n  sd_server()\n\n}\n\nHere the my_data object will be a data.frame with the latest data from your database, refreshed every 5 sections according to the refresh_interval parameter (5 seconds is the default value), which you could then use to make a plot.\nIn this example, the output$my_plot object will be a plot, which you can then display in your survey by placing plotOutput(\"my_plot\") in a code chunk somewhere in your survey.qmd file.\nSee the Reactivity page for more information on how to use reactivity in your survey.",
    "crumbs": [
      "Documentation",
      "Data Management",
      "Fetching Data"
    ]
  },
  {
    "objectID": "docs/local-dashboard.html",
    "href": "docs/local-dashboard.html",
    "title": "Local Dashboard",
    "section": "",
    "text": "The surveydown package has a dashboard app for viewing and modifying your database credentials as well as viewing your survey data. To launch the dashboard, run the following in your R console:\nsurveydown::sd_dashboard()\nThis will open a new browser window where you can navigate to the dashboard for your project. It has two tabs: “Dashboard” and “DB Config”.",
    "crumbs": [
      "Documentation",
      "Data Management",
      "Local Dashboard"
    ]
  },
  {
    "objectID": "docs/local-dashboard.html#dashboard-tab",
    "href": "docs/local-dashboard.html#dashboard-tab",
    "title": "Local Dashboard",
    "section": "Dashboard Tab",
    "text": "Dashboard Tab\nThe “Dashboard” tab looks like this:\n\n\n\n\nThe “Dashboard” tab allows you to view your survey data in a user-friendly interface. It contains survey answering statistics and response summarization charts. On the lower part you can preview the survey data sheet. There is a download button for you to obtain the survey data in CSV format.",
    "crumbs": [
      "Documentation",
      "Data Management",
      "Local Dashboard"
    ]
  },
  {
    "objectID": "docs/local-dashboard.html#db-config-tab",
    "href": "docs/local-dashboard.html#db-config-tab",
    "title": "Local Dashboard",
    "section": "DB Config Tab",
    "text": "DB Config Tab\nThe “DB Config” tab looks like this:\n\n\n\n\nIn the “DB Config” tab, you can view and edit your database credentials. Therefore, you can either set up your credentials using the sd_db_config() function in your R console, or simply launch this dashboard app and modify them here.",
    "crumbs": [
      "Documentation",
      "Data Management",
      "Local Dashboard"
    ]
  },
  {
    "objectID": "docs/performance.html",
    "href": "docs/performance.html",
    "title": "Performance",
    "section": "",
    "text": "Our goal in designing surveydown was to create a package that was both performant and easy to use. While we’ve worked to ensure that the package is efficient, the ultimate performance of your survey in the field will depend on the services you use to host your app, store your data, and field your survey.",
    "crumbs": [
      "Documentation",
      "Deployment & Operations",
      "Performance"
    ]
  },
  {
    "objectID": "docs/performance.html#hosting",
    "href": "docs/performance.html#hosting",
    "title": "Performance",
    "section": "Hosting",
    "text": "Hosting\nWe recommend using shinyapps.io to host your survey as it is designed to work with Shiny Apps. The platform offers a free tier that should work well for most simple surveys. However, more complex surveys may require paid plans to achieve better performance.\nOne thing you can do to improve the performance is to max out the memory settings for your app in the “settings” tab in your app dashboard. It should look something like this:\n\n\n\n\nThe free tier allows for 1 GB of memory, and paid plans can go up much higher (this screenhot is from an earlier period when the free tier memory limits were larger).\nThe other thing to consider is the number of active hours (the free tier allows for 25 active hours per month).\nDepending on your needs, a paid plan may be worth the investment during your actual survey fielding to ensure a smooth user experience. And of course, you can consider other hosting services that might have better options.",
    "crumbs": [
      "Documentation",
      "Deployment & Operations",
      "Performance"
    ]
  },
  {
    "objectID": "docs/performance.html#database",
    "href": "docs/performance.html#database",
    "title": "Performance",
    "section": "Database",
    "text": "Database\nThe surveydown package is designed to work with any PostgreSQL database, but we recommend using Supabase to store your survey responses as it is a fast, reliable, and scalable PostgreSQL database. Like shinyapps.io, Supabase offers a free tier that should work well for most simple surveys, but a paid plan may be needed if you expect to have a large number of concurrent respondents.\nThe free tier allows for 20 concurrent database connections, but since surveydown uses a pooled connection to the database, this limit not directly translate to a hard limit of 20 concurrent respondents.",
    "crumbs": [
      "Documentation",
      "Deployment & Operations",
      "Performance"
    ]
  },
  {
    "objectID": "docs/performance.html#fielding-options",
    "href": "docs/performance.html#fielding-options",
    "title": "Performance",
    "section": "Fielding Options",
    "text": "Fielding Options\nMany researchers use panel providers like Prolific to recruit respondents for their surveys. Given the large number of potential concurrent respondents, you may want to place a limit on the number of people who can complete your survey at once to avoid overloading your app. On prolific, for example, you can set a quota in your study settings, which looks something like this:\n\n\n\n\nAnother option to consider is what types of devices your respondents will be completing your survey on. You may want to test how your survey renders on phones versus computers to see if there are siginificant differences. Some panel providers have options to limit which devices respondents can use to take the survey. On prolific this looks like this:\n\n\n\n\nMany panel providers offer these kinds of fielding options, and we recommend checking with your panel provider to help prevent overloading your app.",
    "crumbs": [
      "Documentation",
      "Deployment & Operations",
      "Performance"
    ]
  },
  {
    "objectID": "docs/question-types.html",
    "href": "docs/question-types.html",
    "title": "Question Types",
    "section": "",
    "text": "All questions in a surveydown survey are created using the sd_question() function. Calls to sd_question() should be put inside code chunks in the survey.qmd file to define the survey questions.\nThe function requires the following three arguments:\nMany question types also require an option argument, which is a named vector of options for the question (e.g. for multiple choice questions). The function also includes many other optional arguments that can be used to customize the question appearance and behavior. See the package documentation for more details.\nBelow are examples of each question type.",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Types"
    ]
  },
  {
    "objectID": "docs/question-types.html#text",
    "href": "docs/question-types.html#text",
    "title": "Question Types",
    "section": "text",
    "text": "text\nUse type = 'text' to specify a text input type question.\n\n\nOutput\nCode\n\n\n\n\n\n\n\nWrite a word:\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type  = \"text\",\n  id    = \"word\",\n  label = \"Write a word:\"\n)\n```",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Types"
    ]
  },
  {
    "objectID": "docs/question-types.html#textarea",
    "href": "docs/question-types.html#textarea",
    "title": "Question Types",
    "section": "textarea",
    "text": "textarea\nUse type = 'textarea' to specify a text area input type question.\n\n\nOutput\nCode\n\n\n\n\n\n\n\nWrite a paragraph:\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type  = \"textarea\",\n  id    = \"paragraph\",\n  label = \"Write a paragraph:\"\n)\n```",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Types"
    ]
  },
  {
    "objectID": "docs/question-types.html#numeric",
    "href": "docs/question-types.html#numeric",
    "title": "Question Types",
    "section": "numeric",
    "text": "numeric\nUse type = 'numeric' to specify a numeric input type.\n\n\nOutput\nCode\n\n\n\n\n\n\n\nWhat’s your age?\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type  = 'numeric',\n  id    = 'age',\n  label = \"What's your age?\"\n)\n```",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Types"
    ]
  },
  {
    "objectID": "docs/question-types.html#mc",
    "href": "docs/question-types.html#mc",
    "title": "Question Types",
    "section": "mc",
    "text": "mc\nUse type = 'mc' to specify a multiple choice type question with a single choice option.\n\n\nOutput\nCode\n\n\n\n\n\n\n\nWhich artist do you prefer most from this list?\n\n\n\n\nTaylor Swift\n\n\n\n\nBeyoncé\n\n\n\n\nAdele\n\n\n\n\nRihanna\n\n\n\n\nLady Gaga\n\n\n\n\nEd Sheeran\n\n\n\n\nDrake\n\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type   = 'mc',\n  id     = 'artist',\n  label  = \"Which artist do you prefer most from this list?\",\n  option = c(\n    \"Taylor Swift\" = \"taylor_swift\",\n    \"Beyoncé\"      = \"beyonce\",\n    \"Adele\"        = \"adele\",\n    \"Rihanna\"      = \"rihanna\",\n    \"Lady Gaga\"    = \"ladygaga\",\n    \"Ed Sheeran\"   = \"ed_sheeran\",\n    \"Drake\"        = \"drake\"\n  )\n)\n```",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Types"
    ]
  },
  {
    "objectID": "docs/question-types.html#mc_multiple",
    "href": "docs/question-types.html#mc_multiple",
    "title": "Question Types",
    "section": "mc_multiple",
    "text": "mc_multiple\nUse type = 'mc_multiple' to specify a multiple choice type question with multiple selection enabled.\n\n\nOutput\nCode\n\n\n\n\n\n\n\nWhat are your favorite Taylor Swift albums (select all that apply)?\n\n\n\n\nTaylor Swift (2006)\n\n\n\n\nFearless (2008)\n\n\n\n\nSpeak Now (2010)\n\n\n\n\nRed (2012)\n\n\n\n\n1989 (2014)\n\n\n\n\nReputation (2017)\n\n\n\n\nLover (2019)\n\n\n\n\nFolklore (2020)\n\n\n\n\nEvermore (2020)\n\n\n\n\nMidnights (2022)\n\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type  = 'mc_multiple',\n  id    = 'swift',\n  label = \"What are your favorite Taylor Swift albums (select all that apply)?\",\n  option = c(\n    \"Taylor Swift (2006)\" = \"taylor_swift\",\n    \"Fearless (2008)\"     = \"fearless\",\n    \"Speak Now (2010)\"    = \"speak_now\",\n    \"Red (2012)\"          = \"red\",\n    \"1989 (2014)\"         = \"1989\",\n    \"Reputation (2017)\"   = \"reputation\",\n    \"Lover (2019)\"        = \"lover\",\n    \"Folklore (2020)\"     = \"folklore\",\n    \"Evermore (2020)\"     = \"evermore\",\n    \"Midnights (2022)\"    = \"midnights\"\n  )\n)\n```",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Types"
    ]
  },
  {
    "objectID": "docs/question-types.html#mc_buttons",
    "href": "docs/question-types.html#mc_buttons",
    "title": "Question Types",
    "section": "mc_buttons",
    "text": "mc_buttons\nUse type = 'mc_buttons' to generate the button version of mc.\n\n\nOutput\nCode\n\n\n\n\n\n\n\nWhich fruit do you prefer most from this list?\n\n\n\nApple\nBanana\nPear\nStrawberry\nGrape\nMango\nWatermelon\n\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type   = 'mc_buttons',\n  id     = 'fruit',\n  label  = \"Which fruit do you prefer most from this list?\",\n  option = c(\n    \"Apple\"      = \"apple\",\n    \"Banana\"     = \"banana\",\n    \"Pear\"       = \"pear\",\n    \"Strawberry\" = \"strawberry\",\n    \"Grape\"      = \"grape\",\n    \"Mango\"      = \"mango\",\n    \"Watermelon\" = \"watermelon\"\n  )\n)\n```\n\n\n\n\nUse direction = \"vertical\" to display the button options vertically.\n\n\nOutput\nCode\n\n\n\n\n\n\n\nWhich fruit do you prefer most from this list?\n\n\n\nApple\nBanana\nPear\nStrawberry\nGrape\nMango\nWatermelon\n\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type   = 'mc_buttons',\n  id     = 'fruit_vertical',\n  label  = \"Which fruit do you prefer most from this list?\",\n  option = c(\n    \"Apple\"      = \"apple\",\n    \"Banana\"     = \"banana\",\n    \"Pear\"       = \"pear\",\n    \"Strawberry\" = \"strawberry\",\n    \"Grape\"      = \"grape\",\n    \"Mango\"      = \"mango\",\n    \"Watermelon\" = \"watermelon\"\n  ), \n  direction = \"vertical\"\n)\n```",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Types"
    ]
  },
  {
    "objectID": "docs/question-types.html#mc_multiple_buttons",
    "href": "docs/question-types.html#mc_multiple_buttons",
    "title": "Question Types",
    "section": "mc_multiple_buttons",
    "text": "mc_multiple_buttons\nUse type = 'mc_multiple_buttons' to generate the button version of mc_multiple.\n\n\nOutput\nCode\n\n\n\n\n\n\n\nWhich are your favorite Michael Jackson songs (select all that apply)?\n\n\n\nThriller (1982)\nBillie Jean (1982)\nBeat It (1982)\nMan in the Mirror (1987)\nSmooth Criminal (1987)\nBlack or White (1991)\nBad (1987)\nHuman Nature (1982)\n\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type  = 'mc_multiple_buttons',\n  id    = 'michael_jackson',\n  label = \"Which are your favorite Michael Jackson songs (select all that apply)?\",\n  option = c(\n    \"Thriller (1982)\"          = \"thriller\",\n    \"Billie Jean (1982)\"       = \"billie_jean\",\n    \"Beat It (1982)\"           = \"beat_it\",\n    \"Man in the Mirror (1987)\" = \"man_in_the_mirror\",\n    \"Smooth Criminal (1987)\"   = \"smooth_criminal\",\n    \"Black or White (1991)\"    = \"black_or_white\",\n    \"Bad (1987)\"               = \"bad\",\n    \"Human Nature (1982)\"      = \"human_nature\"\n  )\n)\n```\n\n\n\n\nUse direction = \"vertical\" to display the button options vertically.\n\n\nOutput\nCode\n\n\n\n\n\n\n\nWhich are your favorite Michael Jackson songs (select all that apply)?\n\n\n\nThriller (1982)\nBillie Jean (1982)\nBeat It (1982)\nMan in the Mirror (1987)\nSmooth Criminal (1987)\nBlack or White (1991)\nBad (1987)\nHuman Nature (1982)\n\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type  = 'mc_multiple_buttons',\n  id    = 'michael_jackson_vertical',\n  label = \"Which are your favorite Michael Jackson songs (select all that apply)?\",\n  option = c(\n    \"Thriller (1982)\"          = \"thriller\",\n    \"Billie Jean (1982)\"       = \"billie_jean\",\n    \"Beat It (1982)\"           = \"beat_it\",\n    \"Man in the Mirror (1987)\" = \"man_in_the_mirror\",\n    \"Smooth Criminal (1987)\"   = \"smooth_criminal\",\n    \"Black or White (1991)\"    = \"black_or_white\",\n    \"Bad (1987)\"               = \"bad\",\n    \"Human Nature (1982)\"      = \"human_nature\"\n  ), \n  direction = \"vertical\"\n)\n```",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Types"
    ]
  },
  {
    "objectID": "docs/question-types.html#select",
    "href": "docs/question-types.html#select",
    "title": "Question Types",
    "section": "select",
    "text": "select\nUse type = 'select' to specify a drop down select type question.\n\n\nOutput\nCode\n\n\n\n\n\n\n\nWhat is the highest level of education you have attained?\n\n\nChoose an option...\nDid not attend high school\nSome high school\nHigh school graduate\nSome college\nCollege\nGraduate Work\nPrefer not to say\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type  = 'select',\n  id    = 'education',\n  label = \"What is the highest level of education you have attained?\",\n  option = c(\n    \"Did not attend high school\" = \"hs_no\",\n    \"Some high school\"           = \"hs_some\",\n    \"High school graduate\"       = \"hs_grad\",\n    \"Some college\"               = \"college_some\",\n    \"College\"                    = \"college_grad\",\n    \"Graduate Work\"              = \"grad\",\n    \"Prefer not to say\"          = \"no_response\"\n  )\n)\n```",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Types"
    ]
  },
  {
    "objectID": "docs/question-types.html#slider",
    "href": "docs/question-types.html#slider",
    "title": "Question Types",
    "section": "slider",
    "text": "slider\n\n\n\n\n\n\nNote\n\n\n\nThis widget only renders well in a Shiny environment, so we just show a screenshot here.\n\n\n\n\nOutput\nCode chunk\n\n\n\n\n\n\n\n\n\n```{r}\nsd_question(\n  type  = 'slider',\n  id    = 'climate_care',\n  label = \"To what extent do you believe human-caused climate change is real?\",\n  option = c(\n    \"Don't Believe\"    = \"dont_believe\",\n    \"Somewhat Believe\" = \"somewhat\",\n    \"Neutral\"          = \"neutral\",\n    \"Believe\"          = \"believe\",\n    \"Strongly Believe\" = \"strongly_believe\"\n  )\n)\n```",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Types"
    ]
  },
  {
    "objectID": "docs/question-types.html#slider_numeric",
    "href": "docs/question-types.html#slider_numeric",
    "title": "Question Types",
    "section": "slider_numeric",
    "text": "slider_numeric\n\n\n\n\n\n\nNote\n\n\n\nThis widget only renders well in a Shiny environment, so we just show a screenshot here.\n\n\nIf your slider uses numeric inputs, use the slider_numeric question type. This type of slider can be used for either single sliders or dual sliders that define a range of values.\nSingle slider:\n\n\nOutput\nCode chunk\n\n\n\n\n\n\n\n\n\n```{r}\nsd_question(\n  type = \"slider_numeric\", \n  id = 'slider_single_val',  \n  label = 'Single value example', \n  option = seq(0, 10, 1)\n)\n```\n\n\n\n\nRange slider:\n\n\nOutput\nCode chunk\n\n\n\n\n\n\n\n\n\n```{r}\nsd_question(\n  type = \"slider_numeric\", \n  id = 'slider_range',  \n  label = 'Range example', \n  option = seq(0, 10, 1), \n  default = c(3, 5)\n)\n```",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Types"
    ]
  },
  {
    "objectID": "docs/question-types.html#date",
    "href": "docs/question-types.html#date",
    "title": "Question Types",
    "section": "date",
    "text": "date\nUse type = 'date' to specify a date input type. The date value will be today’s date by default. Upon clicking on the text box, you are provided with a date dialog box to choose date from.\n\n\n\n\n\n\nNote\n\n\n\nThis widget only renders well in a Shiny environment, so we just show a screenshot here.\n\n\n\n\nOutput\nCode\n\n\n\n\n\n\n\n\n\n```{r}\nsd_question(\n  type  = 'date',\n  id    = 'dob',\n  label = \"What is your date of birth?\"\n)\n```",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Types"
    ]
  },
  {
    "objectID": "docs/question-types.html#daterange",
    "href": "docs/question-types.html#daterange",
    "title": "Question Types",
    "section": "daterange",
    "text": "daterange\nUse type = 'daterange' to specify a date range input type.\n\n\n\n\n\n\nNote\n\n\n\nThis widget only renders well in a Shiny environment, so we just show a screenshot here.\n\n\n\n\nOutput\nCode\n\n\n\n\n\n\n\n\n\n```{r}\nsd_question(\n  type  = 'daterange',\n  id    = 'hs_date',\n  label = \"When did you start and finish high school?\"\n)\n```",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Types"
    ]
  },
  {
    "objectID": "docs/question-types.html#matrix",
    "href": "docs/question-types.html#matrix",
    "title": "Question Types",
    "section": "matrix",
    "text": "matrix\nUse type = 'matrix' to specify a matrix input type.\n\n\nOutput\nCode\n\n\n\n\n\n\n\nPlease indicate your agreement with the following statements.\n\n\n\n\n\n\n\n\n\n\n\nDisagree\nNeutral\nAgree\n\n\n\nI would buy a gasoline car.\n\n\n\n\n\n Disagree \n\n\n Neutral \n\n\n Agree \n\n\n\n*\n\n\n\nI would buy an EV.\n\n\n\n\n\n Disagree \n\n\n Neutral \n\n\n Agree \n\n\n\n*\n\n\n\n\n\n*\n\n\n\n\n\n\n```{r}\nsd_question(\n  type   = \"matrix\",\n  id     = \"car_preference\",\n  label  = \"Please indicate your agreement with the following statements.\",\n  row    = c(\n    \"I would buy a gasoline car.\" = \"buy_gasoline\",\n    \"I would buy an EV.\"          = \"buy_ev\"\n  ),\n  option = c(\n    \"Disagree\" = \"disagree\",\n    \"Neutral\"  = \"neutral\",\n    \"Agree\"    = \"agree\"\n  )\n)\n```",
    "crumbs": [
      "Documentation",
      "Question Development",
      "Question Types"
    ]
  },
  {
    "objectID": "docs/reactivity.html",
    "href": "docs/reactivity.html",
    "title": "Reactivity",
    "section": "",
    "text": "Because surveydown renders to a Shiny app, it can take advantage of Shiny’s reactivity features. This means you can create reactive expressions and reactive values that update the survey in response to user input or other events.\nThis page demonstrates some common use cases for reactive programming in surveydown.",
    "crumbs": [
      "Documentation",
      "Interactivity",
      "Reactivity"
    ]
  },
  {
    "objectID": "docs/reactivity.html#displaying-question-values-in-the-survey",
    "href": "docs/reactivity.html#displaying-question-values-in-the-survey",
    "title": "Reactivity",
    "section": "Displaying question values in the survey",
    "text": "Displaying question values in the survey\nA simple example of using a reactive value is displaying a question value somewhere else in the survey.\nFor example, you might ask the respondent’s name in a question and then display their name somewhere else in the survey, like in a greeting message. First, you would ask the respondent’s name in a question in your survey.qmd file:\n\nsd_question(\n  type  = \"text\",\n  id    = \"name\",\n  label = \"What is your name?\"\n)\n\nThen you can use the sd_output() function to display the value of the \"name\" question elsewhere in the survey. For example, you could display the name in a greeting message:\n\nWelcome, `r sd_output(\"name\", type = \"value\")`!\n\nIf the respondent entered “Dave” in the name question, this would render as:\n\nWelcome, Dave!\n\nThe type = \"value\" argument tells sd_output() to display the value of the question rather than the question itself.\n\n\n\n\n\n\nNoteHow this works under the hood\n\n\n\nEvery question has it’s own id. To access the value that a respondent chose, we can’t use the same id. To address this, whenever you create a question we automatically create an object stored as id_value to store the value chosen by the respondent.\nFor example, if the question id was \"name\", then the value would be stored as \"name_value\". In the sd_output() function, when you use type = \"value\", the function automatically appends this _value to the id to get the question value we want to display, then uses an appropriate shiny output function to display it, e.g. shiny::textOutput().\nYou can also use type = \"question\" to display questions that are defined in the server() function in your app.R file (see the defining questions in the server function section below).",
    "crumbs": [
      "Documentation",
      "Interactivity",
      "Reactivity"
    ]
  },
  {
    "objectID": "docs/reactivity.html#displaying-stored-values-e.g.-a-completion-code",
    "href": "docs/reactivity.html#displaying-stored-values-e.g.-a-completion-code",
    "title": "Reactivity",
    "section": "Displaying stored values (e.g. a completion code)",
    "text": "Displaying stored values (e.g. a completion code)\nYou can use sd_output() with type = \"value\" to display values that you stored in the server() function.\nFor example, you might want to display a completion code at the end of the survey. You can do this by defining a completion code in the server() function and then storing it in the survey data using the sd_store_value() function.\nSince completion codes are often needed, we made a simple sd_completion_code() function that returns a random numeric completion code as a string. Here’s an example of how to use it:\n\n# Make a 10-digit random number completion code\ncompletion_code &lt;- sd_completion_code(10)\n\n# Store the completion code in the survey data\nsd_store_value(completion_code)\n\nThis will store the completion code in the survey data under the completion_code column.\nYou can then display the completion code at the end of the survey using the sd_output() function in your survey.qmd file, like this:\n\nYour code is: `r sd_output(\"completion_code\", type = 'value')`\n\nThis should render as something like this:\n\nYour code is: 7408931907",
    "crumbs": [
      "Documentation",
      "Interactivity",
      "Reactivity"
    ]
  },
  {
    "objectID": "docs/reactivity.html#displaying-the-same-value-in-multiple-places",
    "href": "docs/reactivity.html#displaying-the-same-value-in-multiple-places",
    "title": "Reactivity",
    "section": "Displaying the same value in multiple places",
    "text": "Displaying the same value in multiple places\nThe sd_output() function can only be used once per each unique question id because the id gets used in the rendered HTML divs, and HTML with more than one element with the same id is invalid HTML. This is a general issue for Shiny - outputs can only be used once per each unique id (see this GitHub issue on the topic).\nThe solution that we use is to simply make a copy of the value and then display the copy (this is also the solution on the GitHub issue linked above).\nTo do so, in the server function in the app.R file use the sd_copy_value() function to create a copy of the value, like this:\n\nsd_copy_value(id = \"name\", id_copy = \"name_copy\")\n\nYou can then use the sd_output() function in your survey.qmd file to display both the original and copied values. For example:\n\nWelcome, `r sd_output(\"name\", type = \"value\")`!\n\nIs it alright if we call you `r sd_output(\"name_copy\", type = \"value\")`?\n\nIf the respondent entered “Dave” in the name question, this would render as:\n\nWelcome, Dave!\nIs it alright if we call you Dave?\n\n\n\n\n\n\n\nNote\n\n\n\nIf you find this annoying, we agree! This is a bit of a hack and we are working on a better solution, but it is a limitation of Shiny that we have to live with, at least for now.",
    "crumbs": [
      "Documentation",
      "Interactivity",
      "Reactivity"
    ]
  },
  {
    "objectID": "docs/reactivity.html#working-with-calculated-values",
    "href": "docs/reactivity.html#working-with-calculated-values",
    "title": "Reactivity",
    "section": "Working with calculated values",
    "text": "Working with calculated values\nOften times you’ll need to create intermediate objects in your server that depend on question responses. In this situation, the intermediate objects won’t be generated when the survey launches since the question response(s) needed to calculate them are not yet answered. Instead, they’ll need to be reactively created once the respondent answers the questions.\nTo provide a concrete example, suppose you have a page in your survey.qmd file like the one below. In this page, the questions first_number and second_number define two numeric values. Below these questions, we have several lines that print out the following:\n\nThe values themselves\nTwo computed values based on the two input numbers (product and sum).\nA summary sentence that prints a summary of everything above, which is created in the server.\n\nExample page in survey.qmd** file**:\n\n::: {#page1 .sd-page}\n\n# Demo - Calculation\n\n```{r}\nsd_question(\n  type  = 'numeric',\n  id    = 'first_number',\n  label = \"Type in your first number:\"\n)\n\nsd_question(\n  type  = 'numeric',\n  id    = 'second_number',\n  label = \"Type in your second number:\"\n)\n```\n\nYour first number is: `r sd_output(\"first_number\", type = \"value\")`.\n\nYour second number is: `r sd_output(\"second_number\", type = \"value\")`.\n\nThe product of these 2 numbers is: `r sd_output(\"product\", type = \"value\")`.\n\nThe sum of these 2 numbers is: `r sd_output(\"sum\", type = \"value\")`.\n\n`r sd_output(\"summary\")`\n\n```{r}\nsd_next()\n```\n\n:::\n\nTo make these values display properly, you can create reactive values with the sd_reactive() function in the server, which reactively updates as the user changes any of the question values. Here is an example of how you might create the product value:\n\nproduct &lt;- sd_reactive(\"product\", {\n  input$first_number * input$second_number\n})\n\nThe sd_reactive() function takes an id (in this case \"product\"), which is the name that will be used in the resulting survey response data to store the returned value. The created object (in this case named product) is a reactive expression that can also be used anywhere else in the server using the () symbols, e.g. product(). Inside the function can be any expression that returns a value. In this case, we’re just multiplying together the two input numbers.\nTo create all of the objects in the example page above, our server would look like this:\napp.R file:\n\nlibrary(surveydown)\n\nserver &lt;- function(input, output, session) {\n\n  # Create reactive values for 'product' and 'sum'\n  product &lt;- sd_reactive(\"product\", {\n    input$first_number * input$second_number\n  })\n\n  sum &lt;- sd_reactive(\"sum\", {\n    input$first_number + input$second_number\n  })\n\n  # Use the reactive values to create an additional 'summary' output\n  output$summary &lt;- renderText({\n    paste(\"The product is:\", product(), \"and the sum is:\", sum())\n  })\n\n  sd_server()\n}\n\n# Launch Survey\nshiny::shinyApp(ui = sd_ui(), server = server)\n\nIn this server, we create two reactive values, product and sum, which get stored in our survey data under those respective names. We also use product() and sum() to create the output$summary object, which is just some rendered text to display on the survey page.",
    "crumbs": [
      "Documentation",
      "Interactivity",
      "Reactivity"
    ]
  },
  {
    "objectID": "docs/reactivity.html#defining-questions-in-the-server-function",
    "href": "docs/reactivity.html#defining-questions-in-the-server-function",
    "title": "Reactivity",
    "section": "Defining questions in the server function",
    "text": "Defining questions in the server function\nOften you will want to define questions where the label or options change based on the respondent’s answers to other questions. You can do this by defining the question in the server function and then displaying it in the survey.qmd file using the sd_output() function.\nFor example, let’s say you want to ask a follow-up question based on the respondent’s answer to a previous question. To do this, you would define the first question in the survey.qmd file as usual, e.g.:\n\nsd_question(\n  id     = \"pet_type\",\n  type   = \"mc\",\n  label  = \"Which do you like more, dogs or cats?\",\n  option = c(\"Dogs\" = \"dog\", \"Cats\" = \"cat\")\n)\n\nMy follow-up question is whether or not the respondent has a pet of the type they chose above. To do this, you would define the follow-up question in the app.R file’s server() function like this:\n\nserver &lt;- function(input, output, session) {\n\n  observe({\n    pet_type &lt;- input$pet_type\n\n    # Make the question label and options\n    label &lt;-glue::glue(\"Are you a {pet_type} owner?\")\n    options &lt;- c('yes', 'no')\n    names(options)[1] &lt;- glue::glue(\"Yes, am a {pet_type} owner\")\n    names(options)[2] &lt;- glue::glue(\"No, I am not a {pet_type} owner\")\n\n    # Make the question\n    sd_question(\n      type   = \"mc\",\n      id     = \"pet_owner\",\n      label  = label,\n      option = options\n    )\n  })\n\n  sd_server()\n}\n\nThe pet_owner question is a reactive question where the label and options will change based on the respondent’s answer to the pet_type question.\n\n\n\n\n\n\nNote\n\n\n\nThe observe() function is used to create the reactive question. This is a core concept in Shiny reactivity that allows you to create reactive expressions that can change based on the values of other reactive expressions.\nAlso, in this example we use the glue package to create the question label and options. This is a powerful package for creating strings that contain variable values.\n\n\nFinally, you can display the pet_owner question in the survey.qmd file using the sd_output() function, like this:\n\n```{r}\nsd_output(id = \"pet_owner\", type = \"question\")\n```",
    "crumbs": [
      "Documentation",
      "Interactivity",
      "Reactivity"
    ]
  },
  {
    "objectID": "docs/storing-data.html",
    "href": "docs/storing-data.html",
    "title": "Storing Data",
    "section": "",
    "text": "Survey response data is stored in a PostgreSQL database. We recommend using Supabase as a free and open-source option, though you can use any service you want. In this guide, we’ll walk you through the steps for setting up a Supabase project and connecting your surveydown survey to it.",
    "crumbs": [
      "Documentation",
      "Data Management",
      "Storing Data"
    ]
  },
  {
    "objectID": "docs/storing-data.html#local-data-preview",
    "href": "docs/storing-data.html#local-data-preview",
    "title": "Storing Data",
    "section": "Local data preview",
    "text": "Local data preview\nWhen you run a survey without a database connection, response data will be locally stored in a preview_data.csv file. As the name suggests, this is for preview purposes only. It is there to help you understand what the actual survey response data will look like once you get your database connection properly configured.\nThis file is not where your actual survey response data will be saved. If you deploy your survey live without a database connection, no responses will be saved.",
    "crumbs": [
      "Documentation",
      "Data Management",
      "Storing Data"
    ]
  },
  {
    "objectID": "docs/storing-data.html#setting-up-a-supabase-project",
    "href": "docs/storing-data.html#setting-up-a-supabase-project",
    "title": "Storing Data",
    "section": "Setting up a Supabase project",
    "text": "Setting up a Supabase project\nFirst, navigate to the Supabase website and create an account.\nOnce you are logged in, the page will prompt you to create a project (it’s a green button). Click on it and select your organization. A dialog box will pop up like this:\n\n\n\n\nFill in the project name and give it a strong password. Choose a region that is close to you (or close to your survey audience). All settings can be modified at any time.\n\n\n\n\n\n\nNote\n\n\n\nEach Supabase project is a database that can store multiple tables. Since each surveydown survey requires only one table, you can use the same Supabase project for multiple surveydown surveys.",
    "crumbs": [
      "Documentation",
      "Data Management",
      "Storing Data"
    ]
  },
  {
    "objectID": "docs/storing-data.html#getting-your-supabase-credentials",
    "href": "docs/storing-data.html#getting-your-supabase-credentials",
    "title": "Storing Data",
    "section": "Getting your Supabase credentials",
    "text": "Getting your Supabase credentials\nOnce your Supabase project is ready, click on the “connect” button at the top, it should look like this:\n\n\n\n\nOn the connection page, scroll down to the “Transaction pooler” section. There you can click on the “View parameters” drop down to see your connection parameters. It should look somethinglike this:\n\n\n\n\nYou will need these parameters and your password to connect to your database in surveydown.",
    "crumbs": [
      "Documentation",
      "Data Management",
      "Storing Data"
    ]
  },
  {
    "objectID": "docs/storing-data.html#storing-your-database-credentials",
    "href": "docs/storing-data.html#storing-your-database-credentials",
    "title": "Storing Data",
    "section": "Storing your database credentials",
    "text": "Storing your database credentials\nBefore connecting to your database, you need to store your credentials. You can do this by running the following code in your R console:\n\nsurveydown::sd_db_config()\n\nThis function will prompt you to enter your database credentials and password, one by one. The current credential values will be shown in square brackets. When done it should look like this:\n\n\n\n\nOnce you have entered your credentials, the function will store them in a .env file in your project folder. We strongly recommend that you do not manually edit this file or share it with others as it stores all of your database credentials, including your password.",
    "crumbs": [
      "Documentation",
      "Data Management",
      "Storing Data"
    ]
  },
  {
    "objectID": "docs/storing-data.html#modifying-credentials",
    "href": "docs/storing-data.html#modifying-credentials",
    "title": "Storing Data",
    "section": "Modifying credentials",
    "text": "Modifying credentials\nIf you want to modify your credentials stored in the .env file, you can just run sd_db_config() again and press ‘Enter’ on any parameter you want to leave unchanged while modifying the ones you want to change.\nYou can also pass any of the parameters as arguments to sd_db_config() to change them. For example, if you wanted to only change the table name, you could do this:\n\nsd_db_config(table = 'mytable')\n\nOnce run in the R console, a message will print out confirming that the stored table parameter will now be mytable.\nYou can pass any of the following as arguments to update them: host, dbname, port, user, table, and password.\nFinally, you can also view / modify your database credentials in the surveydown dashboard app. To do this, launch the dashboard by running this command in the R console:\n\nsurveydown::sd_dashboard()\n\nThis will open a new browser window where you can navigate to the dashboard for your project. Click on the “Connection Settings” tab to see and edit your database credentials. Once you have made changes, click on the “Test Connection” button to save your updated credentials.\nSee the Local Dashboard page for more information.",
    "crumbs": [
      "Documentation",
      "Data Management",
      "Storing Data"
    ]
  },
  {
    "objectID": "docs/storing-data.html#connecting-to-your-database-in-surveydown",
    "href": "docs/storing-data.html#connecting-to-your-database-in-surveydown",
    "title": "Storing Data",
    "section": "Connecting to your database in surveydown",
    "text": "Connecting to your database in surveydown\nNow that you have set your credentials stored, you can connect to your database in surveydown by running the following code in your app.R file:\n\ndb &lt;- sd_db_connect()\n\nYou do not need to specify any arguments to this function as it will automatically use the credentials stored in your .env file. If the connection is successful, you should see a message in the console that says “✔ Successfully connected to the database.”\nYou can also ignore the database connection by setting ignore = TRUE in sd_db_connect():\n\ndb &lt;- sd_db_connect(ignore = TRUE)\n\nWith this setting, no database connection will be attempted, and the db object will store the value NULL. Instead, data will be stored in a local preview_data.csv file for previewing purposes only. This is useful when you are still editing your survey and do not want to store any data in your database yet.",
    "crumbs": [
      "Documentation",
      "Data Management",
      "Storing Data"
    ]
  },
  {
    "objectID": "docs/storing-data.html#table-creation-and-data-operations",
    "href": "docs/storing-data.html#table-creation-and-data-operations",
    "title": "Storing Data",
    "section": "Table creation and data operations",
    "text": "Table creation and data operations\nYou never need to manually create a table in the database - it gets automatically created after you first run the survey. After you first set up the config and a .env file is properly created, run your survey locally and click past the first page, then you should see the table get created in the database. You can view it directly on supabase (if you’re using supabase), or you can see the table using the dashboard by running sd_dashboard().\nThe data gets updated in the database on every page turn (each time you push a next button) and after you close the browser, which is usually at the end of the survey, but just in case you close it early it will write to the database then too. This is why you usually have to click past the first page after initial configuration to see the table in the database.",
    "crumbs": [
      "Documentation",
      "Data Management",
      "Storing Data"
    ]
  },
  {
    "objectID": "docs/storing-data.html#trouble-connecting",
    "href": "docs/storing-data.html#trouble-connecting",
    "title": "Storing Data",
    "section": "Trouble connecting?",
    "text": "Trouble connecting?\nIf you’re having trouble connecting to your database, try these steps:\n\nAre you certain your password is correct? You can open your .env file in a text reader app or in your IDE to check it.\nAre you certain your credentials are correct? If you run surveydown::sd_db_config() again in your R console, you can see the current values stored in the [] symbols to check if those are correct.\nAre you getting a message about something related to gssencmode? Take a look here.",
    "crumbs": [
      "Documentation",
      "Data Management",
      "Storing Data"
    ]
  },
  {
    "objectID": "docs/storing-data.html#cookies",
    "href": "docs/storing-data.html#cookies",
    "title": "Storing Data",
    "section": "Cookies",
    "text": "Cookies\nBy default, the data on each page will be locally stored in the browser cookies, though you can turn this feature off if you wish (see here).\nThis is done so that the session state can be restored should a respondent lose an internet connection or close the browser on accident, etc. The responses on each page will not be written to the database until the respondent clicks the next button or if they close the browser.",
    "crumbs": [
      "Documentation",
      "Data Management",
      "Storing Data"
    ]
  },
  {
    "objectID": "docs/system-translations.html",
    "href": "docs/system-translations.html",
    "title": "System Translations",
    "section": "",
    "text": "As of v0.4.2, {surveydown} supports the ability to set the system language for all system messages (i.e. text elements such as button labels and warnings) and to provide the language specific format for date type questions. You can also customize the system messages by providing a translations.yml file in your root project directory.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "System Translations"
    ]
  },
  {
    "objectID": "docs/system-translations.html#setting-the-language",
    "href": "docs/system-translations.html#setting-the-language",
    "title": "System Translations",
    "section": "Setting the Language",
    "text": "Setting the Language\nTo set the language of your survey, you can either define the system-language key in YAML of survey.qmd, or use the system_language argument in the sd_server() function in your app.R file. For example, to set the survey language to Spanish, you would write:\nEither in YAML of survey.qmd:\n---\nsystem-language: es\n---\nOr in the app.R file:\n\nserver &lt;- function(input, output, session) {\n  sd_server(\n    system_language = \"es\"\n  )\n}\n\nWhen setting the language, make sure to use a valid language code. The list of supported language codes is the same as those supported by Shiny’s dateInput() (a full list of codes is provided at the bottom of this page).\nFor now, {surveydown} comes with built-in translations for the following languages:\n\n\nen - English (Default)\n\nde - German\n\nes - Spanish\n\nfr - French\n\nit - Italian\n\nzh-CN - Chinese (Simplified)\n\nThese translations cover all system messages, meaning you can simply set the language and all default messages should be in the chosen language.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "System Translations"
    ]
  },
  {
    "objectID": "docs/system-translations.html#custom-messages",
    "href": "docs/system-translations.html#custom-messages",
    "title": "System Translations",
    "section": "Custom Messages",
    "text": "Custom Messages\nIf you want to customize the system translations or provide translations in a language that is not yet supported, you can create a translations.yml file in the root folder of your survey project using the following function:\n\nsurveydown::sd_create_translations(language = 'en')\n\nThis will create a file named translations.yml in your root project directory with the language set to whatever you provided as the language argument. You can modify any of the system messages in this file to be used in your survey.\nBelow is an example of the translations.yml file for all default English messages. The keys represent the system message identifiers, and the values are the translated messages:\nen:\n  cancel: Cancel\n  confirm_exit: Confirm Exit\n  sure_exit: Are you sure you want to exit the survey?\n  submit_exit: Submit and Exit\n  warning: Warning\n  required: Please answer all required questions before proceeding.\n  rating_title: Before you go...\n  rating_text: 'Rate your survey experience:'\n  rating_scale: from 1-poor to 5-excellent\n  next: Next\n  exit: Exit Survey\n  close_tab: Please close this tab manually to exit the survey.\n  choose_option: Choose an option...\n  click: Click here\n  redirect: Redirecting in\n  seconds: seconds\n  new_tab: Opens in a new tab\n  redirect_error: 'Error: This text won''t trigger any redirection...'\nWhen you run your survey, {surveydown} will detect the translations.yml file in your root folder and use it to override the default translations. If you provide translations for a language not supported by default, you can use the language argument in sd_server() to set your custom language code. Note that the chosen language still must be from the current list of supported languages.\nFor example, suppose you added translations for Portuguese in your translations.yml:\npt:\n  next: 'Próximo'\n  exit: 'Sair da Pesquisa'\n  # ... other messages\nIn your app.R file, set the language to Portuguese:\n\nserver &lt;- function(input, output, session) {\n  sd_server(\n    language = \"pt\"\n  )\n}\n\nIt is also possible to have multiple translations for different translations in a single translations.yml file and simply select the required language one within the sd_server() function with the matching country code.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "System Translations"
    ]
  },
  {
    "objectID": "docs/system-translations.html#overriding-specific-messages",
    "href": "docs/system-translations.html#overriding-specific-messages",
    "title": "System Translations",
    "section": "Overriding Specific Messages",
    "text": "Overriding Specific Messages\nYou don’t have to provide translations for all system messages. If you only want to change specific messages, you can provide translations only for those messages, and {surveydown} will use the default translations for any missing messages.\nFor example, to customize only all “Next” button label in English, you could include the following in your translations.yml file:\nen:\n  next: 'Continue'\nSince English is the default language, the language doesn’t even have to be defined in the sd_server() function in this case.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "System Translations"
    ]
  },
  {
    "objectID": "docs/system-translations.html#button-defaults",
    "href": "docs/system-translations.html#button-defaults",
    "title": "System Translations",
    "section": "Button Defaults",
    "text": "Button Defaults\nThe translations also apply to default labels in sd_next(), sd_close(), and sd_redirect(). For example, if you use sd_next() without specifying a label, it will use the translated label based on the chosen language.\n\n# In your survey.qmd file\n\n# This will display \"Weiter\" if language is set to \"de\" in your app.R file\nsd_next()\n\nHowever, it is still possible to manually adjust the translations in the mentioned functions inside the survey.qmd file using the label argument for each case.\n\n\n\n\n\n\nNote\n\n\n\nIf you separately render your survey.qmd file before running your app.R file, these buttons messages may appear in English in the rendered survey.html file in your root project folder. This is because the survey file doesn’t “know” the language setting until you locally run your app.R at least once. But don’t worry - just run the app.R file once and the language will then be set. Also, the language setting will always be used when the app is run regardless of what the local survey.html file looks like.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "System Translations"
    ]
  },
  {
    "objectID": "docs/system-translations.html#notes",
    "href": "docs/system-translations.html#notes",
    "title": "System Translations",
    "section": "Notes",
    "text": "Notes\n\nWhen providing custom translations, make sure the keys match exactly the expected message identifiers.\nIf you create the translations.yml file manually, please note that each text element containing a : character must be written in quotation marks and the last line must contain a line break.\nIf you provide an invalid language code in language, {surveydown} will fall back to English.\nIf a message is not translated in your translations.yml file, {surveydown} will use the default translation for that message.",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "System Translations"
    ]
  },
  {
    "objectID": "docs/system-translations.html#full-language-code-list",
    "href": "docs/system-translations.html#full-language-code-list",
    "title": "System Translations",
    "section": "Full Language Code List",
    "text": "Full Language Code List\nThe full list of supported language codes can be found in the documentation for shiny::dateInput(). We list them here as a quick reference:\n\n\nar - Arabic\n\naz - Azerbaijani\n\nbg - Bulgarian\n\nbs - Bosnian\n\nca - Catalan\n\ncs - Czech\n\ncy - Welsh\n\nda - Danish\n\nde - German\n\nel - Greek\n\nen - English (Default)\n\nen-AU - English (Australia)\n\nen-GB - English (UK)\n\neo - Esperanto\n\nes - Spanish\n\net - Estonian\n\neu - Basque\n\nfa - Persian\n\nfi - Finnish\n\nfo - Faroese\n\nfr - French\n\nfr-CH - French (Switzerland)\n\ngl - Galician\n\nhe - Hebrew\n\nhr - Croatian\n\nhu - Hungarian\n\nhy - Armenian\n\nid - Indonesian\n\nis - Icelandic\n\nit - Italian\n\nit-CH - Italian (Switzerland)\n\nja - Japanese\n\nka - Georgian\n\nkh - Khmer\n\nkk - Kazakh\n\nko - Korean\n\nkr - Korean\n\nlt - Lithuanian\n\nlv - Latvian\n\nme - Montenegrin\n\nmk - Macedonian\n\nmn - Mongolian\n\nms - Malay\n\nnb - Norwegian Bokmål\n\nnl - Dutch\n\nnl-BE - Dutch (Belgium)\n\nno - Norwegian\n\npl - Polish\n\npt - Portuguese\n\npt-BR - Portuguese (Brazil)\n\nro - Romanian\n\nrs - Serbian\n\nrs-latin - Serbian (Latin)\n\nru - Russian\n\nsk - Slovak\n\nsl - Slovenian\n\nsq - Albanian\n\nsr - Serbian\n\nsr-latin - Serbian (Latin)\n\nsv - Swedish\n\nsw - Swahili\n\nth - Thai\n\ntr - Turkish\n\nuk - Ukrainian\n\nvi - Vietnamese\n\nzh-CN - Chinese (Simplified)\n\nzh-TW - Chinese (Traditional)",
    "crumbs": [
      "Documentation",
      "Survey Design Concepts",
      "System Translations"
    ]
  },
  {
    "objectID": "docs/troubleshooting.html",
    "href": "docs/troubleshooting.html",
    "title": "Troubleshooting",
    "section": "",
    "text": "Note\n\n\n\nsurveydown requires some basic setups in order to get running. If you find glitches or failures, this page is for you.",
    "crumbs": [
      "Documentation",
      "Other",
      "Troubleshooting"
    ]
  },
  {
    "objectID": "docs/troubleshooting.html#r-rstudio",
    "href": "docs/troubleshooting.html#r-rstudio",
    "title": "Troubleshooting",
    "section": "R & RStudio",
    "text": "R & RStudio\nMake sure you have installed the up-to-date versions of R and RStudio. Both can be installed via this link.\nR is the coding language that supports surveydown, and RStudio is the IDE that runs R. Other than RStudio, you can also choose VS Code or Positron. These two IDEs are both open to multiple coding languages, with R included and highly supported.",
    "crumbs": [
      "Documentation",
      "Other",
      "Troubleshooting"
    ]
  },
  {
    "objectID": "docs/troubleshooting.html#quarto",
    "href": "docs/troubleshooting.html#quarto",
    "title": "Troubleshooting",
    "section": "Quarto",
    "text": "Quarto\nQuarto is a publication system that supports Markdown and code scripts. surveydown uses Quarto to turn scripts into nicely formatted survey pages.\nSometimes, glitches of your quarto rendering can be simply solved by an update. To install or update Quarto, go to this page and click on the big download button.",
    "crumbs": [
      "Documentation",
      "Other",
      "Troubleshooting"
    ]
  },
  {
    "objectID": "docs/troubleshooting.html#r-packages",
    "href": "docs/troubleshooting.html#r-packages",
    "title": "Troubleshooting",
    "section": "R Packages",
    "text": "R Packages\nAfter you’ve installed all the above environments, it’s time to take care of the R packages. The function we use to install R packages is install.packages(), and is thus used a lot in this section. You might want to re-run this function for these packages in order to get the most recent version.\nLaunch the R Console\nThe R Console is used to run R codes as well as install R packages. It can be launched by one of the 2 ways:\n\n\nRStudio\nTerminal\n\n\n\nLaunch an RStudio session and you’ll find your R Console in it. It’s located at the bottom left by default.\n\n\n\n\n\nLaunch your Terminal and simply type “R” (capitalized) and then Enter.\n\n\n\n\n\n\nShiny\nAll surveydown surveys are Shiny webapps, so Shiny is an essential component.\nIn your R Console, run this to install Shiny:\n\ninstall.packages(\"shiny\")\n\nsurveydown\nIn your R Console, run this to install surveydown:\n\n# CRAN version - stable but might lack the latest features\ninstall.packages(\"surveydown\")\n\n# GitHub version - with the latest features\npak::pak(\"surveydown-dev/surveydown\", ask = FALSE)\n\nThe GitHub version installation requires the pak package. If you don’t have it, install it using:\n\ninstall.packages(\"pak\")\n\n\n\n\n\n\n\nNote\n\n\n\nSometimes neither of these approaches work, often because your path is managed by some package managing system like Anaconda. In this case, a third alternative is to download the zip file of the package source code and then install it locally.\nTo download the zip file, go the the surveydown repo, click on the green “Code” button and click on “Download Zip”, or simplify click on this link.\nUnzip this repo, then open the surveydown.Rproj file. In your R Console panel, run this code to install:\n\n# install.packages(\"pak\")\npak::local_install(ask = FALSE)\n\n\n\nSome useful links:\n\nsurveydown CRAN Page\nsurveydown GitHub repo\nsurveydown installation docs\nsdstudio\nsdstudio is a companion R package with surveydown. It is intended for supportive webapps for surveydown. It has a single function: sdstudio::launch(), which launches the surveydown Studio. This is a locally run shiny app that supports a graphic interface for survey construction, preview, and data management.\nIn your R Console, run this to install sdstudio from GitHub (it’s not yet on CRAN):\n\n# install.packages('pak')\npak::pak(\"surveydown-dev/sdstudio\", ask = FALSE)\n\nOnce installed, run this to launch the studio:\n\nsdstudio::launch()\n\n\n\n\nOther R Packages\nYou might need some other R packages to get your survey running, for example, tidyverse, kableExtra, etc. Likewise, you can use the install.packages() function to install them:\n\ninstall.packages(\"tidyverse\")\ninstall.packages(\"kableExtra\")",
    "crumbs": [
      "Documentation",
      "Other",
      "Troubleshooting"
    ]
  },
  {
    "objectID": "docs/troubleshooting.html#database-connection",
    "href": "docs/troubleshooting.html#database-connection",
    "title": "Troubleshooting",
    "section": "Database Connection",
    "text": "Database Connection\nYou might encounter connection problem caused by failure of GSSAPI (Generic Security Services Application Program Interface). It is a a protection layer for data security supported by PostgreSQL. In SQL management, it is controlled by the gssencmode argument.\nIn previous versions of surveydown (before v0.12.5), the sd_db_connect() and sd_dashboard() functions have a gssencmode default to \"prefer\", which enables GSSAPI, but may cause connection failure under some network conditions (VPN, for example). Our previous solution is to manually change gssencmode from \"prefer\" to \"disable\", but it is less intuitive and causes more trouble than efficiency.\nTherefore, our current solution (versions after v0.12.5) is to remove the gssencmode argument from these functions, in which the GSSAPI is set to \"prefer\" by default, but if the connection errors due to network problem, it will auto-switch to \"disable\" and leave a message.",
    "crumbs": [
      "Documentation",
      "Other",
      "Troubleshooting"
    ]
  },
  {
    "objectID": "docs/troubleshooting.html#still-cant-deploy",
    "href": "docs/troubleshooting.html#still-cant-deploy",
    "title": "Troubleshooting",
    "section": "Still Can’t Deploy?",
    "text": "Still Can’t Deploy?\nIf your shinyapps deployment fails, you should firstly make sure your Supabase credentials are correctly defined, including your Supabase project settings and password settings. The password defined by sd_db_config() should be the same as your Supabase project password. Access the Storing Data page for how to set all Supabase credentials. Then, make sure your survey runs on your local machine and can successfully link with your Supabase project table. With these confirmed, your shinyapps deployment should work without problem.\nIf you still encounter an error (e.g., the page shows the app failed to start, or you see the page but it doesn’t run properly), try clearing your cache. The simplest way to do so is to reboot your computer. It may also help if you delete previously generated files, such as the survey.html file if you rendered it and the rsconnect folder. After re-rendering, you should be able to deploy the app without error.",
    "crumbs": [
      "Documentation",
      "Other",
      "Troubleshooting"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to surveydown.org!",
    "section": "",
    "text": "Welcome to surveydown.org!\nsurveydown is a flexible, open-source platform for making programmable, markdown-based surveys with , Quarto, Shiny, and PostgreSQL.\nThe  package deployment site can be accessed here.\n\n\n\n\n\nAbout the package and the open-source technologies behind it.\n\n\nABOUT\n\n\n\n\n\n\n\n\nTemplates for an easy start.\n\n\nTEMPLATES\n\n\n\n\n\n\n\n\nComprehensive documentation for building surveys with surveydown.\n\n\nDOCUMENTATION\n\n\n\n\n\n\n\n\nFrequently asked questions.\n\n\nFAQ"
  },
  {
    "objectID": "templates/conditional_showing.html",
    "href": "templates/conditional_showing.html",
    "title": "Conditional Showing",
    "section": "",
    "text": "To create this template, run this command in your R console:\n\nsurveydown::sd_create_survey(\n  #path = \"path/to/survey\",\n  template = \"conditional_showing\"\n)\n\nRefer to the Start with a template section for more details.\n\n Open in New Tab  GitHub Repo\n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Templates",
      "Conditions",
      "Conditional Showing"
    ]
  },
  {
    "objectID": "templates/conditional_stopping.html",
    "href": "templates/conditional_stopping.html",
    "title": "Conditional Stopping",
    "section": "",
    "text": "To create this template, run this command in your R console:\n\nsurveydown::sd_create_survey(\n  #path = \"path/to/survey\",\n  template = \"conditional_stopping\"\n)\n\nRefer to the Start with a template section for more details.\n\n Open in New Tab  GitHub Repo\n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Templates",
      "Conditions",
      "Conditional Stopping"
    ]
  },
  {
    "objectID": "templates/conjoint_tables.html",
    "href": "templates/conjoint_tables.html",
    "title": "Choice-based-conjoint Survey with Tables",
    "section": "",
    "text": "To create this template, run this command in your R console:\n\nsurveydown::sd_create_survey(\n  #path = \"path/to/survey\",\n  template = \"conjoint_tables\"\n)\n\nRefer to the Start with a template section for more details.\n\n Open in New Tab  GitHub Repo\n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Templates",
      "Conjoint",
      "Conjoint Tables"
    ]
  },
  {
    "objectID": "templates/custom_plotly_chart.html",
    "href": "templates/custom_plotly_chart.html",
    "title": "Custom Plotly Chart",
    "section": "",
    "text": "To create this template, run this command in your R console:\n\nsurveydown::sd_create_survey(\n  #path = \"path/to/survey\",\n  template = \"custom_plotly_chart\"\n)\n\nRefer to the Start with a template section for more details.\n\n Open in New Tab  GitHub Repo\n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Templates",
      "Custom",
      "Custom Plotly Chart"
    ]
  },
  {
    "objectID": "templates/external_redirect.html",
    "href": "templates/external_redirect.html",
    "title": "External Redirect",
    "section": "",
    "text": "To create this template, run this command in your R console:\n\nsurveydown::sd_create_survey(\n  #path = \"path/to/survey\",\n  template = \"external_redirect\"\n)\n\nRefer to the Start with a template section for more details.\n\n Open in New Tab  GitHub Repo\n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Templates",
      "Reactivity",
      "External Redirect"
    ]
  },
  {
    "objectID": "templates/question_types.html",
    "href": "templates/question_types.html",
    "title": "Question Types",
    "section": "",
    "text": "To create this template, run this command in your R console:\n\nsurveydown::sd_create_survey(\n  #path = \"path/to/survey\",\n  template = \"question_types\"\n)\n\nRefer to the Start with a template section for more details.\n\n Open in New Tab  GitHub Repo\n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Templates",
      "Basic",
      "Question Types"
    ]
  },
  {
    "objectID": "templates/random_options.html",
    "href": "templates/random_options.html",
    "title": "Random Options",
    "section": "",
    "text": "To create this template, run this command in your R console:\n\nsurveydown::sd_create_survey(\n  #path = \"path/to/survey\",\n  template = \"random_options\"\n)\n\nRefer to the Start with a template section for more details.\n\n Open in New Tab  GitHub Repo\n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Templates",
      "Randomization",
      "Random Options"
    ]
  },
  {
    "objectID": "templates/reactive_drilldown.html",
    "href": "templates/reactive_drilldown.html",
    "title": "Reactive drilldown",
    "section": "",
    "text": "To create this template, run this command in your R console:\n\nsurveydown::sd_create_survey(\n  #path = \"path/to/survey\",\n  template = \"reactive_drilldown\"\n)\n\nRefer to the Start with a template section for more details.\n\n Open in New Tab  GitHub Repo\n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Templates",
      "Reactivity",
      "Reactive drilldown"
    ]
  }
]